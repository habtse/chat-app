"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-hook-form";
exports.ids = ["vendor-chunks/react-hook-form"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-hook-form/dist/index.esm.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/react-hook-form/dist/index.esm.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Controller: () => (/* binding */ Controller),\n/* harmony export */   Form: () => (/* binding */ Form),\n/* harmony export */   FormProvider: () => (/* binding */ FormProvider),\n/* harmony export */   Watch: () => (/* binding */ Watch),\n/* harmony export */   appendErrors: () => (/* binding */ appendErrors),\n/* harmony export */   createFormControl: () => (/* binding */ createFormControl),\n/* harmony export */   get: () => (/* binding */ get),\n/* harmony export */   set: () => (/* binding */ set),\n/* harmony export */   useController: () => (/* binding */ useController),\n/* harmony export */   useFieldArray: () => (/* binding */ useFieldArray),\n/* harmony export */   useForm: () => (/* binding */ useForm),\n/* harmony export */   useFormContext: () => (/* binding */ useFormContext),\n/* harmony export */   useFormState: () => (/* binding */ useFormState),\n/* harmony export */   useWatch: () => (/* binding */ useWatch)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\nvar isCheckBoxInput = (element)=>element.type === \"checkbox\";\nvar isDateObject = (value1)=>value1 instanceof Date;\nvar isNullOrUndefined = (value1)=>value1 == null;\nconst isObjectType = (value1)=>typeof value1 === \"object\";\nvar isObject = (value1)=>!isNullOrUndefined(value1) && !Array.isArray(value1) && isObjectType(value1) && !isDateObject(value1);\nvar getEventValue = (event)=>isObject(event) && event.target ? isCheckBoxInput(event.target) ? event.target.checked : event.target.value : event;\nvar getNodeParentName = (name)=>name.substring(0, name.search(/\\.\\d+(\\.|$)/)) || name;\nvar isNameInFieldArray = (names, name)=>names.has(getNodeParentName(name));\nvar isPlainObject = (tempObject)=>{\n    const prototypeCopy = tempObject.constructor && tempObject.constructor.prototype;\n    return isObject(prototypeCopy) && prototypeCopy.hasOwnProperty(\"isPrototypeOf\");\n};\nvar isWeb =  false && 0;\nfunction cloneObject(data) {\n    let copy;\n    const isArray = Array.isArray(data);\n    const isFileListInstance = typeof FileList !== \"undefined\" ? data instanceof FileList : false;\n    if (data instanceof Date) {\n        copy = new Date(data);\n    } else if (!(isWeb && (data instanceof Blob || isFileListInstance)) && (isArray || isObject(data))) {\n        copy = isArray ? [] : Object.create(Object.getPrototypeOf(data));\n        if (!isArray && !isPlainObject(data)) {\n            copy = data;\n        } else {\n            for(const key in data){\n                if (data.hasOwnProperty(key)) {\n                    copy[key] = cloneObject(data[key]);\n                }\n            }\n        }\n    } else {\n        return data;\n    }\n    return copy;\n}\nvar isKey = (value1)=>/^\\w*$/.test(value1);\nvar isUndefined = (val)=>val === undefined;\nvar compact = (value1)=>Array.isArray(value1) ? value1.filter(Boolean) : [];\nvar stringToPath = (input)=>compact(input.replace(/[\"|']|\\]/g, \"\").split(/\\.|\\[/));\nvar get = (object, path, defaultValue)=>{\n    if (!path || !isObject(object)) {\n        return defaultValue;\n    }\n    const result = (isKey(path) ? [\n        path\n    ] : stringToPath(path)).reduce((result, key)=>isNullOrUndefined(result) ? result : result[key], object);\n    return isUndefined(result) || result === object ? isUndefined(object[path]) ? defaultValue : object[path] : result;\n};\nvar isBoolean = (value1)=>typeof value1 === \"boolean\";\nvar set = (object, path, value1)=>{\n    let index = -1;\n    const tempPath = isKey(path) ? [\n        path\n    ] : stringToPath(path);\n    const length = tempPath.length;\n    const lastIndex = length - 1;\n    while(++index < length){\n        const key = tempPath[index];\n        let newValue = value1;\n        if (index !== lastIndex) {\n            const objValue = object[key];\n            newValue = isObject(objValue) || Array.isArray(objValue) ? objValue : !isNaN(+tempPath[index + 1]) ? [] : {};\n        }\n        if (key === \"__proto__\" || key === \"constructor\" || key === \"prototype\") {\n            return;\n        }\n        object[key] = newValue;\n        object = object[key];\n    }\n};\nconst EVENTS = {\n    BLUR: \"blur\",\n    FOCUS_OUT: \"focusout\",\n    CHANGE: \"change\"\n};\nconst VALIDATION_MODE = {\n    onBlur: \"onBlur\",\n    onChange: \"onChange\",\n    onSubmit: \"onSubmit\",\n    onTouched: \"onTouched\",\n    all: \"all\"\n};\nconst INPUT_VALIDATION_RULES = {\n    max: \"max\",\n    min: \"min\",\n    maxLength: \"maxLength\",\n    minLength: \"minLength\",\n    pattern: \"pattern\",\n    required: \"required\",\n    validate: \"validate\"\n};\nconst HookFormContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nHookFormContext.displayName = \"HookFormContext\";\n/**\n * This custom hook allows you to access the form context. useFormContext is intended to be used in deeply nested structures, where it would become inconvenient to pass the context as a prop. To be used with {@link FormProvider}.\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/useformcontext) • [Demo](https://codesandbox.io/s/react-hook-form-v7-form-context-ytudi)\n *\n * @returns return all useForm methods\n *\n * @example\n * ```tsx\n * function App() {\n *   const methods = useForm();\n *   const onSubmit = data => console.log(data);\n *\n *   return (\n *     <FormProvider {...methods} >\n *       <form onSubmit={methods.handleSubmit(onSubmit)}>\n *         <NestedInput />\n *         <input type=\"submit\" />\n *       </form>\n *     </FormProvider>\n *   );\n * }\n *\n *  function NestedInput() {\n *   const { register } = useFormContext(); // retrieve all hook methods\n *   return <input {...register(\"test\")} />;\n * }\n * ```\n */ const useFormContext = ()=>react__WEBPACK_IMPORTED_MODULE_0__.useContext(HookFormContext);\n/**\n * A provider component that propagates the `useForm` methods to all children components via [React Context](https://react.dev/reference/react/useContext) API. To be used with {@link useFormContext}.\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/useformcontext) • [Demo](https://codesandbox.io/s/react-hook-form-v7-form-context-ytudi)\n *\n * @param props - all useForm methods\n *\n * @example\n * ```tsx\n * function App() {\n *   const methods = useForm();\n *   const onSubmit = data => console.log(data);\n *\n *   return (\n *     <FormProvider {...methods} >\n *       <form onSubmit={methods.handleSubmit(onSubmit)}>\n *         <NestedInput />\n *         <input type=\"submit\" />\n *       </form>\n *     </FormProvider>\n *   );\n * }\n *\n *  function NestedInput() {\n *   const { register } = useFormContext(); // retrieve all hook methods\n *   return <input {...register(\"test\")} />;\n * }\n * ```\n */ const FormProvider = (props)=>{\n    const { children, ...data } = props;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(HookFormContext.Provider, {\n        value: data\n    }, children);\n};\nvar getProxyFormState = (formState, control, localProxyFormState, isRoot = true)=>{\n    const result = {\n        defaultValues: control._defaultValues\n    };\n    for(const key in formState){\n        Object.defineProperty(result, key, {\n            get: ()=>{\n                const _key = key;\n                if (control._proxyFormState[_key] !== VALIDATION_MODE.all) {\n                    control._proxyFormState[_key] = !isRoot || VALIDATION_MODE.all;\n                }\n                localProxyFormState && (localProxyFormState[_key] = true);\n                return formState[_key];\n            }\n        });\n    }\n    return result;\n};\nconst useIsomorphicLayoutEffect =  false ? 0 : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\n/**\n * This custom hook allows you to subscribe to each form state, and isolate the re-render at the custom hook level. It has its scope in terms of form state subscription, so it would not affect other useFormState and useForm. Using this hook can reduce the re-render impact on large and complex form application.\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/useformstate) • [Demo](https://codesandbox.io/s/useformstate-75xly)\n *\n * @param props - include options on specify fields to subscribe. {@link UseFormStateReturn}\n *\n * @example\n * ```tsx\n * function App() {\n *   const { register, handleSubmit, control } = useForm({\n *     defaultValues: {\n *     firstName: \"firstName\"\n *   }});\n *   const { dirtyFields } = useFormState({\n *     control\n *   });\n *   const onSubmit = (data) => console.log(data);\n *\n *   return (\n *     <form onSubmit={handleSubmit(onSubmit)}>\n *       <input {...register(\"firstName\")} placeholder=\"First Name\" />\n *       {dirtyFields.firstName && <p>Field is dirty.</p>}\n *       <input type=\"submit\" />\n *     </form>\n *   );\n * }\n * ```\n */ function useFormState(props) {\n    const methods = useFormContext();\n    const { control = methods.control, disabled, name, exact } = props || {};\n    const [formState, updateFormState] = react__WEBPACK_IMPORTED_MODULE_0__.useState(control._formState);\n    const _localProxyFormState = react__WEBPACK_IMPORTED_MODULE_0__.useRef({\n        isDirty: false,\n        isLoading: false,\n        dirtyFields: false,\n        touchedFields: false,\n        validatingFields: false,\n        isValidating: false,\n        isValid: false,\n        errors: false\n    });\n    useIsomorphicLayoutEffect(()=>control._subscribe({\n            name,\n            formState: _localProxyFormState.current,\n            exact,\n            callback: (formState)=>{\n                !disabled && updateFormState({\n                    ...control._formState,\n                    ...formState\n                });\n            }\n        }), [\n        name,\n        disabled,\n        exact\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        _localProxyFormState.current.isValid && control._setValid(true);\n    }, [\n        control\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>getProxyFormState(formState, control, _localProxyFormState.current, false), [\n        formState,\n        control\n    ]);\n}\nvar isString = (value1)=>typeof value1 === \"string\";\nvar generateWatchOutput = (names, _names, formValues, isGlobal, defaultValue)=>{\n    if (isString(names)) {\n        isGlobal && _names.watch.add(names);\n        return get(formValues, names, defaultValue);\n    }\n    if (Array.isArray(names)) {\n        return names.map((fieldName)=>(isGlobal && _names.watch.add(fieldName), get(formValues, fieldName)));\n    }\n    isGlobal && (_names.watchAll = true);\n    return formValues;\n};\nvar isPrimitive = (value1)=>isNullOrUndefined(value1) || !isObjectType(value1);\nfunction deepEqual(object1, object2, _internal_visited = new WeakSet()) {\n    if (isPrimitive(object1) || isPrimitive(object2)) {\n        return Object.is(object1, object2);\n    }\n    if (isDateObject(object1) && isDateObject(object2)) {\n        return object1.getTime() === object2.getTime();\n    }\n    const keys1 = Object.keys(object1);\n    const keys2 = Object.keys(object2);\n    if (keys1.length !== keys2.length) {\n        return false;\n    }\n    if (_internal_visited.has(object1) || _internal_visited.has(object2)) {\n        return true;\n    }\n    _internal_visited.add(object1);\n    _internal_visited.add(object2);\n    for (const key of keys1){\n        const val1 = object1[key];\n        if (!keys2.includes(key)) {\n            return false;\n        }\n        if (key !== \"ref\") {\n            const val2 = object2[key];\n            if (isDateObject(val1) && isDateObject(val2) || isObject(val1) && isObject(val2) || Array.isArray(val1) && Array.isArray(val2) ? !deepEqual(val1, val2, _internal_visited) : !Object.is(val1, val2)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n/**\n * Custom hook to subscribe to field change and isolate re-rendering at the component level.\n *\n * @remarks\n *\n * [API](https://react-hook-form.com/docs/usewatch) • [Demo](https://codesandbox.io/s/react-hook-form-v7-ts-usewatch-h9i5e)\n *\n * @example\n * ```tsx\n * const { control } = useForm();\n * const values = useWatch({\n *   name: \"fieldName\"\n *   control,\n * })\n * ```\n */ function useWatch(props) {\n    const methods = useFormContext();\n    const { control = methods.control, name, defaultValue, disabled, exact, compute } = props || {};\n    const _defaultValue = react__WEBPACK_IMPORTED_MODULE_0__.useRef(defaultValue);\n    const _compute = react__WEBPACK_IMPORTED_MODULE_0__.useRef(compute);\n    const _computeFormValues = react__WEBPACK_IMPORTED_MODULE_0__.useRef(undefined);\n    const _prevControl = react__WEBPACK_IMPORTED_MODULE_0__.useRef(control);\n    const _prevName = react__WEBPACK_IMPORTED_MODULE_0__.useRef(name);\n    _compute.current = compute;\n    const [value1, updateValue] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>{\n        const defaultValue = control._getWatch(name, _defaultValue.current);\n        return _compute.current ? _compute.current(defaultValue) : defaultValue;\n    });\n    const getCurrentOutput = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((values)=>{\n        const formValues = generateWatchOutput(name, control._names, values || control._formValues, false, _defaultValue.current);\n        return _compute.current ? _compute.current(formValues) : formValues;\n    }, [\n        control._formValues,\n        control._names,\n        name\n    ]);\n    const refreshValue = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((values)=>{\n        if (!disabled) {\n            const formValues = generateWatchOutput(name, control._names, values || control._formValues, false, _defaultValue.current);\n            if (_compute.current) {\n                const computedFormValues = _compute.current(formValues);\n                if (!deepEqual(computedFormValues, _computeFormValues.current)) {\n                    updateValue(computedFormValues);\n                    _computeFormValues.current = computedFormValues;\n                }\n            } else {\n                updateValue(formValues);\n            }\n        }\n    }, [\n        control._formValues,\n        control._names,\n        disabled,\n        name\n    ]);\n    useIsomorphicLayoutEffect(()=>{\n        if (_prevControl.current !== control || !deepEqual(_prevName.current, name)) {\n            _prevControl.current = control;\n            _prevName.current = name;\n            refreshValue();\n        }\n        return control._subscribe({\n            name,\n            formState: {\n                values: true\n            },\n            exact,\n            callback: (formState)=>{\n                refreshValue(formState.values);\n            }\n        });\n    }, [\n        control,\n        exact,\n        name,\n        refreshValue\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>control._removeUnmounted());\n    // If name or control changed for this render, synchronously reflect the\n    // latest value so callers (like useController) see the correct value\n    // immediately on the same render.\n    // Optimize: Check control reference first before expensive deepEqual\n    const controlChanged = _prevControl.current !== control;\n    const prevName = _prevName.current;\n    // Cache the computed output to avoid duplicate calls within the same render\n    // We include shouldReturnImmediate in deps to ensure proper recomputation\n    const computedOutput = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        if (disabled) {\n            return null;\n        }\n        const nameChanged = !controlChanged && !deepEqual(prevName, name);\n        const shouldReturnImmediate = controlChanged || nameChanged;\n        return shouldReturnImmediate ? getCurrentOutput() : null;\n    }, [\n        disabled,\n        controlChanged,\n        name,\n        prevName,\n        getCurrentOutput\n    ]);\n    return computedOutput !== null ? computedOutput : value1;\n}\n/**\n * Custom hook to work with controlled component, this function provide you with both form and field level state. Re-render is isolated at the hook level.\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/usecontroller) • [Demo](https://codesandbox.io/s/usecontroller-0o8px)\n *\n * @param props - the path name to the form field value, and validation rules.\n *\n * @returns field properties, field and form state. {@link UseControllerReturn}\n *\n * @example\n * ```tsx\n * function Input(props) {\n *   const { field, fieldState, formState } = useController(props);\n *   return (\n *     <div>\n *       <input {...field} placeholder={props.name} />\n *       <p>{fieldState.isTouched && \"Touched\"}</p>\n *       <p>{formState.isSubmitted ? \"submitted\" : \"\"}</p>\n *     </div>\n *   );\n * }\n * ```\n */ function useController(props) {\n    const methods = useFormContext();\n    const { name, disabled, control = methods.control, shouldUnregister, defaultValue, exact = true } = props;\n    const isArrayField = isNameInFieldArray(control._names.array, name);\n    const defaultValueMemo = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>get(control._formValues, name, get(control._defaultValues, name, defaultValue)), [\n        control,\n        name,\n        defaultValue\n    ]);\n    const value1 = useWatch({\n        control,\n        name,\n        defaultValue: defaultValueMemo,\n        exact\n    });\n    const formState = useFormState({\n        control,\n        name,\n        exact\n    });\n    const _props = react__WEBPACK_IMPORTED_MODULE_0__.useRef(props);\n    const _previousNameRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(undefined);\n    const _registerProps = react__WEBPACK_IMPORTED_MODULE_0__.useRef(control.register(name, {\n        ...props.rules,\n        value: value1,\n        ...isBoolean(props.disabled) ? {\n            disabled: props.disabled\n        } : {}\n    }));\n    _props.current = props;\n    const fieldState = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>Object.defineProperties({}, {\n            invalid: {\n                enumerable: true,\n                get: ()=>!!get(formState.errors, name)\n            },\n            isDirty: {\n                enumerable: true,\n                get: ()=>!!get(formState.dirtyFields, name)\n            },\n            isTouched: {\n                enumerable: true,\n                get: ()=>!!get(formState.touchedFields, name)\n            },\n            isValidating: {\n                enumerable: true,\n                get: ()=>!!get(formState.validatingFields, name)\n            },\n            error: {\n                enumerable: true,\n                get: ()=>get(formState.errors, name)\n            }\n        }), [\n        formState,\n        name\n    ]);\n    const onChange = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((event)=>_registerProps.current.onChange({\n            target: {\n                value: getEventValue(event),\n                name: name\n            },\n            type: EVENTS.CHANGE\n        }), [\n        name\n    ]);\n    const onBlur = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(()=>_registerProps.current.onBlur({\n            target: {\n                value: get(control._formValues, name),\n                name: name\n            },\n            type: EVENTS.BLUR\n        }), [\n        name,\n        control._formValues\n    ]);\n    const ref = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((elm)=>{\n        const field = get(control._fields, name);\n        if (field && elm) {\n            field._f.ref = {\n                focus: ()=>elm.focus && elm.focus(),\n                select: ()=>elm.select && elm.select(),\n                setCustomValidity: (message)=>elm.setCustomValidity(message),\n                reportValidity: ()=>elm.reportValidity()\n            };\n        }\n    }, [\n        control._fields,\n        name\n    ]);\n    const field = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            name,\n            value: value1,\n            ...isBoolean(disabled) || formState.disabled ? {\n                disabled: formState.disabled || disabled\n            } : {},\n            onChange,\n            onBlur,\n            ref\n        }), [\n        name,\n        disabled,\n        formState.disabled,\n        onChange,\n        onBlur,\n        ref,\n        value1\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        const _shouldUnregisterField = control._options.shouldUnregister || shouldUnregister;\n        const previousName = _previousNameRef.current;\n        if (previousName && previousName !== name && !isArrayField) {\n            control.unregister(previousName);\n        }\n        control.register(name, {\n            ..._props.current.rules,\n            ...isBoolean(_props.current.disabled) ? {\n                disabled: _props.current.disabled\n            } : {}\n        });\n        const updateMounted = (name, value1)=>{\n            const field = get(control._fields, name);\n            if (field && field._f) {\n                field._f.mount = value1;\n            }\n        };\n        updateMounted(name, true);\n        if (_shouldUnregisterField) {\n            const value1 = cloneObject(get(control._options.defaultValues, name, _props.current.defaultValue));\n            set(control._defaultValues, name, value1);\n            if (isUndefined(get(control._formValues, name))) {\n                set(control._formValues, name, value1);\n            }\n        }\n        !isArrayField && control.register(name);\n        _previousNameRef.current = name;\n        return ()=>{\n            (isArrayField ? _shouldUnregisterField && !control._state.action : _shouldUnregisterField) ? control.unregister(name) : updateMounted(name, false);\n        };\n    }, [\n        name,\n        control,\n        isArrayField,\n        shouldUnregister\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        control._setDisabledField({\n            disabled,\n            name\n        });\n    }, [\n        disabled,\n        name,\n        control\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            field,\n            formState,\n            fieldState\n        }), [\n        field,\n        formState,\n        fieldState\n    ]);\n}\n/**\n * Component based on `useController` hook to work with controlled component.\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/usecontroller/controller) • [Demo](https://codesandbox.io/s/react-hook-form-v6-controller-ts-jwyzw) • [Video](https://www.youtube.com/watch?v=N2UNk_UCVyA)\n *\n * @param props - the path name to the form field value, and validation rules.\n *\n * @returns provide field handler functions, field and form state.\n *\n * @example\n * ```tsx\n * function App() {\n *   const { control } = useForm<FormValues>({\n *     defaultValues: {\n *       test: \"\"\n *     }\n *   });\n *\n *   return (\n *     <form>\n *       <Controller\n *         control={control}\n *         name=\"test\"\n *         render={({ field: { onChange, onBlur, value, ref }, formState, fieldState }) => (\n *           <>\n *             <input\n *               onChange={onChange} // send value to hook form\n *               onBlur={onBlur} // notify when input is touched\n *               value={value} // return updated value\n *               ref={ref} // set ref for focus management\n *             />\n *             <p>{formState.isSubmitted ? \"submitted\" : \"\"}</p>\n *             <p>{fieldState.isTouched ? \"touched\" : \"\"}</p>\n *           </>\n *         )}\n *       />\n *     </form>\n *   );\n * }\n * ```\n */ const Controller = (props)=>props.render(useController(props));\nconst flatten = (obj)=>{\n    const output = {};\n    for (const key of Object.keys(obj)){\n        if (isObjectType(obj[key]) && obj[key] !== null) {\n            const nested = flatten(obj[key]);\n            for (const nestedKey of Object.keys(nested)){\n                output[`${key}.${nestedKey}`] = nested[nestedKey];\n            }\n        } else {\n            output[key] = obj[key];\n        }\n    }\n    return output;\n};\nconst POST_REQUEST = \"post\";\n/**\n * Form component to manage submission.\n *\n * @param props - to setup submission detail. {@link FormProps}\n *\n * @returns form component or headless render prop.\n *\n * @example\n * ```tsx\n * function App() {\n *   const { control, formState: { errors } } = useForm();\n *\n *   return (\n *     <Form action=\"/api\" control={control}>\n *       <input {...register(\"name\")} />\n *       <p>{errors?.root?.server && 'Server error'}</p>\n *       <button>Submit</button>\n *     </Form>\n *   );\n * }\n * ```\n */ function Form(props) {\n    const methods = useFormContext();\n    const [mounted, setMounted] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n    const { control = methods.control, onSubmit, children, action, method = POST_REQUEST, headers, encType, onError, render, onSuccess, validateStatus, ...rest } = props;\n    const submit = async (event)=>{\n        let hasError = false;\n        let type = \"\";\n        await control.handleSubmit(async (data)=>{\n            const formData = new FormData();\n            let formDataJson = \"\";\n            try {\n                formDataJson = JSON.stringify(data);\n            } catch (_a) {}\n            const flattenFormValues = flatten(control._formValues);\n            for(const key in flattenFormValues){\n                formData.append(key, flattenFormValues[key]);\n            }\n            if (onSubmit) {\n                await onSubmit({\n                    data,\n                    event,\n                    method,\n                    formData,\n                    formDataJson\n                });\n            }\n            if (action) {\n                try {\n                    const shouldStringifySubmissionData = [\n                        headers && headers[\"Content-Type\"],\n                        encType\n                    ].some((value1)=>value1 && value1.includes(\"json\"));\n                    const response = await fetch(String(action), {\n                        method,\n                        headers: {\n                            ...headers,\n                            ...encType && encType !== \"multipart/form-data\" ? {\n                                \"Content-Type\": encType\n                            } : {}\n                        },\n                        body: shouldStringifySubmissionData ? formDataJson : formData\n                    });\n                    if (response && (validateStatus ? !validateStatus(response.status) : response.status < 200 || response.status >= 300)) {\n                        hasError = true;\n                        onError && onError({\n                            response\n                        });\n                        type = String(response.status);\n                    } else {\n                        onSuccess && onSuccess({\n                            response\n                        });\n                    }\n                } catch (error) {\n                    hasError = true;\n                    onError && onError({\n                        error\n                    });\n                }\n            }\n        })(event);\n        if (hasError && props.control) {\n            props.control._subjects.state.next({\n                isSubmitSuccessful: false\n            });\n            props.control.setError(\"root.server\", {\n                type\n            });\n        }\n    };\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        setMounted(true);\n    }, []);\n    return render ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, render({\n        submit\n    })) : /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"form\", {\n        noValidate: mounted,\n        action: action,\n        method: method,\n        encType: encType,\n        onSubmit: submit,\n        ...rest\n    }, children);\n}\nvar appendErrors = (name, validateAllFieldCriteria, errors, type, message)=>validateAllFieldCriteria ? {\n        ...errors[name],\n        types: {\n            ...errors[name] && errors[name].types ? errors[name].types : {},\n            [type]: message || true\n        }\n    } : {};\nvar convertToArrayPayload = (value1)=>Array.isArray(value1) ? value1 : [\n        value1\n    ];\nvar createSubject = ()=>{\n    let _observers = [];\n    const next = (value1)=>{\n        for (const observer of _observers){\n            observer.next && observer.next(value1);\n        }\n    };\n    const subscribe = (observer)=>{\n        _observers.push(observer);\n        return {\n            unsubscribe: ()=>{\n                _observers = _observers.filter((o)=>o !== observer);\n            }\n        };\n    };\n    const unsubscribe = ()=>{\n        _observers = [];\n    };\n    return {\n        get observers () {\n            return _observers;\n        },\n        next,\n        subscribe,\n        unsubscribe\n    };\n};\nfunction extractFormValues(fieldsState, formValues) {\n    const values = {};\n    for(const key in fieldsState){\n        if (fieldsState.hasOwnProperty(key)) {\n            const fieldState = fieldsState[key];\n            const fieldValue = formValues[key];\n            if (fieldState && isObject(fieldState) && fieldValue) {\n                const nestedFieldsState = extractFormValues(fieldState, fieldValue);\n                if (isObject(nestedFieldsState)) {\n                    values[key] = nestedFieldsState;\n                }\n            } else if (fieldsState[key]) {\n                values[key] = fieldValue;\n            }\n        }\n    }\n    return values;\n}\nvar isEmptyObject = (value1)=>isObject(value1) && !Object.keys(value1).length;\nvar isFileInput = (element)=>element.type === \"file\";\nvar isFunction = (value1)=>typeof value1 === \"function\";\nvar isHTMLElement = (value1)=>{\n    if (!isWeb) {\n        return false;\n    }\n    const owner = value1 ? value1.ownerDocument : 0;\n    return value1 instanceof (owner && owner.defaultView ? owner.defaultView.HTMLElement : HTMLElement);\n};\nvar isMultipleSelect = (element)=>element.type === `select-multiple`;\nvar isRadioInput = (element)=>element.type === \"radio\";\nvar isRadioOrCheckbox = (ref)=>isRadioInput(ref) || isCheckBoxInput(ref);\nvar live = (ref)=>isHTMLElement(ref) && ref.isConnected;\nfunction baseGet(object, updatePath) {\n    const length = updatePath.slice(0, -1).length;\n    let index = 0;\n    while(index < length){\n        object = isUndefined(object) ? index++ : object[updatePath[index++]];\n    }\n    return object;\n}\nfunction isEmptyArray(obj) {\n    for(const key in obj){\n        if (obj.hasOwnProperty(key) && !isUndefined(obj[key])) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction unset(object, path) {\n    const paths = Array.isArray(path) ? path : isKey(path) ? [\n        path\n    ] : stringToPath(path);\n    const childObject = paths.length === 1 ? object : baseGet(object, paths);\n    const index = paths.length - 1;\n    const key = paths[index];\n    if (childObject) {\n        delete childObject[key];\n    }\n    if (index !== 0 && (isObject(childObject) && isEmptyObject(childObject) || Array.isArray(childObject) && isEmptyArray(childObject))) {\n        unset(object, paths.slice(0, -1));\n    }\n    return object;\n}\nvar objectHasFunction = (data)=>{\n    for(const key in data){\n        if (isFunction(data[key])) {\n            return true;\n        }\n    }\n    return false;\n};\nfunction isTraversable(value1) {\n    return Array.isArray(value1) || isObject(value1) && !objectHasFunction(value1);\n}\nfunction markFieldsDirty(data, fields = {}) {\n    for(const key in data){\n        const value1 = data[key];\n        if (isTraversable(value1)) {\n            fields[key] = Array.isArray(value1) ? [] : {};\n            markFieldsDirty(value1, fields[key]);\n        } else if (!isUndefined(value1)) {\n            fields[key] = true;\n        }\n    }\n    return fields;\n}\nfunction getDirtyFields(data, formValues, dirtyFieldsFromValues) {\n    if (!dirtyFieldsFromValues) {\n        dirtyFieldsFromValues = markFieldsDirty(formValues);\n    }\n    for(const key in data){\n        const value1 = data[key];\n        if (isTraversable(value1)) {\n            if (isUndefined(formValues) || isPrimitive(dirtyFieldsFromValues[key])) {\n                dirtyFieldsFromValues[key] = markFieldsDirty(value1, Array.isArray(value1) ? [] : {});\n            } else {\n                getDirtyFields(value1, isNullOrUndefined(formValues) ? {} : formValues[key], dirtyFieldsFromValues[key]);\n            }\n        } else {\n            const formValue = formValues[key];\n            dirtyFieldsFromValues[key] = !deepEqual(value1, formValue);\n        }\n    }\n    return dirtyFieldsFromValues;\n}\nconst defaultResult = {\n    value: false,\n    isValid: false\n};\nconst validResult = {\n    value: true,\n    isValid: true\n};\nvar getCheckboxValue = (options)=>{\n    if (Array.isArray(options)) {\n        if (options.length > 1) {\n            const values = options.filter((option)=>option && option.checked && !option.disabled).map((option)=>option.value);\n            return {\n                value: values,\n                isValid: !!values.length\n            };\n        }\n        return options[0].checked && !options[0].disabled ? options[0].attributes && !isUndefined(options[0].attributes.value) ? isUndefined(options[0].value) || options[0].value === \"\" ? validResult : {\n            value: options[0].value,\n            isValid: true\n        } : validResult : defaultResult;\n    }\n    return defaultResult;\n};\nvar getFieldValueAs = (value1, { valueAsNumber, valueAsDate, setValueAs })=>isUndefined(value1) ? value1 : valueAsNumber ? value1 === \"\" ? NaN : value1 ? +value1 : value1 : valueAsDate && isString(value1) ? new Date(value1) : setValueAs ? setValueAs(value1) : value1;\nconst defaultReturn = {\n    isValid: false,\n    value: null\n};\nvar getRadioValue = (options)=>Array.isArray(options) ? options.reduce((previous, option)=>option && option.checked && !option.disabled ? {\n            isValid: true,\n            value: option.value\n        } : previous, defaultReturn) : defaultReturn;\nfunction getFieldValue(_f) {\n    const ref = _f.ref;\n    if (isFileInput(ref)) {\n        return ref.files;\n    }\n    if (isRadioInput(ref)) {\n        return getRadioValue(_f.refs).value;\n    }\n    if (isMultipleSelect(ref)) {\n        return [\n            ...ref.selectedOptions\n        ].map(({ value: value1 })=>value1);\n    }\n    if (isCheckBoxInput(ref)) {\n        return getCheckboxValue(_f.refs).value;\n    }\n    return getFieldValueAs(isUndefined(ref.value) ? _f.ref.value : ref.value, _f);\n}\nvar getResolverOptions = (fieldsNames, _fields, criteriaMode, shouldUseNativeValidation)=>{\n    const fields = {};\n    for (const name of fieldsNames){\n        const field = get(_fields, name);\n        field && set(fields, name, field._f);\n    }\n    return {\n        criteriaMode,\n        names: [\n            ...fieldsNames\n        ],\n        fields,\n        shouldUseNativeValidation\n    };\n};\nvar isRegex = (value1)=>value1 instanceof RegExp;\nvar getRuleValue = (rule)=>isUndefined(rule) ? rule : isRegex(rule) ? rule.source : isObject(rule) ? isRegex(rule.value) ? rule.value.source : rule.value : rule;\nvar getValidationModes = (mode)=>({\n        isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\n        isOnBlur: mode === VALIDATION_MODE.onBlur,\n        isOnChange: mode === VALIDATION_MODE.onChange,\n        isOnAll: mode === VALIDATION_MODE.all,\n        isOnTouch: mode === VALIDATION_MODE.onTouched\n    });\nconst ASYNC_FUNCTION = \"AsyncFunction\";\nvar hasPromiseValidation = (fieldReference)=>!!fieldReference && !!fieldReference.validate && !!(isFunction(fieldReference.validate) && fieldReference.validate.constructor.name === ASYNC_FUNCTION || isObject(fieldReference.validate) && Object.values(fieldReference.validate).find((validateFunction)=>validateFunction.constructor.name === ASYNC_FUNCTION));\nvar hasValidation = (options)=>options.mount && (options.required || options.min || options.max || options.maxLength || options.minLength || options.pattern || options.validate);\nvar isWatched = (name, _names, isBlurEvent)=>!isBlurEvent && (_names.watchAll || _names.watch.has(name) || [\n        ..._names.watch\n    ].some((watchName)=>name.startsWith(watchName) && /^\\.\\w+/.test(name.slice(watchName.length))));\nconst iterateFieldsByAction = (fields, action, fieldsNames, abortEarly)=>{\n    for (const key of fieldsNames || Object.keys(fields)){\n        const field = get(fields, key);\n        if (field) {\n            const { _f, ...currentField } = field;\n            if (_f) {\n                if (_f.refs && _f.refs[0] && action(_f.refs[0], key) && !abortEarly) {\n                    return true;\n                } else if (_f.ref && action(_f.ref, _f.name) && !abortEarly) {\n                    return true;\n                } else {\n                    if (iterateFieldsByAction(currentField, action)) {\n                        break;\n                    }\n                }\n            } else if (isObject(currentField)) {\n                if (iterateFieldsByAction(currentField, action)) {\n                    break;\n                }\n            }\n        }\n    }\n    return;\n};\nfunction schemaErrorLookup(errors, _fields, name) {\n    const error = get(errors, name);\n    if (error || isKey(name)) {\n        return {\n            error,\n            name\n        };\n    }\n    const names = name.split(\".\");\n    while(names.length){\n        const fieldName = names.join(\".\");\n        const field = get(_fields, fieldName);\n        const foundError = get(errors, fieldName);\n        if (field && !Array.isArray(field) && name !== fieldName) {\n            return {\n                name\n            };\n        }\n        if (foundError && foundError.type) {\n            return {\n                name: fieldName,\n                error: foundError\n            };\n        }\n        if (foundError && foundError.root && foundError.root.type) {\n            return {\n                name: `${fieldName}.root`,\n                error: foundError.root\n            };\n        }\n        names.pop();\n    }\n    return {\n        name\n    };\n}\nvar shouldRenderFormState = (formStateData, _proxyFormState, updateFormState, isRoot)=>{\n    updateFormState(formStateData);\n    const { name, ...formState } = formStateData;\n    return isEmptyObject(formState) || Object.keys(formState).length >= Object.keys(_proxyFormState).length || Object.keys(formState).find((key)=>_proxyFormState[key] === (!isRoot || VALIDATION_MODE.all));\n};\nvar shouldSubscribeByName = (name, signalName, exact)=>!name || !signalName || name === signalName || convertToArrayPayload(name).some((currentName)=>currentName && (exact ? currentName === signalName : currentName.startsWith(signalName) || signalName.startsWith(currentName)));\nvar skipValidation = (isBlurEvent, isTouched, isSubmitted, reValidateMode, mode)=>{\n    if (mode.isOnAll) {\n        return false;\n    } else if (!isSubmitted && mode.isOnTouch) {\n        return !(isTouched || isBlurEvent);\n    } else if (isSubmitted ? reValidateMode.isOnBlur : mode.isOnBlur) {\n        return !isBlurEvent;\n    } else if (isSubmitted ? reValidateMode.isOnChange : mode.isOnChange) {\n        return isBlurEvent;\n    }\n    return true;\n};\nvar unsetEmptyArray = (ref, name)=>!compact(get(ref, name)).length && unset(ref, name);\nvar updateFieldArrayRootError = (errors, error, name)=>{\n    const fieldArrayErrors = convertToArrayPayload(get(errors, name));\n    set(fieldArrayErrors, \"root\", error[name]);\n    set(errors, name, fieldArrayErrors);\n    return errors;\n};\nfunction getValidateError(result, ref, type = \"validate\") {\n    if (isString(result) || Array.isArray(result) && result.every(isString) || isBoolean(result) && !result) {\n        return {\n            type,\n            message: isString(result) ? result : \"\",\n            ref\n        };\n    }\n}\nvar getValueAndMessage = (validationData)=>isObject(validationData) && !isRegex(validationData) ? validationData : {\n        value: validationData,\n        message: \"\"\n    };\nvar validateField = async (field, disabledFieldNames, formValues, validateAllFieldCriteria, shouldUseNativeValidation, isFieldArray)=>{\n    const { ref, refs, required, maxLength, minLength, min, max, pattern, validate, name, valueAsNumber, mount } = field._f;\n    const inputValue = get(formValues, name);\n    if (!mount || disabledFieldNames.has(name)) {\n        return {};\n    }\n    const inputRef = refs ? refs[0] : ref;\n    const setCustomValidity = (message)=>{\n        if (shouldUseNativeValidation && inputRef.reportValidity) {\n            inputRef.setCustomValidity(isBoolean(message) ? \"\" : message || \"\");\n            inputRef.reportValidity();\n        }\n    };\n    const error = {};\n    const isRadio = isRadioInput(ref);\n    const isCheckBox = isCheckBoxInput(ref);\n    const isRadioOrCheckbox = isRadio || isCheckBox;\n    const isEmpty = (valueAsNumber || isFileInput(ref)) && isUndefined(ref.value) && isUndefined(inputValue) || isHTMLElement(ref) && ref.value === \"\" || inputValue === \"\" || Array.isArray(inputValue) && !inputValue.length;\n    const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);\n    const getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength)=>{\n        const message = exceedMax ? maxLengthMessage : minLengthMessage;\n        error[name] = {\n            type: exceedMax ? maxType : minType,\n            message,\n            ref,\n            ...appendErrorsCurry(exceedMax ? maxType : minType, message)\n        };\n    };\n    if (isFieldArray ? !Array.isArray(inputValue) || !inputValue.length : required && (!isRadioOrCheckbox && (isEmpty || isNullOrUndefined(inputValue)) || isBoolean(inputValue) && !inputValue || isCheckBox && !getCheckboxValue(refs).isValid || isRadio && !getRadioValue(refs).isValid)) {\n        const { value: value1, message } = isString(required) ? {\n            value: !!required,\n            message: required\n        } : getValueAndMessage(required);\n        if (value1) {\n            error[name] = {\n                type: INPUT_VALIDATION_RULES.required,\n                message,\n                ref: inputRef,\n                ...appendErrorsCurry(INPUT_VALIDATION_RULES.required, message)\n            };\n            if (!validateAllFieldCriteria) {\n                setCustomValidity(message);\n                return error;\n            }\n        }\n    }\n    if (!isEmpty && (!isNullOrUndefined(min) || !isNullOrUndefined(max))) {\n        let exceedMax;\n        let exceedMin;\n        const maxOutput = getValueAndMessage(max);\n        const minOutput = getValueAndMessage(min);\n        if (!isNullOrUndefined(inputValue) && !isNaN(inputValue)) {\n            const valueNumber = ref.valueAsNumber || (inputValue ? +inputValue : inputValue);\n            if (!isNullOrUndefined(maxOutput.value)) {\n                exceedMax = valueNumber > maxOutput.value;\n            }\n            if (!isNullOrUndefined(minOutput.value)) {\n                exceedMin = valueNumber < minOutput.value;\n            }\n        } else {\n            const valueDate = ref.valueAsDate || new Date(inputValue);\n            const convertTimeToDate = (time)=>new Date(new Date().toDateString() + \" \" + time);\n            const isTime = ref.type == \"time\";\n            const isWeek = ref.type == \"week\";\n            if (isString(maxOutput.value) && inputValue) {\n                exceedMax = isTime ? convertTimeToDate(inputValue) > convertTimeToDate(maxOutput.value) : isWeek ? inputValue > maxOutput.value : valueDate > new Date(maxOutput.value);\n            }\n            if (isString(minOutput.value) && inputValue) {\n                exceedMin = isTime ? convertTimeToDate(inputValue) < convertTimeToDate(minOutput.value) : isWeek ? inputValue < minOutput.value : valueDate < new Date(minOutput.value);\n            }\n        }\n        if (exceedMax || exceedMin) {\n            getMinMaxMessage(!!exceedMax, maxOutput.message, minOutput.message, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);\n            if (!validateAllFieldCriteria) {\n                setCustomValidity(error[name].message);\n                return error;\n            }\n        }\n    }\n    if ((maxLength || minLength) && !isEmpty && (isString(inputValue) || isFieldArray && Array.isArray(inputValue))) {\n        const maxLengthOutput = getValueAndMessage(maxLength);\n        const minLengthOutput = getValueAndMessage(minLength);\n        const exceedMax = !isNullOrUndefined(maxLengthOutput.value) && inputValue.length > +maxLengthOutput.value;\n        const exceedMin = !isNullOrUndefined(minLengthOutput.value) && inputValue.length < +minLengthOutput.value;\n        if (exceedMax || exceedMin) {\n            getMinMaxMessage(exceedMax, maxLengthOutput.message, minLengthOutput.message);\n            if (!validateAllFieldCriteria) {\n                setCustomValidity(error[name].message);\n                return error;\n            }\n        }\n    }\n    if (pattern && !isEmpty && isString(inputValue)) {\n        const { value: patternValue, message } = getValueAndMessage(pattern);\n        if (isRegex(patternValue) && !inputValue.match(patternValue)) {\n            error[name] = {\n                type: INPUT_VALIDATION_RULES.pattern,\n                message,\n                ref,\n                ...appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, message)\n            };\n            if (!validateAllFieldCriteria) {\n                setCustomValidity(message);\n                return error;\n            }\n        }\n    }\n    if (validate) {\n        if (isFunction(validate)) {\n            const result = await validate(inputValue, formValues);\n            const validateError = getValidateError(result, inputRef);\n            if (validateError) {\n                error[name] = {\n                    ...validateError,\n                    ...appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message)\n                };\n                if (!validateAllFieldCriteria) {\n                    setCustomValidity(validateError.message);\n                    return error;\n                }\n            }\n        } else if (isObject(validate)) {\n            let validationResult = {};\n            for(const key in validate){\n                if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {\n                    break;\n                }\n                const validateError = getValidateError(await validate[key](inputValue, formValues), inputRef, key);\n                if (validateError) {\n                    validationResult = {\n                        ...validateError,\n                        ...appendErrorsCurry(key, validateError.message)\n                    };\n                    setCustomValidity(validateError.message);\n                    if (validateAllFieldCriteria) {\n                        error[name] = validationResult;\n                    }\n                }\n            }\n            if (!isEmptyObject(validationResult)) {\n                error[name] = {\n                    ref: inputRef,\n                    ...validationResult\n                };\n                if (!validateAllFieldCriteria) {\n                    return error;\n                }\n            }\n        }\n    }\n    setCustomValidity(true);\n    return error;\n};\nconst defaultOptions = {\n    mode: VALIDATION_MODE.onSubmit,\n    reValidateMode: VALIDATION_MODE.onChange,\n    shouldFocusError: true\n};\nfunction createFormControl(props = {}) {\n    let _options = {\n        ...defaultOptions,\n        ...props\n    };\n    let _formState = {\n        submitCount: 0,\n        isDirty: false,\n        isReady: false,\n        isLoading: isFunction(_options.defaultValues),\n        isValidating: false,\n        isSubmitted: false,\n        isSubmitting: false,\n        isSubmitSuccessful: false,\n        isValid: false,\n        touchedFields: {},\n        dirtyFields: {},\n        validatingFields: {},\n        errors: _options.errors || {},\n        disabled: _options.disabled || false\n    };\n    let _fields = {};\n    let _defaultValues = isObject(_options.defaultValues) || isObject(_options.values) ? cloneObject(_options.defaultValues || _options.values) || {} : {};\n    let _formValues = _options.shouldUnregister ? {} : cloneObject(_defaultValues);\n    let _state = {\n        action: false,\n        mount: false,\n        watch: false\n    };\n    let _names = {\n        mount: new Set(),\n        disabled: new Set(),\n        unMount: new Set(),\n        array: new Set(),\n        watch: new Set()\n    };\n    let delayErrorCallback;\n    let timer = 0;\n    const _proxyFormState = {\n        isDirty: false,\n        dirtyFields: false,\n        validatingFields: false,\n        touchedFields: false,\n        isValidating: false,\n        isValid: false,\n        errors: false\n    };\n    let _proxySubscribeFormState = {\n        ..._proxyFormState\n    };\n    const _subjects = {\n        array: createSubject(),\n        state: createSubject()\n    };\n    const shouldDisplayAllAssociatedErrors = _options.criteriaMode === VALIDATION_MODE.all;\n    const debounce = (callback)=>(wait)=>{\n            clearTimeout(timer);\n            timer = setTimeout(callback, wait);\n        };\n    const _setValid = async (shouldUpdateValid)=>{\n        if (!_options.disabled && (_proxyFormState.isValid || _proxySubscribeFormState.isValid || shouldUpdateValid)) {\n            const isValid = _options.resolver ? isEmptyObject((await _runSchema()).errors) : await executeBuiltInValidation(_fields, true);\n            if (isValid !== _formState.isValid) {\n                _subjects.state.next({\n                    isValid\n                });\n            }\n        }\n    };\n    const _updateIsValidating = (names, isValidating)=>{\n        if (!_options.disabled && (_proxyFormState.isValidating || _proxyFormState.validatingFields || _proxySubscribeFormState.isValidating || _proxySubscribeFormState.validatingFields)) {\n            (names || Array.from(_names.mount)).forEach((name)=>{\n                if (name) {\n                    isValidating ? set(_formState.validatingFields, name, isValidating) : unset(_formState.validatingFields, name);\n                }\n            });\n            _subjects.state.next({\n                validatingFields: _formState.validatingFields,\n                isValidating: !isEmptyObject(_formState.validatingFields)\n            });\n        }\n    };\n    const _setFieldArray = (name, values = [], method, args, shouldSetValues = true, shouldUpdateFieldsAndState = true)=>{\n        if (args && method && !_options.disabled) {\n            _state.action = true;\n            if (shouldUpdateFieldsAndState && Array.isArray(get(_fields, name))) {\n                const fieldValues = method(get(_fields, name), args.argA, args.argB);\n                shouldSetValues && set(_fields, name, fieldValues);\n            }\n            if (shouldUpdateFieldsAndState && Array.isArray(get(_formState.errors, name))) {\n                const errors = method(get(_formState.errors, name), args.argA, args.argB);\n                shouldSetValues && set(_formState.errors, name, errors);\n                unsetEmptyArray(_formState.errors, name);\n            }\n            if ((_proxyFormState.touchedFields || _proxySubscribeFormState.touchedFields) && shouldUpdateFieldsAndState && Array.isArray(get(_formState.touchedFields, name))) {\n                const touchedFields = method(get(_formState.touchedFields, name), args.argA, args.argB);\n                shouldSetValues && set(_formState.touchedFields, name, touchedFields);\n            }\n            if (_proxyFormState.dirtyFields || _proxySubscribeFormState.dirtyFields) {\n                _formState.dirtyFields = getDirtyFields(_defaultValues, _formValues);\n            }\n            _subjects.state.next({\n                name,\n                isDirty: _getDirty(name, values),\n                dirtyFields: _formState.dirtyFields,\n                errors: _formState.errors,\n                isValid: _formState.isValid\n            });\n        } else {\n            set(_formValues, name, values);\n        }\n    };\n    const updateErrors = (name, error)=>{\n        set(_formState.errors, name, error);\n        _subjects.state.next({\n            errors: _formState.errors\n        });\n    };\n    const _setErrors = (errors)=>{\n        _formState.errors = errors;\n        _subjects.state.next({\n            errors: _formState.errors,\n            isValid: false\n        });\n    };\n    const updateValidAndValue = (name, shouldSkipSetValueAs, value1, ref)=>{\n        const field = get(_fields, name);\n        if (field) {\n            const defaultValue = get(_formValues, name, isUndefined(value1) ? get(_defaultValues, name) : value1);\n            isUndefined(defaultValue) || ref && ref.defaultChecked || shouldSkipSetValueAs ? set(_formValues, name, shouldSkipSetValueAs ? defaultValue : getFieldValue(field._f)) : setFieldValue(name, defaultValue);\n            _state.mount && !_state.action && _setValid();\n        }\n    };\n    const updateTouchAndDirty = (name, fieldValue, isBlurEvent, shouldDirty, shouldRender)=>{\n        let shouldUpdateField = false;\n        let isPreviousDirty = false;\n        const output = {\n            name\n        };\n        if (!_options.disabled) {\n            if (!isBlurEvent || shouldDirty) {\n                if (_proxyFormState.isDirty || _proxySubscribeFormState.isDirty) {\n                    isPreviousDirty = _formState.isDirty;\n                    _formState.isDirty = output.isDirty = _getDirty();\n                    shouldUpdateField = isPreviousDirty !== output.isDirty;\n                }\n                const isCurrentFieldPristine = deepEqual(get(_defaultValues, name), fieldValue);\n                isPreviousDirty = !!get(_formState.dirtyFields, name);\n                isCurrentFieldPristine ? unset(_formState.dirtyFields, name) : set(_formState.dirtyFields, name, true);\n                output.dirtyFields = _formState.dirtyFields;\n                shouldUpdateField = shouldUpdateField || (_proxyFormState.dirtyFields || _proxySubscribeFormState.dirtyFields) && isPreviousDirty !== !isCurrentFieldPristine;\n            }\n            if (isBlurEvent) {\n                const isPreviousFieldTouched = get(_formState.touchedFields, name);\n                if (!isPreviousFieldTouched) {\n                    set(_formState.touchedFields, name, isBlurEvent);\n                    output.touchedFields = _formState.touchedFields;\n                    shouldUpdateField = shouldUpdateField || (_proxyFormState.touchedFields || _proxySubscribeFormState.touchedFields) && isPreviousFieldTouched !== isBlurEvent;\n                }\n            }\n            shouldUpdateField && shouldRender && _subjects.state.next(output);\n        }\n        return shouldUpdateField ? output : {};\n    };\n    const shouldRenderByError = (name, isValid, error, fieldState)=>{\n        const previousFieldError = get(_formState.errors, name);\n        const shouldUpdateValid = (_proxyFormState.isValid || _proxySubscribeFormState.isValid) && isBoolean(isValid) && _formState.isValid !== isValid;\n        if (_options.delayError && error) {\n            delayErrorCallback = debounce(()=>updateErrors(name, error));\n            delayErrorCallback(_options.delayError);\n        } else {\n            clearTimeout(timer);\n            delayErrorCallback = null;\n            error ? set(_formState.errors, name, error) : unset(_formState.errors, name);\n        }\n        if ((error ? !deepEqual(previousFieldError, error) : previousFieldError) || !isEmptyObject(fieldState) || shouldUpdateValid) {\n            const updatedFormState = {\n                ...fieldState,\n                ...shouldUpdateValid && isBoolean(isValid) ? {\n                    isValid\n                } : {},\n                errors: _formState.errors,\n                name\n            };\n            _formState = {\n                ..._formState,\n                ...updatedFormState\n            };\n            _subjects.state.next(updatedFormState);\n        }\n    };\n    const _runSchema = async (name)=>{\n        _updateIsValidating(name, true);\n        const result = await _options.resolver(_formValues, _options.context, getResolverOptions(name || _names.mount, _fields, _options.criteriaMode, _options.shouldUseNativeValidation));\n        _updateIsValidating(name);\n        return result;\n    };\n    const executeSchemaAndUpdateState = async (names)=>{\n        const { errors } = await _runSchema(names);\n        if (names) {\n            for (const name of names){\n                const error = get(errors, name);\n                error ? set(_formState.errors, name, error) : unset(_formState.errors, name);\n            }\n        } else {\n            _formState.errors = errors;\n        }\n        return errors;\n    };\n    const executeBuiltInValidation = async (fields, shouldOnlyCheckValid, context = {\n        valid: true\n    })=>{\n        for(const name in fields){\n            const field = fields[name];\n            if (field) {\n                const { _f, ...fieldValue } = field;\n                if (_f) {\n                    const isFieldArrayRoot = _names.array.has(_f.name);\n                    const isPromiseFunction = field._f && hasPromiseValidation(field._f);\n                    if (isPromiseFunction && _proxyFormState.validatingFields) {\n                        _updateIsValidating([\n                            _f.name\n                        ], true);\n                    }\n                    const fieldError = await validateField(field, _names.disabled, _formValues, shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation && !shouldOnlyCheckValid, isFieldArrayRoot);\n                    if (isPromiseFunction && _proxyFormState.validatingFields) {\n                        _updateIsValidating([\n                            _f.name\n                        ]);\n                    }\n                    if (fieldError[_f.name]) {\n                        context.valid = false;\n                        if (shouldOnlyCheckValid) {\n                            break;\n                        }\n                    }\n                    !shouldOnlyCheckValid && (get(fieldError, _f.name) ? isFieldArrayRoot ? updateFieldArrayRootError(_formState.errors, fieldError, _f.name) : set(_formState.errors, _f.name, fieldError[_f.name]) : unset(_formState.errors, _f.name));\n                }\n                !isEmptyObject(fieldValue) && await executeBuiltInValidation(fieldValue, shouldOnlyCheckValid, context);\n            }\n        }\n        return context.valid;\n    };\n    const _removeUnmounted = ()=>{\n        for (const name of _names.unMount){\n            const field = get(_fields, name);\n            field && (field._f.refs ? field._f.refs.every((ref)=>!live(ref)) : !live(field._f.ref)) && unregister(name);\n        }\n        _names.unMount = new Set();\n    };\n    const _getDirty = (name, data)=>!_options.disabled && (name && data && set(_formValues, name, data), !deepEqual(getValues(), _defaultValues));\n    const _getWatch = (names, defaultValue, isGlobal)=>generateWatchOutput(names, _names, {\n            ..._state.mount ? _formValues : isUndefined(defaultValue) ? _defaultValues : isString(names) ? {\n                [names]: defaultValue\n            } : defaultValue\n        }, isGlobal, defaultValue);\n    const _getFieldArray = (name)=>compact(get(_state.mount ? _formValues : _defaultValues, name, _options.shouldUnregister ? get(_defaultValues, name, []) : []));\n    const setFieldValue = (name, value1, options = {})=>{\n        const field = get(_fields, name);\n        let fieldValue = value1;\n        if (field) {\n            const fieldReference = field._f;\n            if (fieldReference) {\n                !fieldReference.disabled && set(_formValues, name, getFieldValueAs(value1, fieldReference));\n                fieldValue = isHTMLElement(fieldReference.ref) && isNullOrUndefined(value1) ? \"\" : value1;\n                if (isMultipleSelect(fieldReference.ref)) {\n                    [\n                        ...fieldReference.ref.options\n                    ].forEach((optionRef)=>optionRef.selected = fieldValue.includes(optionRef.value));\n                } else if (fieldReference.refs) {\n                    if (isCheckBoxInput(fieldReference.ref)) {\n                        fieldReference.refs.forEach((checkboxRef)=>{\n                            if (!checkboxRef.defaultChecked || !checkboxRef.disabled) {\n                                if (Array.isArray(fieldValue)) {\n                                    checkboxRef.checked = !!fieldValue.find((data)=>data === checkboxRef.value);\n                                } else {\n                                    checkboxRef.checked = fieldValue === checkboxRef.value || !!fieldValue;\n                                }\n                            }\n                        });\n                    } else {\n                        fieldReference.refs.forEach((radioRef)=>radioRef.checked = radioRef.value === fieldValue);\n                    }\n                } else if (isFileInput(fieldReference.ref)) {\n                    fieldReference.ref.value = \"\";\n                } else {\n                    fieldReference.ref.value = fieldValue;\n                    if (!fieldReference.ref.type) {\n                        _subjects.state.next({\n                            name,\n                            values: cloneObject(_formValues)\n                        });\n                    }\n                }\n            }\n        }\n        (options.shouldDirty || options.shouldTouch) && updateTouchAndDirty(name, fieldValue, options.shouldTouch, options.shouldDirty, true);\n        options.shouldValidate && trigger(name);\n    };\n    const setValues = (name, value1, options)=>{\n        for(const fieldKey in value1){\n            if (!value1.hasOwnProperty(fieldKey)) {\n                return;\n            }\n            const fieldValue = value1[fieldKey];\n            const fieldName = name + \".\" + fieldKey;\n            const field = get(_fields, fieldName);\n            (_names.array.has(name) || isObject(fieldValue) || field && !field._f) && !isDateObject(fieldValue) ? setValues(fieldName, fieldValue, options) : setFieldValue(fieldName, fieldValue, options);\n        }\n    };\n    const setValue = (name, value1, options = {})=>{\n        const field = get(_fields, name);\n        const isFieldArray = _names.array.has(name);\n        const cloneValue = cloneObject(value1);\n        set(_formValues, name, cloneValue);\n        if (isFieldArray) {\n            _subjects.array.next({\n                name,\n                values: cloneObject(_formValues)\n            });\n            if ((_proxyFormState.isDirty || _proxyFormState.dirtyFields || _proxySubscribeFormState.isDirty || _proxySubscribeFormState.dirtyFields) && options.shouldDirty) {\n                _subjects.state.next({\n                    name,\n                    dirtyFields: getDirtyFields(_defaultValues, _formValues),\n                    isDirty: _getDirty(name, cloneValue)\n                });\n            }\n        } else {\n            field && !field._f && !isNullOrUndefined(cloneValue) ? setValues(name, cloneValue, options) : setFieldValue(name, cloneValue, options);\n        }\n        isWatched(name, _names) && _subjects.state.next({\n            ..._formState,\n            name\n        });\n        _subjects.state.next({\n            name: _state.mount ? name : undefined,\n            values: cloneObject(_formValues)\n        });\n    };\n    const onChange = async (event)=>{\n        _state.mount = true;\n        const target = event.target;\n        let name = target.name;\n        let isFieldValueUpdated = true;\n        const field = get(_fields, name);\n        const _updateIsFieldValueUpdated = (fieldValue)=>{\n            isFieldValueUpdated = Number.isNaN(fieldValue) || isDateObject(fieldValue) && isNaN(fieldValue.getTime()) || deepEqual(fieldValue, get(_formValues, name, fieldValue));\n        };\n        const validationModeBeforeSubmit = getValidationModes(_options.mode);\n        const validationModeAfterSubmit = getValidationModes(_options.reValidateMode);\n        if (field) {\n            let error;\n            let isValid;\n            const fieldValue = target.type ? getFieldValue(field._f) : getEventValue(event);\n            const isBlurEvent = event.type === EVENTS.BLUR || event.type === EVENTS.FOCUS_OUT;\n            const shouldSkipValidation = !hasValidation(field._f) && !_options.resolver && !get(_formState.errors, name) && !field._f.deps || skipValidation(isBlurEvent, get(_formState.touchedFields, name), _formState.isSubmitted, validationModeAfterSubmit, validationModeBeforeSubmit);\n            const watched = isWatched(name, _names, isBlurEvent);\n            set(_formValues, name, fieldValue);\n            if (isBlurEvent) {\n                if (!target || !target.readOnly) {\n                    field._f.onBlur && field._f.onBlur(event);\n                    delayErrorCallback && delayErrorCallback(0);\n                }\n            } else if (field._f.onChange) {\n                field._f.onChange(event);\n            }\n            const fieldState = updateTouchAndDirty(name, fieldValue, isBlurEvent);\n            const shouldRender = !isEmptyObject(fieldState) || watched;\n            !isBlurEvent && _subjects.state.next({\n                name,\n                type: event.type,\n                values: cloneObject(_formValues)\n            });\n            if (shouldSkipValidation) {\n                if (_proxyFormState.isValid || _proxySubscribeFormState.isValid) {\n                    if (_options.mode === \"onBlur\") {\n                        if (isBlurEvent) {\n                            _setValid();\n                        }\n                    } else if (!isBlurEvent) {\n                        _setValid();\n                    }\n                }\n                return shouldRender && _subjects.state.next({\n                    name,\n                    ...watched ? {} : fieldState\n                });\n            }\n            !isBlurEvent && watched && _subjects.state.next({\n                ..._formState\n            });\n            if (_options.resolver) {\n                const { errors } = await _runSchema([\n                    name\n                ]);\n                _updateIsFieldValueUpdated(fieldValue);\n                if (isFieldValueUpdated) {\n                    const previousErrorLookupResult = schemaErrorLookup(_formState.errors, _fields, name);\n                    const errorLookupResult = schemaErrorLookup(errors, _fields, previousErrorLookupResult.name || name);\n                    error = errorLookupResult.error;\n                    name = errorLookupResult.name;\n                    isValid = isEmptyObject(errors);\n                }\n            } else {\n                _updateIsValidating([\n                    name\n                ], true);\n                error = (await validateField(field, _names.disabled, _formValues, shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation))[name];\n                _updateIsValidating([\n                    name\n                ]);\n                _updateIsFieldValueUpdated(fieldValue);\n                if (isFieldValueUpdated) {\n                    if (error) {\n                        isValid = false;\n                    } else if (_proxyFormState.isValid || _proxySubscribeFormState.isValid) {\n                        isValid = await executeBuiltInValidation(_fields, true);\n                    }\n                }\n            }\n            if (isFieldValueUpdated) {\n                field._f.deps && (!Array.isArray(field._f.deps) || field._f.deps.length > 0) && trigger(field._f.deps);\n                shouldRenderByError(name, isValid, error, fieldState);\n            }\n        }\n    };\n    const _focusInput = (ref, key)=>{\n        if (get(_formState.errors, key) && ref.focus) {\n            ref.focus();\n            return 1;\n        }\n        return;\n    };\n    const trigger = async (name, options = {})=>{\n        let isValid;\n        let validationResult;\n        const fieldNames = convertToArrayPayload(name);\n        if (_options.resolver) {\n            const errors = await executeSchemaAndUpdateState(isUndefined(name) ? name : fieldNames);\n            isValid = isEmptyObject(errors);\n            validationResult = name ? !fieldNames.some((name)=>get(errors, name)) : isValid;\n        } else if (name) {\n            validationResult = (await Promise.all(fieldNames.map(async (fieldName)=>{\n                const field = get(_fields, fieldName);\n                return await executeBuiltInValidation(field && field._f ? {\n                    [fieldName]: field\n                } : field);\n            }))).every(Boolean);\n            !(!validationResult && !_formState.isValid) && _setValid();\n        } else {\n            validationResult = isValid = await executeBuiltInValidation(_fields);\n        }\n        _subjects.state.next({\n            ...!isString(name) || (_proxyFormState.isValid || _proxySubscribeFormState.isValid) && isValid !== _formState.isValid ? {} : {\n                name\n            },\n            ..._options.resolver || !name ? {\n                isValid\n            } : {},\n            errors: _formState.errors\n        });\n        options.shouldFocus && !validationResult && iterateFieldsByAction(_fields, _focusInput, name ? fieldNames : _names.mount);\n        return validationResult;\n    };\n    const getValues = (fieldNames, config)=>{\n        let values = {\n            ..._state.mount ? _formValues : _defaultValues\n        };\n        if (config) {\n            values = extractFormValues(config.dirtyFields ? _formState.dirtyFields : _formState.touchedFields, values);\n        }\n        return isUndefined(fieldNames) ? values : isString(fieldNames) ? get(values, fieldNames) : fieldNames.map((name)=>get(values, name));\n    };\n    const getFieldState = (name, formState)=>({\n            invalid: !!get((formState || _formState).errors, name),\n            isDirty: !!get((formState || _formState).dirtyFields, name),\n            error: get((formState || _formState).errors, name),\n            isValidating: !!get(_formState.validatingFields, name),\n            isTouched: !!get((formState || _formState).touchedFields, name)\n        });\n    const clearErrors = (name)=>{\n        name && convertToArrayPayload(name).forEach((inputName)=>unset(_formState.errors, inputName));\n        _subjects.state.next({\n            errors: name ? _formState.errors : {}\n        });\n    };\n    const setError = (name, error, options)=>{\n        const ref = (get(_fields, name, {\n            _f: {}\n        })._f || {}).ref;\n        const currentError = get(_formState.errors, name) || {};\n        // Don't override existing error messages elsewhere in the object tree.\n        const { ref: currentRef, message, type, ...restOfErrorTree } = currentError;\n        set(_formState.errors, name, {\n            ...restOfErrorTree,\n            ...error,\n            ref\n        });\n        _subjects.state.next({\n            name,\n            errors: _formState.errors,\n            isValid: false\n        });\n        options && options.shouldFocus && ref && ref.focus && ref.focus();\n    };\n    const watch = (name, defaultValue)=>isFunction(name) ? _subjects.state.subscribe({\n            next: (payload)=>\"values\" in payload && name(_getWatch(undefined, defaultValue), payload)\n        }) : _getWatch(name, defaultValue, true);\n    const _subscribe = (props)=>_subjects.state.subscribe({\n            next: (formState)=>{\n                if (shouldSubscribeByName(props.name, formState.name, props.exact) && shouldRenderFormState(formState, props.formState || _proxyFormState, _setFormState, props.reRenderRoot)) {\n                    props.callback({\n                        values: {\n                            ..._formValues\n                        },\n                        ..._formState,\n                        ...formState,\n                        defaultValues: _defaultValues\n                    });\n                }\n            }\n        }).unsubscribe;\n    const subscribe = (props)=>{\n        _state.mount = true;\n        _proxySubscribeFormState = {\n            ..._proxySubscribeFormState,\n            ...props.formState\n        };\n        return _subscribe({\n            ...props,\n            formState: _proxySubscribeFormState\n        });\n    };\n    const unregister = (name, options = {})=>{\n        for (const fieldName of name ? convertToArrayPayload(name) : _names.mount){\n            _names.mount.delete(fieldName);\n            _names.array.delete(fieldName);\n            if (!options.keepValue) {\n                unset(_fields, fieldName);\n                unset(_formValues, fieldName);\n            }\n            !options.keepError && unset(_formState.errors, fieldName);\n            !options.keepDirty && unset(_formState.dirtyFields, fieldName);\n            !options.keepTouched && unset(_formState.touchedFields, fieldName);\n            !options.keepIsValidating && unset(_formState.validatingFields, fieldName);\n            !_options.shouldUnregister && !options.keepDefaultValue && unset(_defaultValues, fieldName);\n        }\n        _subjects.state.next({\n            values: cloneObject(_formValues)\n        });\n        _subjects.state.next({\n            ..._formState,\n            ...!options.keepDirty ? {} : {\n                isDirty: _getDirty()\n            }\n        });\n        !options.keepIsValid && _setValid();\n    };\n    const _setDisabledField = ({ disabled, name })=>{\n        if (isBoolean(disabled) && _state.mount || !!disabled || _names.disabled.has(name)) {\n            disabled ? _names.disabled.add(name) : _names.disabled.delete(name);\n        }\n    };\n    const register = (name, options = {})=>{\n        let field = get(_fields, name);\n        const disabledIsDefined = isBoolean(options.disabled) || isBoolean(_options.disabled);\n        set(_fields, name, {\n            ...field || {},\n            _f: {\n                ...field && field._f ? field._f : {\n                    ref: {\n                        name\n                    }\n                },\n                name,\n                mount: true,\n                ...options\n            }\n        });\n        _names.mount.add(name);\n        if (field) {\n            _setDisabledField({\n                disabled: isBoolean(options.disabled) ? options.disabled : _options.disabled,\n                name\n            });\n        } else {\n            updateValidAndValue(name, true, options.value);\n        }\n        return {\n            ...disabledIsDefined ? {\n                disabled: options.disabled || _options.disabled\n            } : {},\n            ..._options.progressive ? {\n                required: !!options.required,\n                min: getRuleValue(options.min),\n                max: getRuleValue(options.max),\n                minLength: getRuleValue(options.minLength),\n                maxLength: getRuleValue(options.maxLength),\n                pattern: getRuleValue(options.pattern)\n            } : {},\n            name,\n            onChange,\n            onBlur: onChange,\n            ref: (ref)=>{\n                if (ref) {\n                    register(name, options);\n                    field = get(_fields, name);\n                    const fieldRef = isUndefined(ref.value) ? ref.querySelectorAll ? ref.querySelectorAll(\"input,select,textarea\")[0] || ref : ref : ref;\n                    const radioOrCheckbox = isRadioOrCheckbox(fieldRef);\n                    const refs = field._f.refs || [];\n                    if (radioOrCheckbox ? refs.find((option)=>option === fieldRef) : fieldRef === field._f.ref) {\n                        return;\n                    }\n                    set(_fields, name, {\n                        _f: {\n                            ...field._f,\n                            ...radioOrCheckbox ? {\n                                refs: [\n                                    ...refs.filter(live),\n                                    fieldRef,\n                                    ...Array.isArray(get(_defaultValues, name)) ? [\n                                        {}\n                                    ] : []\n                                ],\n                                ref: {\n                                    type: fieldRef.type,\n                                    name\n                                }\n                            } : {\n                                ref: fieldRef\n                            }\n                        }\n                    });\n                    updateValidAndValue(name, false, undefined, fieldRef);\n                } else {\n                    field = get(_fields, name, {});\n                    if (field._f) {\n                        field._f.mount = false;\n                    }\n                    (_options.shouldUnregister || options.shouldUnregister) && !(isNameInFieldArray(_names.array, name) && _state.action) && _names.unMount.add(name);\n                }\n            }\n        };\n    };\n    const _focusError = ()=>_options.shouldFocusError && iterateFieldsByAction(_fields, _focusInput, _names.mount);\n    const _disableForm = (disabled)=>{\n        if (isBoolean(disabled)) {\n            _subjects.state.next({\n                disabled\n            });\n            iterateFieldsByAction(_fields, (ref, name)=>{\n                const currentField = get(_fields, name);\n                if (currentField) {\n                    ref.disabled = currentField._f.disabled || disabled;\n                    if (Array.isArray(currentField._f.refs)) {\n                        currentField._f.refs.forEach((inputRef)=>{\n                            inputRef.disabled = currentField._f.disabled || disabled;\n                        });\n                    }\n                }\n            }, 0, false);\n        }\n    };\n    const handleSubmit = (onValid, onInvalid)=>async (e)=>{\n            let onValidError = undefined;\n            if (e) {\n                e.preventDefault && e.preventDefault();\n                e.persist && e.persist();\n            }\n            let fieldValues = cloneObject(_formValues);\n            _subjects.state.next({\n                isSubmitting: true\n            });\n            if (_options.resolver) {\n                const { errors, values } = await _runSchema();\n                _formState.errors = errors;\n                fieldValues = cloneObject(values);\n            } else {\n                await executeBuiltInValidation(_fields);\n            }\n            if (_names.disabled.size) {\n                for (const name of _names.disabled){\n                    unset(fieldValues, name);\n                }\n            }\n            unset(_formState.errors, \"root\");\n            if (isEmptyObject(_formState.errors)) {\n                _subjects.state.next({\n                    errors: {}\n                });\n                try {\n                    await onValid(fieldValues, e);\n                } catch (error) {\n                    onValidError = error;\n                }\n            } else {\n                if (onInvalid) {\n                    await onInvalid({\n                        ..._formState.errors\n                    }, e);\n                }\n                _focusError();\n                setTimeout(_focusError);\n            }\n            _subjects.state.next({\n                isSubmitted: true,\n                isSubmitting: false,\n                isSubmitSuccessful: isEmptyObject(_formState.errors) && !onValidError,\n                submitCount: _formState.submitCount + 1,\n                errors: _formState.errors\n            });\n            if (onValidError) {\n                throw onValidError;\n            }\n        };\n    const resetField = (name, options = {})=>{\n        if (get(_fields, name)) {\n            if (isUndefined(options.defaultValue)) {\n                setValue(name, cloneObject(get(_defaultValues, name)));\n            } else {\n                setValue(name, options.defaultValue);\n                set(_defaultValues, name, cloneObject(options.defaultValue));\n            }\n            if (!options.keepTouched) {\n                unset(_formState.touchedFields, name);\n            }\n            if (!options.keepDirty) {\n                unset(_formState.dirtyFields, name);\n                _formState.isDirty = options.defaultValue ? _getDirty(name, cloneObject(get(_defaultValues, name))) : _getDirty();\n            }\n            if (!options.keepError) {\n                unset(_formState.errors, name);\n                _proxyFormState.isValid && _setValid();\n            }\n            _subjects.state.next({\n                ..._formState\n            });\n        }\n    };\n    const _reset = (formValues, keepStateOptions = {})=>{\n        const updatedValues = formValues ? cloneObject(formValues) : _defaultValues;\n        const cloneUpdatedValues = cloneObject(updatedValues);\n        const isEmptyResetValues = isEmptyObject(formValues);\n        const values = isEmptyResetValues ? _defaultValues : cloneUpdatedValues;\n        if (!keepStateOptions.keepDefaultValues) {\n            _defaultValues = updatedValues;\n        }\n        if (!keepStateOptions.keepValues) {\n            if (keepStateOptions.keepDirtyValues) {\n                const fieldsToCheck = new Set([\n                    ..._names.mount,\n                    ...Object.keys(getDirtyFields(_defaultValues, _formValues))\n                ]);\n                for (const fieldName of Array.from(fieldsToCheck)){\n                    get(_formState.dirtyFields, fieldName) ? set(values, fieldName, get(_formValues, fieldName)) : setValue(fieldName, get(values, fieldName));\n                }\n            } else {\n                if (isWeb && isUndefined(formValues)) {\n                    for (const name of _names.mount){\n                        const field = get(_fields, name);\n                        if (field && field._f) {\n                            const fieldReference = Array.isArray(field._f.refs) ? field._f.refs[0] : field._f.ref;\n                            if (isHTMLElement(fieldReference)) {\n                                const form = fieldReference.closest(\"form\");\n                                if (form) {\n                                    form.reset();\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                }\n                if (keepStateOptions.keepFieldsRef) {\n                    for (const fieldName of _names.mount){\n                        setValue(fieldName, get(values, fieldName));\n                    }\n                } else {\n                    _fields = {};\n                }\n            }\n            _formValues = _options.shouldUnregister ? keepStateOptions.keepDefaultValues ? cloneObject(_defaultValues) : {} : cloneObject(values);\n            _subjects.array.next({\n                values: {\n                    ...values\n                }\n            });\n            _subjects.state.next({\n                values: {\n                    ...values\n                }\n            });\n        }\n        _names = {\n            mount: keepStateOptions.keepDirtyValues ? _names.mount : new Set(),\n            unMount: new Set(),\n            array: new Set(),\n            disabled: new Set(),\n            watch: new Set(),\n            watchAll: false,\n            focus: \"\"\n        };\n        _state.mount = !_proxyFormState.isValid || !!keepStateOptions.keepIsValid || !!keepStateOptions.keepDirtyValues || !_options.shouldUnregister && !isEmptyObject(values);\n        _state.watch = !!_options.shouldUnregister;\n        _subjects.state.next({\n            submitCount: keepStateOptions.keepSubmitCount ? _formState.submitCount : 0,\n            isDirty: isEmptyResetValues ? false : keepStateOptions.keepDirty ? _formState.isDirty : !!(keepStateOptions.keepDefaultValues && !deepEqual(formValues, _defaultValues)),\n            isSubmitted: keepStateOptions.keepIsSubmitted ? _formState.isSubmitted : false,\n            dirtyFields: isEmptyResetValues ? {} : keepStateOptions.keepDirtyValues ? keepStateOptions.keepDefaultValues && _formValues ? getDirtyFields(_defaultValues, _formValues) : _formState.dirtyFields : keepStateOptions.keepDefaultValues && formValues ? getDirtyFields(_defaultValues, formValues) : keepStateOptions.keepDirty ? _formState.dirtyFields : {},\n            touchedFields: keepStateOptions.keepTouched ? _formState.touchedFields : {},\n            errors: keepStateOptions.keepErrors ? _formState.errors : {},\n            isSubmitSuccessful: keepStateOptions.keepIsSubmitSuccessful ? _formState.isSubmitSuccessful : false,\n            isSubmitting: false,\n            defaultValues: _defaultValues\n        });\n    };\n    const reset = (formValues, keepStateOptions)=>_reset(isFunction(formValues) ? formValues(_formValues) : formValues, keepStateOptions);\n    const setFocus = (name, options = {})=>{\n        const field = get(_fields, name);\n        const fieldReference = field && field._f;\n        if (fieldReference) {\n            const fieldRef = fieldReference.refs ? fieldReference.refs[0] : fieldReference.ref;\n            if (fieldRef.focus) {\n                fieldRef.focus();\n                options.shouldSelect && isFunction(fieldRef.select) && fieldRef.select();\n            }\n        }\n    };\n    const _setFormState = (updatedFormState)=>{\n        _formState = {\n            ..._formState,\n            ...updatedFormState\n        };\n    };\n    const _resetDefaultValues = ()=>isFunction(_options.defaultValues) && _options.defaultValues().then((values)=>{\n            reset(values, _options.resetOptions);\n            _subjects.state.next({\n                isLoading: false\n            });\n        });\n    const methods = {\n        control: {\n            register,\n            unregister,\n            getFieldState,\n            handleSubmit,\n            setError,\n            _subscribe,\n            _runSchema,\n            _focusError,\n            _getWatch,\n            _getDirty,\n            _setValid,\n            _setFieldArray,\n            _setDisabledField,\n            _setErrors,\n            _getFieldArray,\n            _reset,\n            _resetDefaultValues,\n            _removeUnmounted,\n            _disableForm,\n            _subjects,\n            _proxyFormState,\n            get _fields () {\n                return _fields;\n            },\n            get _formValues () {\n                return _formValues;\n            },\n            get _state () {\n                return _state;\n            },\n            set _state (value){\n                _state = value;\n            },\n            get _defaultValues () {\n                return _defaultValues;\n            },\n            get _names () {\n                return _names;\n            },\n            set _names (value){\n                _names = value;\n            },\n            get _formState () {\n                return _formState;\n            },\n            get _options () {\n                return _options;\n            },\n            set _options (value){\n                _options = {\n                    ..._options,\n                    ...value\n                };\n            }\n        },\n        subscribe,\n        trigger,\n        register,\n        handleSubmit,\n        watch,\n        setValue,\n        getValues,\n        reset,\n        resetField,\n        clearErrors,\n        unregister,\n        setError,\n        setFocus,\n        getFieldState\n    };\n    return {\n        ...methods,\n        formControl: methods\n    };\n}\nvar generateId = ()=>{\n    if (typeof crypto !== \"undefined\" && crypto.randomUUID) {\n        return crypto.randomUUID();\n    }\n    const d = typeof performance === \"undefined\" ? Date.now() : performance.now() * 1000;\n    return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (c)=>{\n        const r = (Math.random() * 16 + d) % 16 | 0;\n        return (c == \"x\" ? r : r & 0x3 | 0x8).toString(16);\n    });\n};\nvar getFocusFieldName = (name, index, options = {})=>options.shouldFocus || isUndefined(options.shouldFocus) ? options.focusName || `${name}.${isUndefined(options.focusIndex) ? index : options.focusIndex}.` : \"\";\nvar appendAt = (data, value1)=>[\n        ...data,\n        ...convertToArrayPayload(value1)\n    ];\nvar fillEmptyArray = (value1)=>Array.isArray(value1) ? value1.map(()=>undefined) : undefined;\nfunction insert(data, index, value1) {\n    return [\n        ...data.slice(0, index),\n        ...convertToArrayPayload(value1),\n        ...data.slice(index)\n    ];\n}\nvar moveArrayAt = (data, from, to)=>{\n    if (!Array.isArray(data)) {\n        return [];\n    }\n    if (isUndefined(data[to])) {\n        data[to] = undefined;\n    }\n    data.splice(to, 0, data.splice(from, 1)[0]);\n    return data;\n};\nvar prependAt = (data, value1)=>[\n        ...convertToArrayPayload(value1),\n        ...convertToArrayPayload(data)\n    ];\nfunction removeAtIndexes(data, indexes) {\n    let i = 0;\n    const temp = [\n        ...data\n    ];\n    for (const index of indexes){\n        temp.splice(index - i, 1);\n        i++;\n    }\n    return compact(temp).length ? temp : [];\n}\nvar removeArrayAt = (data, index)=>isUndefined(index) ? [] : removeAtIndexes(data, convertToArrayPayload(index).sort((a, b)=>a - b));\nvar swapArrayAt = (data, indexA, indexB)=>{\n    [data[indexA], data[indexB]] = [\n        data[indexB],\n        data[indexA]\n    ];\n};\nvar updateAt = (fieldValues, index, value1)=>{\n    fieldValues[index] = value1;\n    return fieldValues;\n};\n/**\n * A custom hook that exposes convenient methods to perform operations with a list of dynamic inputs that need to be appended, updated, removed etc. • [Demo](https://codesandbox.io/s/react-hook-form-usefieldarray-ssugn) • [Video](https://youtu.be/4MrbfGSFY2A)\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/usefieldarray) • [Demo](https://codesandbox.io/s/react-hook-form-usefieldarray-ssugn)\n *\n * @param props - useFieldArray props\n *\n * @returns methods - functions to manipulate with the Field Arrays (dynamic inputs) {@link UseFieldArrayReturn}\n *\n * @example\n * ```tsx\n * function App() {\n *   const { register, control, handleSubmit, reset, trigger, setError } = useForm({\n *     defaultValues: {\n *       test: []\n *     }\n *   });\n *   const { fields, append } = useFieldArray({\n *     control,\n *     name: \"test\"\n *   });\n *\n *   return (\n *     <form onSubmit={handleSubmit(data => console.log(data))}>\n *       {fields.map((item, index) => (\n *          <input key={item.id} {...register(`test.${index}.firstName`)}  />\n *       ))}\n *       <button type=\"button\" onClick={() => append({ firstName: \"bill\" })}>\n *         append\n *       </button>\n *       <input type=\"submit\" />\n *     </form>\n *   );\n * }\n * ```\n */ function useFieldArray(props) {\n    const methods = useFormContext();\n    const { control = methods.control, name, keyName = \"id\", shouldUnregister, rules } = props;\n    const [fields, setFields] = react__WEBPACK_IMPORTED_MODULE_0__.useState(control._getFieldArray(name));\n    const ids = react__WEBPACK_IMPORTED_MODULE_0__.useRef(control._getFieldArray(name).map(generateId));\n    const _actioned = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    control._names.array.add(name);\n    react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>rules && fields.length >= 0 && control.register(name, rules), [\n        control,\n        name,\n        fields.length,\n        rules\n    ]);\n    useIsomorphicLayoutEffect(()=>control._subjects.array.subscribe({\n            next: ({ values, name: fieldArrayName })=>{\n                if (fieldArrayName === name || !fieldArrayName) {\n                    const fieldValues = get(values, name);\n                    if (Array.isArray(fieldValues)) {\n                        setFields(fieldValues);\n                        ids.current = fieldValues.map(generateId);\n                    }\n                }\n            }\n        }).unsubscribe, [\n        control,\n        name\n    ]);\n    const updateValues = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((updatedFieldArrayValues)=>{\n        _actioned.current = true;\n        control._setFieldArray(name, updatedFieldArrayValues);\n    }, [\n        control,\n        name\n    ]);\n    const append = (value1, options)=>{\n        const appendValue = convertToArrayPayload(cloneObject(value1));\n        const updatedFieldArrayValues = appendAt(control._getFieldArray(name), appendValue);\n        control._names.focus = getFocusFieldName(name, updatedFieldArrayValues.length - 1, options);\n        ids.current = appendAt(ids.current, appendValue.map(generateId));\n        updateValues(updatedFieldArrayValues);\n        setFields(updatedFieldArrayValues);\n        control._setFieldArray(name, updatedFieldArrayValues, appendAt, {\n            argA: fillEmptyArray(value1)\n        });\n    };\n    const prepend = (value1, options)=>{\n        const prependValue = convertToArrayPayload(cloneObject(value1));\n        const updatedFieldArrayValues = prependAt(control._getFieldArray(name), prependValue);\n        control._names.focus = getFocusFieldName(name, 0, options);\n        ids.current = prependAt(ids.current, prependValue.map(generateId));\n        updateValues(updatedFieldArrayValues);\n        setFields(updatedFieldArrayValues);\n        control._setFieldArray(name, updatedFieldArrayValues, prependAt, {\n            argA: fillEmptyArray(value1)\n        });\n    };\n    const remove = (index)=>{\n        const updatedFieldArrayValues = removeArrayAt(control._getFieldArray(name), index);\n        ids.current = removeArrayAt(ids.current, index);\n        updateValues(updatedFieldArrayValues);\n        setFields(updatedFieldArrayValues);\n        !Array.isArray(get(control._fields, name)) && set(control._fields, name, undefined);\n        control._setFieldArray(name, updatedFieldArrayValues, removeArrayAt, {\n            argA: index\n        });\n    };\n    const insert$1 = (index, value1, options)=>{\n        const insertValue = convertToArrayPayload(cloneObject(value1));\n        const updatedFieldArrayValues = insert(control._getFieldArray(name), index, insertValue);\n        control._names.focus = getFocusFieldName(name, index, options);\n        ids.current = insert(ids.current, index, insertValue.map(generateId));\n        updateValues(updatedFieldArrayValues);\n        setFields(updatedFieldArrayValues);\n        control._setFieldArray(name, updatedFieldArrayValues, insert, {\n            argA: index,\n            argB: fillEmptyArray(value1)\n        });\n    };\n    const swap = (indexA, indexB)=>{\n        const updatedFieldArrayValues = control._getFieldArray(name);\n        swapArrayAt(updatedFieldArrayValues, indexA, indexB);\n        swapArrayAt(ids.current, indexA, indexB);\n        updateValues(updatedFieldArrayValues);\n        setFields(updatedFieldArrayValues);\n        control._setFieldArray(name, updatedFieldArrayValues, swapArrayAt, {\n            argA: indexA,\n            argB: indexB\n        }, false);\n    };\n    const move = (from, to)=>{\n        const updatedFieldArrayValues = control._getFieldArray(name);\n        moveArrayAt(updatedFieldArrayValues, from, to);\n        moveArrayAt(ids.current, from, to);\n        updateValues(updatedFieldArrayValues);\n        setFields(updatedFieldArrayValues);\n        control._setFieldArray(name, updatedFieldArrayValues, moveArrayAt, {\n            argA: from,\n            argB: to\n        }, false);\n    };\n    const update = (index, value1)=>{\n        const updateValue = cloneObject(value1);\n        const updatedFieldArrayValues = updateAt(control._getFieldArray(name), index, updateValue);\n        ids.current = [\n            ...updatedFieldArrayValues\n        ].map((item, i)=>!item || i === index ? generateId() : ids.current[i]);\n        updateValues(updatedFieldArrayValues);\n        setFields([\n            ...updatedFieldArrayValues\n        ]);\n        control._setFieldArray(name, updatedFieldArrayValues, updateAt, {\n            argA: index,\n            argB: updateValue\n        }, true, false);\n    };\n    const replace = (value1)=>{\n        const updatedFieldArrayValues = convertToArrayPayload(cloneObject(value1));\n        ids.current = updatedFieldArrayValues.map(generateId);\n        updateValues([\n            ...updatedFieldArrayValues\n        ]);\n        setFields([\n            ...updatedFieldArrayValues\n        ]);\n        control._setFieldArray(name, [\n            ...updatedFieldArrayValues\n        ], (data)=>data, {}, true, false);\n    };\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        control._state.action = false;\n        isWatched(name, control._names) && control._subjects.state.next({\n            ...control._formState\n        });\n        if (_actioned.current && (!getValidationModes(control._options.mode).isOnSubmit || control._formState.isSubmitted) && !getValidationModes(control._options.reValidateMode).isOnSubmit) {\n            if (control._options.resolver) {\n                control._runSchema([\n                    name\n                ]).then((result)=>{\n                    const error = get(result.errors, name);\n                    const existingError = get(control._formState.errors, name);\n                    if (existingError ? !error && existingError.type || error && (existingError.type !== error.type || existingError.message !== error.message) : error && error.type) {\n                        error ? set(control._formState.errors, name, error) : unset(control._formState.errors, name);\n                        control._subjects.state.next({\n                            errors: control._formState.errors\n                        });\n                    }\n                });\n            } else {\n                const field = get(control._fields, name);\n                if (field && field._f && !(getValidationModes(control._options.reValidateMode).isOnSubmit && getValidationModes(control._options.mode).isOnSubmit)) {\n                    validateField(field, control._names.disabled, control._formValues, control._options.criteriaMode === VALIDATION_MODE.all, control._options.shouldUseNativeValidation, true).then((error)=>!isEmptyObject(error) && control._subjects.state.next({\n                            errors: updateFieldArrayRootError(control._formState.errors, error, name)\n                        }));\n                }\n            }\n        }\n        control._subjects.state.next({\n            name,\n            values: cloneObject(control._formValues)\n        });\n        control._names.focus && iterateFieldsByAction(control._fields, (ref, key)=>{\n            if (control._names.focus && key.startsWith(control._names.focus) && ref.focus) {\n                ref.focus();\n                return 1;\n            }\n            return;\n        });\n        control._names.focus = \"\";\n        control._setValid();\n        _actioned.current = false;\n    }, [\n        fields,\n        name,\n        control\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        !get(control._formValues, name) && control._setFieldArray(name);\n        return ()=>{\n            const updateMounted = (name, value1)=>{\n                const field = get(control._fields, name);\n                if (field && field._f) {\n                    field._f.mount = value1;\n                }\n            };\n            control._options.shouldUnregister || shouldUnregister ? control.unregister(name) : updateMounted(name, false);\n        };\n    }, [\n        name,\n        control,\n        keyName,\n        shouldUnregister\n    ]);\n    return {\n        swap: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(swap, [\n            updateValues,\n            name,\n            control\n        ]),\n        move: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(move, [\n            updateValues,\n            name,\n            control\n        ]),\n        prepend: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(prepend, [\n            updateValues,\n            name,\n            control\n        ]),\n        append: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(append, [\n            updateValues,\n            name,\n            control\n        ]),\n        remove: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(remove, [\n            updateValues,\n            name,\n            control\n        ]),\n        insert: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(insert$1, [\n            updateValues,\n            name,\n            control\n        ]),\n        update: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(update, [\n            updateValues,\n            name,\n            control\n        ]),\n        replace: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(replace, [\n            updateValues,\n            name,\n            control\n        ]),\n        fields: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>fields.map((field, index)=>({\n                    ...field,\n                    [keyName]: ids.current[index] || generateId()\n                })), [\n            fields,\n            keyName\n        ])\n    };\n}\n/**\n * Custom hook to manage the entire form.\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/useform) • [Demo](https://codesandbox.io/s/react-hook-form-get-started-ts-5ksmm) • [Video](https://www.youtube.com/watch?v=RkXv4AXXC_4)\n *\n * @param props - form configuration and validation parameters.\n *\n * @returns methods - individual functions to manage the form state. {@link UseFormReturn}\n *\n * @example\n * ```tsx\n * function App() {\n *   const { register, handleSubmit, watch, formState: { errors } } = useForm();\n *   const onSubmit = data => console.log(data);\n *\n *   console.log(watch(\"example\"));\n *\n *   return (\n *     <form onSubmit={handleSubmit(onSubmit)}>\n *       <input defaultValue=\"test\" {...register(\"example\")} />\n *       <input {...register(\"exampleRequired\", { required: true })} />\n *       {errors.exampleRequired && <span>This field is required</span>}\n *       <button>Submit</button>\n *     </form>\n *   );\n * }\n * ```\n */ function useForm(props = {}) {\n    const _formControl = react__WEBPACK_IMPORTED_MODULE_0__.useRef(undefined);\n    const _values = react__WEBPACK_IMPORTED_MODULE_0__.useRef(undefined);\n    const [formState, updateFormState] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n        isDirty: false,\n        isValidating: false,\n        isLoading: isFunction(props.defaultValues),\n        isSubmitted: false,\n        isSubmitting: false,\n        isSubmitSuccessful: false,\n        isValid: false,\n        submitCount: 0,\n        dirtyFields: {},\n        touchedFields: {},\n        validatingFields: {},\n        errors: props.errors || {},\n        disabled: props.disabled || false,\n        isReady: false,\n        defaultValues: isFunction(props.defaultValues) ? undefined : props.defaultValues\n    });\n    if (!_formControl.current) {\n        if (props.formControl) {\n            _formControl.current = {\n                ...props.formControl,\n                formState\n            };\n            if (props.defaultValues && !isFunction(props.defaultValues)) {\n                props.formControl.reset(props.defaultValues, props.resetOptions);\n            }\n        } else {\n            const { formControl, ...rest } = createFormControl(props);\n            _formControl.current = {\n                ...rest,\n                formState\n            };\n        }\n    }\n    const control = _formControl.current.control;\n    control._options = props;\n    useIsomorphicLayoutEffect(()=>{\n        const sub = control._subscribe({\n            formState: control._proxyFormState,\n            callback: ()=>updateFormState({\n                    ...control._formState\n                }),\n            reRenderRoot: true\n        });\n        updateFormState((data)=>({\n                ...data,\n                isReady: true\n            }));\n        control._formState.isReady = true;\n        return sub;\n    }, [\n        control\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>control._disableForm(props.disabled), [\n        control,\n        props.disabled\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (props.mode) {\n            control._options.mode = props.mode;\n        }\n        if (props.reValidateMode) {\n            control._options.reValidateMode = props.reValidateMode;\n        }\n    }, [\n        control,\n        props.mode,\n        props.reValidateMode\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (props.errors) {\n            control._setErrors(props.errors);\n            control._focusError();\n        }\n    }, [\n        control,\n        props.errors\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        props.shouldUnregister && control._subjects.state.next({\n            values: control._getWatch()\n        });\n    }, [\n        control,\n        props.shouldUnregister\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (control._proxyFormState.isDirty) {\n            const isDirty = control._getDirty();\n            if (isDirty !== formState.isDirty) {\n                control._subjects.state.next({\n                    isDirty\n                });\n            }\n        }\n    }, [\n        control,\n        formState.isDirty\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        var _a;\n        if (props.values && !deepEqual(props.values, _values.current)) {\n            control._reset(props.values, {\n                keepFieldsRef: true,\n                ...control._options.resetOptions\n            });\n            if (!((_a = control._options.resetOptions) === null || _a === void 0 ? void 0 : _a.keepIsValid)) {\n                control._setValid();\n            }\n            _values.current = props.values;\n            updateFormState((state)=>({\n                    ...state\n                }));\n        } else {\n            control._resetDefaultValues();\n        }\n    }, [\n        control,\n        props.values\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!control._state.mount) {\n            control._setValid();\n            control._state.mount = true;\n        }\n        if (control._state.watch) {\n            control._state.watch = false;\n            control._subjects.state.next({\n                ...control._formState\n            });\n        }\n        control._removeUnmounted();\n    });\n    _formControl.current.formState = getProxyFormState(formState, control);\n    return _formControl.current;\n}\n/**\n * Watch component that subscribes to form field changes and re-renders when watched fields update.\n *\n * @param control - The form control object from useForm\n * @param names - Array of field names to watch for changes\n * @param render - The function that receives watched values and returns ReactNode\n * @returns The result of calling render function with watched values\n *\n * @example\n * The `Watch` component only re-render when the values of `foo`, `bar`, and `baz.qux` change.\n * The types of `foo`, `bar`, and `baz.qux` are precisely inferred.\n *\n * ```tsx\n * const { control } = useForm();\n *\n * <Watch\n *   control={control}\n *   names={['foo', 'bar', 'baz.qux']}\n *   render={([foo, bar, baz_qux]) => <div>{foo}{bar}{baz_qux}</div>}\n * />\n * ```\n */ const Watch = ({ control, names, render })=>render(useWatch({\n        control,\n        name: names\n    }));\n //# sourceMappingURL=index.esm.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtaG9vay1mb3JtL2Rpc3QvaW5kZXguZXNtLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMEI7QUFFMUIsSUFBSUMsa0JBQWtCLENBQUNDLFVBQVlBLFFBQVFDLElBQUksS0FBSztBQUVwRCxJQUFJQyxlQUFlLENBQUNDLFNBQVVBLGtCQUFpQkM7QUFFL0MsSUFBSUMsb0JBQW9CLENBQUNGLFNBQVVBLFVBQVM7QUFFNUMsTUFBTUcsZUFBZSxDQUFDSCxTQUFVLE9BQU9BLFdBQVU7QUFDakQsSUFBSUksV0FBVyxDQUFDSixTQUFVLENBQUNFLGtCQUFrQkYsV0FDekMsQ0FBQ0ssTUFBTUMsT0FBTyxDQUFDTixXQUNmRyxhQUFhSCxXQUNiLENBQUNELGFBQWFDO0FBRWxCLElBQUlPLGdCQUFnQixDQUFDQyxRQUFVSixTQUFTSSxVQUFVQSxNQUFNQyxNQUFNLEdBQ3hEYixnQkFBZ0JZLE1BQU1DLE1BQU0sSUFDeEJELE1BQU1DLE1BQU0sQ0FBQ0MsT0FBTyxHQUNwQkYsTUFBTUMsTUFBTSxDQUFDVCxLQUFLLEdBQ3RCUTtBQUVOLElBQUlHLG9CQUFvQixDQUFDQyxPQUFTQSxLQUFLQyxTQUFTLENBQUMsR0FBR0QsS0FBS0UsTUFBTSxDQUFDLG1CQUFtQkY7QUFFbkYsSUFBSUcscUJBQXFCLENBQUNDLE9BQU9KLE9BQVNJLE1BQU1DLEdBQUcsQ0FBQ04sa0JBQWtCQztBQUV0RSxJQUFJTSxnQkFBZ0IsQ0FBQ0M7SUFDakIsTUFBTUMsZ0JBQWdCRCxXQUFXRSxXQUFXLElBQUlGLFdBQVdFLFdBQVcsQ0FBQ0MsU0FBUztJQUNoRixPQUFRbEIsU0FBU2dCLGtCQUFrQkEsY0FBY0csY0FBYyxDQUFDO0FBQ3BFO0FBRUEsSUFBSUMsUUFBUSxNQUNzQixJQUM5QixDQUFvQjtBQUV4QixTQUFTSSxZQUFZQyxJQUFJO0lBQ3JCLElBQUlDO0lBQ0osTUFBTXhCLFVBQVVELE1BQU1DLE9BQU8sQ0FBQ3VCO0lBQzlC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O1lBQ3JCO1lBQ0EyYyxRQUFRN2MsT0FBTyxHQUFHbkMsTUFBTTBFLE1BQU07WUFDOUJyRCxnQkFBZ0IsQ0FBQ3VJLFFBQVc7b0JBQUUsR0FBR0EsS0FBSztnQkFBQztRQUMzQyxPQUNLO1lBQ0R0SixRQUFRZ2IsbUJBQW1CO1FBQy9CO0lBQ0osR0FBRztRQUFDaGI7UUFBU04sTUFBTTBFLE1BQU07S0FBQztJQUMxQnhLLDRDQUFlLENBQUM7UUFDWixJQUFJLENBQUNvRyxRQUFROEcsTUFBTSxDQUFDRCxLQUFLLEVBQUU7WUFDdkI3RyxRQUFRK0IsU0FBUztZQUNqQi9CLFFBQVE4RyxNQUFNLENBQUNELEtBQUssR0FBRztRQUMzQjtRQUNBLElBQUk3RyxRQUFROEcsTUFBTSxDQUFDeEUsS0FBSyxFQUFFO1lBQ3RCdEMsUUFBUThHLE1BQU0sQ0FBQ3hFLEtBQUssR0FBRztZQUN2QnRDLFFBQVFxSixTQUFTLENBQUNDLEtBQUssQ0FBQ0MsSUFBSSxDQUFDO2dCQUFFLEdBQUd2SixRQUFRaUIsVUFBVTtZQUFDO1FBQ3pEO1FBQ0FqQixRQUFRd0UsZ0JBQWdCO0lBQzVCO0lBQ0FpYSxhQUFhNWMsT0FBTyxDQUFDOUIsU0FBUyxHQUFHRCxrQkFBa0JDLFdBQVdDO0lBQzlELE9BQU95ZSxhQUFhNWMsT0FBTztBQUMvQjtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FxQkMsR0FDRCxNQUFNK2MsUUFBUSxDQUFDLEVBQUU1ZSxPQUFPLEVBQUUvRSxLQUFLLEVBQUVpTSxNQUFNLEVBQUcsR0FBS0EsT0FBT3pELFNBQVM7UUFBRXpEO1FBQVNuRixNQUFNSTtJQUFNO0FBRXFGLENBQzNLLHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL3NoaXBwZXItY2hhdC1tdnAtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvcmVhY3QtaG9vay1mb3JtL2Rpc3QvaW5kZXguZXNtLm1qcz85ZGMzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbnZhciBpc0NoZWNrQm94SW5wdXQgPSAoZWxlbWVudCkgPT4gZWxlbWVudC50eXBlID09PSAnY2hlY2tib3gnO1xuXG52YXIgaXNEYXRlT2JqZWN0ID0gKHZhbHVlKSA9PiB2YWx1ZSBpbnN0YW5jZW9mIERhdGU7XG5cbnZhciBpc051bGxPclVuZGVmaW5lZCA9ICh2YWx1ZSkgPT4gdmFsdWUgPT0gbnVsbDtcblxuY29uc3QgaXNPYmplY3RUeXBlID0gKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnO1xudmFyIGlzT2JqZWN0ID0gKHZhbHVlKSA9PiAhaXNOdWxsT3JVbmRlZmluZWQodmFsdWUpICYmXG4gICAgIUFycmF5LmlzQXJyYXkodmFsdWUpICYmXG4gICAgaXNPYmplY3RUeXBlKHZhbHVlKSAmJlxuICAgICFpc0RhdGVPYmplY3QodmFsdWUpO1xuXG52YXIgZ2V0RXZlbnRWYWx1ZSA9IChldmVudCkgPT4gaXNPYmplY3QoZXZlbnQpICYmIGV2ZW50LnRhcmdldFxuICAgID8gaXNDaGVja0JveElucHV0KGV2ZW50LnRhcmdldClcbiAgICAgICAgPyBldmVudC50YXJnZXQuY2hlY2tlZFxuICAgICAgICA6IGV2ZW50LnRhcmdldC52YWx1ZVxuICAgIDogZXZlbnQ7XG5cbnZhciBnZXROb2RlUGFyZW50TmFtZSA9IChuYW1lKSA9PiBuYW1lLnN1YnN0cmluZygwLCBuYW1lLnNlYXJjaCgvXFwuXFxkKyhcXC58JCkvKSkgfHwgbmFtZTtcblxudmFyIGlzTmFtZUluRmllbGRBcnJheSA9IChuYW1lcywgbmFtZSkgPT4gbmFtZXMuaGFzKGdldE5vZGVQYXJlbnROYW1lKG5hbWUpKTtcblxudmFyIGlzUGxhaW5PYmplY3QgPSAodGVtcE9iamVjdCkgPT4ge1xuICAgIGNvbnN0IHByb3RvdHlwZUNvcHkgPSB0ZW1wT2JqZWN0LmNvbnN0cnVjdG9yICYmIHRlbXBPYmplY3QuY29uc3RydWN0b3IucHJvdG90eXBlO1xuICAgIHJldHVybiAoaXNPYmplY3QocHJvdG90eXBlQ29weSkgJiYgcHJvdG90eXBlQ29weS5oYXNPd25Qcm9wZXJ0eSgnaXNQcm90b3R5cGVPZicpKTtcbn07XG5cbnZhciBpc1dlYiA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIHdpbmRvdy5IVE1MRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xuXG5mdW5jdGlvbiBjbG9uZU9iamVjdChkYXRhKSB7XG4gICAgbGV0IGNvcHk7XG4gICAgY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoZGF0YSk7XG4gICAgY29uc3QgaXNGaWxlTGlzdEluc3RhbmNlID0gdHlwZW9mIEZpbGVMaXN0ICE9PSAndW5kZWZpbmVkJyA/IGRhdGEgaW5zdGFuY2VvZiBGaWxlTGlzdCA6IGZhbHNlO1xuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICBjb3B5ID0gbmV3IERhdGUoZGF0YSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCEoaXNXZWIgJiYgKGRhdGEgaW5zdGFuY2VvZiBCbG9iIHx8IGlzRmlsZUxpc3RJbnN0YW5jZSkpICYmXG4gICAgICAgIChpc0FycmF5IHx8IGlzT2JqZWN0KGRhdGEpKSkge1xuICAgICAgICBjb3B5ID0gaXNBcnJheSA/IFtdIDogT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YoZGF0YSkpO1xuICAgICAgICBpZiAoIWlzQXJyYXkgJiYgIWlzUGxhaW5PYmplY3QoZGF0YSkpIHtcbiAgICAgICAgICAgIGNvcHkgPSBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZGF0YSkge1xuICAgICAgICAgICAgICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29weVtrZXldID0gY2xvbmVPYmplY3QoZGF0YVtrZXldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICByZXR1cm4gY29weTtcbn1cblxudmFyIGlzS2V5ID0gKHZhbHVlKSA9PiAvXlxcdyokLy50ZXN0KHZhbHVlKTtcblxudmFyIGlzVW5kZWZpbmVkID0gKHZhbCkgPT4gdmFsID09PSB1bmRlZmluZWQ7XG5cbnZhciBjb21wYWN0ID0gKHZhbHVlKSA9PiBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLmZpbHRlcihCb29sZWFuKSA6IFtdO1xuXG52YXIgc3RyaW5nVG9QYXRoID0gKGlucHV0KSA9PiBjb21wYWN0KGlucHV0LnJlcGxhY2UoL1tcInwnXXxcXF0vZywgJycpLnNwbGl0KC9cXC58XFxbLykpO1xuXG52YXIgZ2V0ID0gKG9iamVjdCwgcGF0aCwgZGVmYXVsdFZhbHVlKSA9PiB7XG4gICAgaWYgKCFwYXRoIHx8ICFpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IChpc0tleShwYXRoKSA/IFtwYXRoXSA6IHN0cmluZ1RvUGF0aChwYXRoKSkucmVkdWNlKChyZXN1bHQsIGtleSkgPT4gaXNOdWxsT3JVbmRlZmluZWQocmVzdWx0KSA/IHJlc3VsdCA6IHJlc3VsdFtrZXldLCBvYmplY3QpO1xuICAgIHJldHVybiBpc1VuZGVmaW5lZChyZXN1bHQpIHx8IHJlc3VsdCA9PT0gb2JqZWN0XG4gICAgICAgID8gaXNVbmRlZmluZWQob2JqZWN0W3BhdGhdKVxuICAgICAgICAgICAgPyBkZWZhdWx0VmFsdWVcbiAgICAgICAgICAgIDogb2JqZWN0W3BhdGhdXG4gICAgICAgIDogcmVzdWx0O1xufTtcblxudmFyIGlzQm9vbGVhbiA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbic7XG5cbnZhciBzZXQgPSAob2JqZWN0LCBwYXRoLCB2YWx1ZSkgPT4ge1xuICAgIGxldCBpbmRleCA9IC0xO1xuICAgIGNvbnN0IHRlbXBQYXRoID0gaXNLZXkocGF0aCkgPyBbcGF0aF0gOiBzdHJpbmdUb1BhdGgocGF0aCk7XG4gICAgY29uc3QgbGVuZ3RoID0gdGVtcFBhdGgubGVuZ3RoO1xuICAgIGNvbnN0IGxhc3RJbmRleCA9IGxlbmd0aCAtIDE7XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gdGVtcFBhdGhbaW5kZXhdO1xuICAgICAgICBsZXQgbmV3VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSBsYXN0SW5kZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IG9ialZhbHVlID0gb2JqZWN0W2tleV07XG4gICAgICAgICAgICBuZXdWYWx1ZSA9XG4gICAgICAgICAgICAgICAgaXNPYmplY3Qob2JqVmFsdWUpIHx8IEFycmF5LmlzQXJyYXkob2JqVmFsdWUpXG4gICAgICAgICAgICAgICAgICAgID8gb2JqVmFsdWVcbiAgICAgICAgICAgICAgICAgICAgOiAhaXNOYU4oK3RlbXBQYXRoW2luZGV4ICsgMV0pXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFtdXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXkgPT09ICdfX3Byb3RvX18nIHx8IGtleSA9PT0gJ2NvbnN0cnVjdG9yJyB8fCBrZXkgPT09ICdwcm90b3R5cGUnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0W2tleV0gPSBuZXdWYWx1ZTtcbiAgICAgICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gICAgfVxufTtcblxuY29uc3QgRVZFTlRTID0ge1xuICAgIEJMVVI6ICdibHVyJyxcbiAgICBGT0NVU19PVVQ6ICdmb2N1c291dCcsXG4gICAgQ0hBTkdFOiAnY2hhbmdlJyxcbn07XG5jb25zdCBWQUxJREFUSU9OX01PREUgPSB7XG4gICAgb25CbHVyOiAnb25CbHVyJyxcbiAgICBvbkNoYW5nZTogJ29uQ2hhbmdlJyxcbiAgICBvblN1Ym1pdDogJ29uU3VibWl0JyxcbiAgICBvblRvdWNoZWQ6ICdvblRvdWNoZWQnLFxuICAgIGFsbDogJ2FsbCcsXG59O1xuY29uc3QgSU5QVVRfVkFMSURBVElPTl9SVUxFUyA9IHtcbiAgICBtYXg6ICdtYXgnLFxuICAgIG1pbjogJ21pbicsXG4gICAgbWF4TGVuZ3RoOiAnbWF4TGVuZ3RoJyxcbiAgICBtaW5MZW5ndGg6ICdtaW5MZW5ndGgnLFxuICAgIHBhdHRlcm46ICdwYXR0ZXJuJyxcbiAgICByZXF1aXJlZDogJ3JlcXVpcmVkJyxcbiAgICB2YWxpZGF0ZTogJ3ZhbGlkYXRlJyxcbn07XG5cbmNvbnN0IEhvb2tGb3JtQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5Ib29rRm9ybUNvbnRleHQuZGlzcGxheU5hbWUgPSAnSG9va0Zvcm1Db250ZXh0Jztcbi8qKlxuICogVGhpcyBjdXN0b20gaG9vayBhbGxvd3MgeW91IHRvIGFjY2VzcyB0aGUgZm9ybSBjb250ZXh0LiB1c2VGb3JtQ29udGV4dCBpcyBpbnRlbmRlZCB0byBiZSB1c2VkIGluIGRlZXBseSBuZXN0ZWQgc3RydWN0dXJlcywgd2hlcmUgaXQgd291bGQgYmVjb21lIGluY29udmVuaWVudCB0byBwYXNzIHRoZSBjb250ZXh0IGFzIGEgcHJvcC4gVG8gYmUgdXNlZCB3aXRoIHtAbGluayBGb3JtUHJvdmlkZXJ9LlxuICpcbiAqIEByZW1hcmtzXG4gKiBbQVBJXShodHRwczovL3JlYWN0LWhvb2stZm9ybS5jb20vZG9jcy91c2Vmb3JtY29udGV4dCkg4oCiIFtEZW1vXShodHRwczovL2NvZGVzYW5kYm94LmlvL3MvcmVhY3QtaG9vay1mb3JtLXY3LWZvcm0tY29udGV4dC15dHVkaSlcbiAqXG4gKiBAcmV0dXJucyByZXR1cm4gYWxsIHVzZUZvcm0gbWV0aG9kc1xuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c3hcbiAqIGZ1bmN0aW9uIEFwcCgpIHtcbiAqICAgY29uc3QgbWV0aG9kcyA9IHVzZUZvcm0oKTtcbiAqICAgY29uc3Qgb25TdWJtaXQgPSBkYXRhID0+IGNvbnNvbGUubG9nKGRhdGEpO1xuICpcbiAqICAgcmV0dXJuIChcbiAqICAgICA8Rm9ybVByb3ZpZGVyIHsuLi5tZXRob2RzfSA+XG4gKiAgICAgICA8Zm9ybSBvblN1Ym1pdD17bWV0aG9kcy5oYW5kbGVTdWJtaXQob25TdWJtaXQpfT5cbiAqICAgICAgICAgPE5lc3RlZElucHV0IC8+XG4gKiAgICAgICAgIDxpbnB1dCB0eXBlPVwic3VibWl0XCIgLz5cbiAqICAgICAgIDwvZm9ybT5cbiAqICAgICA8L0Zvcm1Qcm92aWRlcj5cbiAqICAgKTtcbiAqIH1cbiAqXG4gKiAgZnVuY3Rpb24gTmVzdGVkSW5wdXQoKSB7XG4gKiAgIGNvbnN0IHsgcmVnaXN0ZXIgfSA9IHVzZUZvcm1Db250ZXh0KCk7IC8vIHJldHJpZXZlIGFsbCBob29rIG1ldGhvZHNcbiAqICAgcmV0dXJuIDxpbnB1dCB7Li4ucmVnaXN0ZXIoXCJ0ZXN0XCIpfSAvPjtcbiAqIH1cbiAqIGBgYFxuICovXG5jb25zdCB1c2VGb3JtQ29udGV4dCA9ICgpID0+IFJlYWN0LnVzZUNvbnRleHQoSG9va0Zvcm1Db250ZXh0KTtcbi8qKlxuICogQSBwcm92aWRlciBjb21wb25lbnQgdGhhdCBwcm9wYWdhdGVzIHRoZSBgdXNlRm9ybWAgbWV0aG9kcyB0byBhbGwgY2hpbGRyZW4gY29tcG9uZW50cyB2aWEgW1JlYWN0IENvbnRleHRdKGh0dHBzOi8vcmVhY3QuZGV2L3JlZmVyZW5jZS9yZWFjdC91c2VDb250ZXh0KSBBUEkuIFRvIGJlIHVzZWQgd2l0aCB7QGxpbmsgdXNlRm9ybUNvbnRleHR9LlxuICpcbiAqIEByZW1hcmtzXG4gKiBbQVBJXShodHRwczovL3JlYWN0LWhvb2stZm9ybS5jb20vZG9jcy91c2Vmb3JtY29udGV4dCkg4oCiIFtEZW1vXShodHRwczovL2NvZGVzYW5kYm94LmlvL3MvcmVhY3QtaG9vay1mb3JtLXY3LWZvcm0tY29udGV4dC15dHVkaSlcbiAqXG4gKiBAcGFyYW0gcHJvcHMgLSBhbGwgdXNlRm9ybSBtZXRob2RzXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICogZnVuY3Rpb24gQXBwKCkge1xuICogICBjb25zdCBtZXRob2RzID0gdXNlRm9ybSgpO1xuICogICBjb25zdCBvblN1Ym1pdCA9IGRhdGEgPT4gY29uc29sZS5sb2coZGF0YSk7XG4gKlxuICogICByZXR1cm4gKFxuICogICAgIDxGb3JtUHJvdmlkZXIgey4uLm1ldGhvZHN9ID5cbiAqICAgICAgIDxmb3JtIG9uU3VibWl0PXttZXRob2RzLmhhbmRsZVN1Ym1pdChvblN1Ym1pdCl9PlxuICogICAgICAgICA8TmVzdGVkSW5wdXQgLz5cbiAqICAgICAgICAgPGlucHV0IHR5cGU9XCJzdWJtaXRcIiAvPlxuICogICAgICAgPC9mb3JtPlxuICogICAgIDwvRm9ybVByb3ZpZGVyPlxuICogICApO1xuICogfVxuICpcbiAqICBmdW5jdGlvbiBOZXN0ZWRJbnB1dCgpIHtcbiAqICAgY29uc3QgeyByZWdpc3RlciB9ID0gdXNlRm9ybUNvbnRleHQoKTsgLy8gcmV0cmlldmUgYWxsIGhvb2sgbWV0aG9kc1xuICogICByZXR1cm4gPGlucHV0IHsuLi5yZWdpc3RlcihcInRlc3RcIil9IC8+O1xuICogfVxuICogYGBgXG4gKi9cbmNvbnN0IEZvcm1Qcm92aWRlciA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IHsgY2hpbGRyZW4sIC4uLmRhdGEgfSA9IHByb3BzO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChIb29rRm9ybUNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGRhdGEgfSwgY2hpbGRyZW4pKTtcbn07XG5cbnZhciBnZXRQcm94eUZvcm1TdGF0ZSA9IChmb3JtU3RhdGUsIGNvbnRyb2wsIGxvY2FsUHJveHlGb3JtU3RhdGUsIGlzUm9vdCA9IHRydWUpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIGRlZmF1bHRWYWx1ZXM6IGNvbnRyb2wuX2RlZmF1bHRWYWx1ZXMsXG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBmb3JtU3RhdGUpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc3VsdCwga2V5LCB7XG4gICAgICAgICAgICBnZXQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBfa2V5ID0ga2V5O1xuICAgICAgICAgICAgICAgIGlmIChjb250cm9sLl9wcm94eUZvcm1TdGF0ZVtfa2V5XSAhPT0gVkFMSURBVElPTl9NT0RFLmFsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sLl9wcm94eUZvcm1TdGF0ZVtfa2V5XSA9ICFpc1Jvb3QgfHwgVkFMSURBVElPTl9NT0RFLmFsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9jYWxQcm94eUZvcm1TdGF0ZSAmJiAobG9jYWxQcm94eUZvcm1TdGF0ZVtfa2V5XSA9IHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmb3JtU3RhdGVbX2tleV07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmNvbnN0IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IFJlYWN0LnVzZUxheW91dEVmZmVjdCA6IFJlYWN0LnVzZUVmZmVjdDtcblxuLyoqXG4gKiBUaGlzIGN1c3RvbSBob29rIGFsbG93cyB5b3UgdG8gc3Vic2NyaWJlIHRvIGVhY2ggZm9ybSBzdGF0ZSwgYW5kIGlzb2xhdGUgdGhlIHJlLXJlbmRlciBhdCB0aGUgY3VzdG9tIGhvb2sgbGV2ZWwuIEl0IGhhcyBpdHMgc2NvcGUgaW4gdGVybXMgb2YgZm9ybSBzdGF0ZSBzdWJzY3JpcHRpb24sIHNvIGl0IHdvdWxkIG5vdCBhZmZlY3Qgb3RoZXIgdXNlRm9ybVN0YXRlIGFuZCB1c2VGb3JtLiBVc2luZyB0aGlzIGhvb2sgY2FuIHJlZHVjZSB0aGUgcmUtcmVuZGVyIGltcGFjdCBvbiBsYXJnZSBhbmQgY29tcGxleCBmb3JtIGFwcGxpY2F0aW9uLlxuICpcbiAqIEByZW1hcmtzXG4gKiBbQVBJXShodHRwczovL3JlYWN0LWhvb2stZm9ybS5jb20vZG9jcy91c2Vmb3Jtc3RhdGUpIOKAoiBbRGVtb10oaHR0cHM6Ly9jb2Rlc2FuZGJveC5pby9zL3VzZWZvcm1zdGF0ZS03NXhseSlcbiAqXG4gKiBAcGFyYW0gcHJvcHMgLSBpbmNsdWRlIG9wdGlvbnMgb24gc3BlY2lmeSBmaWVsZHMgdG8gc3Vic2NyaWJlLiB7QGxpbmsgVXNlRm9ybVN0YXRlUmV0dXJufVxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c3hcbiAqIGZ1bmN0aW9uIEFwcCgpIHtcbiAqICAgY29uc3QgeyByZWdpc3RlciwgaGFuZGxlU3VibWl0LCBjb250cm9sIH0gPSB1c2VGb3JtKHtcbiAqICAgICBkZWZhdWx0VmFsdWVzOiB7XG4gKiAgICAgZmlyc3ROYW1lOiBcImZpcnN0TmFtZVwiXG4gKiAgIH19KTtcbiAqICAgY29uc3QgeyBkaXJ0eUZpZWxkcyB9ID0gdXNlRm9ybVN0YXRlKHtcbiAqICAgICBjb250cm9sXG4gKiAgIH0pO1xuICogICBjb25zdCBvblN1Ym1pdCA9IChkYXRhKSA9PiBjb25zb2xlLmxvZyhkYXRhKTtcbiAqXG4gKiAgIHJldHVybiAoXG4gKiAgICAgPGZvcm0gb25TdWJtaXQ9e2hhbmRsZVN1Ym1pdChvblN1Ym1pdCl9PlxuICogICAgICAgPGlucHV0IHsuLi5yZWdpc3RlcihcImZpcnN0TmFtZVwiKX0gcGxhY2Vob2xkZXI9XCJGaXJzdCBOYW1lXCIgLz5cbiAqICAgICAgIHtkaXJ0eUZpZWxkcy5maXJzdE5hbWUgJiYgPHA+RmllbGQgaXMgZGlydHkuPC9wPn1cbiAqICAgICAgIDxpbnB1dCB0eXBlPVwic3VibWl0XCIgLz5cbiAqICAgICA8L2Zvcm0+XG4gKiAgICk7XG4gKiB9XG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gdXNlRm9ybVN0YXRlKHByb3BzKSB7XG4gICAgY29uc3QgbWV0aG9kcyA9IHVzZUZvcm1Db250ZXh0KCk7XG4gICAgY29uc3QgeyBjb250cm9sID0gbWV0aG9kcy5jb250cm9sLCBkaXNhYmxlZCwgbmFtZSwgZXhhY3QgfSA9IHByb3BzIHx8IHt9O1xuICAgIGNvbnN0IFtmb3JtU3RhdGUsIHVwZGF0ZUZvcm1TdGF0ZV0gPSBSZWFjdC51c2VTdGF0ZShjb250cm9sLl9mb3JtU3RhdGUpO1xuICAgIGNvbnN0IF9sb2NhbFByb3h5Rm9ybVN0YXRlID0gUmVhY3QudXNlUmVmKHtcbiAgICAgICAgaXNEaXJ0eTogZmFsc2UsXG4gICAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICAgIGRpcnR5RmllbGRzOiBmYWxzZSxcbiAgICAgICAgdG91Y2hlZEZpZWxkczogZmFsc2UsXG4gICAgICAgIHZhbGlkYXRpbmdGaWVsZHM6IGZhbHNlLFxuICAgICAgICBpc1ZhbGlkYXRpbmc6IGZhbHNlLFxuICAgICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgICAgZXJyb3JzOiBmYWxzZSxcbiAgICB9KTtcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IGNvbnRyb2wuX3N1YnNjcmliZSh7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIGZvcm1TdGF0ZTogX2xvY2FsUHJveHlGb3JtU3RhdGUuY3VycmVudCxcbiAgICAgICAgZXhhY3QsXG4gICAgICAgIGNhbGxiYWNrOiAoZm9ybVN0YXRlKSA9PiB7XG4gICAgICAgICAgICAhZGlzYWJsZWQgJiZcbiAgICAgICAgICAgICAgICB1cGRhdGVGb3JtU3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICAuLi5jb250cm9sLl9mb3JtU3RhdGUsXG4gICAgICAgICAgICAgICAgICAgIC4uLmZvcm1TdGF0ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICB9KSwgW25hbWUsIGRpc2FibGVkLCBleGFjdF0pO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIF9sb2NhbFByb3h5Rm9ybVN0YXRlLmN1cnJlbnQuaXNWYWxpZCAmJiBjb250cm9sLl9zZXRWYWxpZCh0cnVlKTtcbiAgICB9LCBbY29udHJvbF0pO1xuICAgIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IGdldFByb3h5Rm9ybVN0YXRlKGZvcm1TdGF0ZSwgY29udHJvbCwgX2xvY2FsUHJveHlGb3JtU3RhdGUuY3VycmVudCwgZmFsc2UpLCBbZm9ybVN0YXRlLCBjb250cm9sXSk7XG59XG5cbnZhciBpc1N0cmluZyA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcblxudmFyIGdlbmVyYXRlV2F0Y2hPdXRwdXQgPSAobmFtZXMsIF9uYW1lcywgZm9ybVZhbHVlcywgaXNHbG9iYWwsIGRlZmF1bHRWYWx1ZSkgPT4ge1xuICAgIGlmIChpc1N0cmluZyhuYW1lcykpIHtcbiAgICAgICAgaXNHbG9iYWwgJiYgX25hbWVzLndhdGNoLmFkZChuYW1lcyk7XG4gICAgICAgIHJldHVybiBnZXQoZm9ybVZhbHVlcywgbmFtZXMsIGRlZmF1bHRWYWx1ZSk7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KG5hbWVzKSkge1xuICAgICAgICByZXR1cm4gbmFtZXMubWFwKChmaWVsZE5hbWUpID0+IChpc0dsb2JhbCAmJiBfbmFtZXMud2F0Y2guYWRkKGZpZWxkTmFtZSksXG4gICAgICAgICAgICBnZXQoZm9ybVZhbHVlcywgZmllbGROYW1lKSkpO1xuICAgIH1cbiAgICBpc0dsb2JhbCAmJiAoX25hbWVzLndhdGNoQWxsID0gdHJ1ZSk7XG4gICAgcmV0dXJuIGZvcm1WYWx1ZXM7XG59O1xuXG52YXIgaXNQcmltaXRpdmUgPSAodmFsdWUpID0+IGlzTnVsbE9yVW5kZWZpbmVkKHZhbHVlKSB8fCAhaXNPYmplY3RUeXBlKHZhbHVlKTtcblxuZnVuY3Rpb24gZGVlcEVxdWFsKG9iamVjdDEsIG9iamVjdDIsIF9pbnRlcm5hbF92aXNpdGVkID0gbmV3IFdlYWtTZXQoKSkge1xuICAgIGlmIChpc1ByaW1pdGl2ZShvYmplY3QxKSB8fCBpc1ByaW1pdGl2ZShvYmplY3QyKSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmlzKG9iamVjdDEsIG9iamVjdDIpO1xuICAgIH1cbiAgICBpZiAoaXNEYXRlT2JqZWN0KG9iamVjdDEpICYmIGlzRGF0ZU9iamVjdChvYmplY3QyKSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0MS5nZXRUaW1lKCkgPT09IG9iamVjdDIuZ2V0VGltZSgpO1xuICAgIH1cbiAgICBjb25zdCBrZXlzMSA9IE9iamVjdC5rZXlzKG9iamVjdDEpO1xuICAgIGNvbnN0IGtleXMyID0gT2JqZWN0LmtleXMob2JqZWN0Mik7XG4gICAgaWYgKGtleXMxLmxlbmd0aCAhPT0ga2V5czIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKF9pbnRlcm5hbF92aXNpdGVkLmhhcyhvYmplY3QxKSB8fCBfaW50ZXJuYWxfdmlzaXRlZC5oYXMob2JqZWN0MikpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF92aXNpdGVkLmFkZChvYmplY3QxKTtcbiAgICBfaW50ZXJuYWxfdmlzaXRlZC5hZGQob2JqZWN0Mik7XG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5czEpIHtcbiAgICAgICAgY29uc3QgdmFsMSA9IG9iamVjdDFba2V5XTtcbiAgICAgICAgaWYgKCFrZXlzMi5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleSAhPT0gJ3JlZicpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbDIgPSBvYmplY3QyW2tleV07XG4gICAgICAgICAgICBpZiAoKGlzRGF0ZU9iamVjdCh2YWwxKSAmJiBpc0RhdGVPYmplY3QodmFsMikpIHx8XG4gICAgICAgICAgICAgICAgKGlzT2JqZWN0KHZhbDEpICYmIGlzT2JqZWN0KHZhbDIpKSB8fFxuICAgICAgICAgICAgICAgIChBcnJheS5pc0FycmF5KHZhbDEpICYmIEFycmF5LmlzQXJyYXkodmFsMikpXG4gICAgICAgICAgICAgICAgPyAhZGVlcEVxdWFsKHZhbDEsIHZhbDIsIF9pbnRlcm5hbF92aXNpdGVkKVxuICAgICAgICAgICAgICAgIDogIU9iamVjdC5pcyh2YWwxLCB2YWwyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBDdXN0b20gaG9vayB0byBzdWJzY3JpYmUgdG8gZmllbGQgY2hhbmdlIGFuZCBpc29sYXRlIHJlLXJlbmRlcmluZyBhdCB0aGUgY29tcG9uZW50IGxldmVsLlxuICpcbiAqIEByZW1hcmtzXG4gKlxuICogW0FQSV0oaHR0cHM6Ly9yZWFjdC1ob29rLWZvcm0uY29tL2RvY3MvdXNld2F0Y2gpIOKAoiBbRGVtb10oaHR0cHM6Ly9jb2Rlc2FuZGJveC5pby9zL3JlYWN0LWhvb2stZm9ybS12Ny10cy11c2V3YXRjaC1oOWk1ZSlcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHN4XG4gKiBjb25zdCB7IGNvbnRyb2wgfSA9IHVzZUZvcm0oKTtcbiAqIGNvbnN0IHZhbHVlcyA9IHVzZVdhdGNoKHtcbiAqICAgbmFtZTogXCJmaWVsZE5hbWVcIlxuICogICBjb250cm9sLFxuICogfSlcbiAqIGBgYFxuICovXG5mdW5jdGlvbiB1c2VXYXRjaChwcm9wcykge1xuICAgIGNvbnN0IG1ldGhvZHMgPSB1c2VGb3JtQ29udGV4dCgpO1xuICAgIGNvbnN0IHsgY29udHJvbCA9IG1ldGhvZHMuY29udHJvbCwgbmFtZSwgZGVmYXVsdFZhbHVlLCBkaXNhYmxlZCwgZXhhY3QsIGNvbXB1dGUsIH0gPSBwcm9wcyB8fCB7fTtcbiAgICBjb25zdCBfZGVmYXVsdFZhbHVlID0gUmVhY3QudXNlUmVmKGRlZmF1bHRWYWx1ZSk7XG4gICAgY29uc3QgX2NvbXB1dGUgPSBSZWFjdC51c2VSZWYoY29tcHV0ZSk7XG4gICAgY29uc3QgX2NvbXB1dGVGb3JtVmFsdWVzID0gUmVhY3QudXNlUmVmKHVuZGVmaW5lZCk7XG4gICAgY29uc3QgX3ByZXZDb250cm9sID0gUmVhY3QudXNlUmVmKGNvbnRyb2wpO1xuICAgIGNvbnN0IF9wcmV2TmFtZSA9IFJlYWN0LnVzZVJlZihuYW1lKTtcbiAgICBfY29tcHV0ZS5jdXJyZW50ID0gY29tcHV0ZTtcbiAgICBjb25zdCBbdmFsdWUsIHVwZGF0ZVZhbHVlXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IHtcbiAgICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gY29udHJvbC5fZ2V0V2F0Y2gobmFtZSwgX2RlZmF1bHRWYWx1ZS5jdXJyZW50KTtcbiAgICAgICAgcmV0dXJuIF9jb21wdXRlLmN1cnJlbnQgPyBfY29tcHV0ZS5jdXJyZW50KGRlZmF1bHRWYWx1ZSkgOiBkZWZhdWx0VmFsdWU7XG4gICAgfSk7XG4gICAgY29uc3QgZ2V0Q3VycmVudE91dHB1dCA9IFJlYWN0LnVzZUNhbGxiYWNrKCh2YWx1ZXMpID0+IHtcbiAgICAgICAgY29uc3QgZm9ybVZhbHVlcyA9IGdlbmVyYXRlV2F0Y2hPdXRwdXQobmFtZSwgY29udHJvbC5fbmFtZXMsIHZhbHVlcyB8fCBjb250cm9sLl9mb3JtVmFsdWVzLCBmYWxzZSwgX2RlZmF1bHRWYWx1ZS5jdXJyZW50KTtcbiAgICAgICAgcmV0dXJuIF9jb21wdXRlLmN1cnJlbnQgPyBfY29tcHV0ZS5jdXJyZW50KGZvcm1WYWx1ZXMpIDogZm9ybVZhbHVlcztcbiAgICB9LCBbY29udHJvbC5fZm9ybVZhbHVlcywgY29udHJvbC5fbmFtZXMsIG5hbWVdKTtcbiAgICBjb25zdCByZWZyZXNoVmFsdWUgPSBSZWFjdC51c2VDYWxsYmFjaygodmFsdWVzKSA9PiB7XG4gICAgICAgIGlmICghZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGZvcm1WYWx1ZXMgPSBnZW5lcmF0ZVdhdGNoT3V0cHV0KG5hbWUsIGNvbnRyb2wuX25hbWVzLCB2YWx1ZXMgfHwgY29udHJvbC5fZm9ybVZhbHVlcywgZmFsc2UsIF9kZWZhdWx0VmFsdWUuY3VycmVudCk7XG4gICAgICAgICAgICBpZiAoX2NvbXB1dGUuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXB1dGVkRm9ybVZhbHVlcyA9IF9jb21wdXRlLmN1cnJlbnQoZm9ybVZhbHVlcyk7XG4gICAgICAgICAgICAgICAgaWYgKCFkZWVwRXF1YWwoY29tcHV0ZWRGb3JtVmFsdWVzLCBfY29tcHV0ZUZvcm1WYWx1ZXMuY3VycmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlVmFsdWUoY29tcHV0ZWRGb3JtVmFsdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgX2NvbXB1dGVGb3JtVmFsdWVzLmN1cnJlbnQgPSBjb21wdXRlZEZvcm1WYWx1ZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlVmFsdWUoZm9ybVZhbHVlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbY29udHJvbC5fZm9ybVZhbHVlcywgY29udHJvbC5fbmFtZXMsIGRpc2FibGVkLCBuYW1lXSk7XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChfcHJldkNvbnRyb2wuY3VycmVudCAhPT0gY29udHJvbCB8fFxuICAgICAgICAgICAgIWRlZXBFcXVhbChfcHJldk5hbWUuY3VycmVudCwgbmFtZSkpIHtcbiAgICAgICAgICAgIF9wcmV2Q29udHJvbC5jdXJyZW50ID0gY29udHJvbDtcbiAgICAgICAgICAgIF9wcmV2TmFtZS5jdXJyZW50ID0gbmFtZTtcbiAgICAgICAgICAgIHJlZnJlc2hWYWx1ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250cm9sLl9zdWJzY3JpYmUoe1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGZvcm1TdGF0ZToge1xuICAgICAgICAgICAgICAgIHZhbHVlczogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBleGFjdCxcbiAgICAgICAgICAgIGNhbGxiYWNrOiAoZm9ybVN0YXRlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVmcmVzaFZhbHVlKGZvcm1TdGF0ZS52YWx1ZXMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfSwgW2NvbnRyb2wsIGV4YWN0LCBuYW1lLCByZWZyZXNoVmFsdWVdKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4gY29udHJvbC5fcmVtb3ZlVW5tb3VudGVkKCkpO1xuICAgIC8vIElmIG5hbWUgb3IgY29udHJvbCBjaGFuZ2VkIGZvciB0aGlzIHJlbmRlciwgc3luY2hyb25vdXNseSByZWZsZWN0IHRoZVxuICAgIC8vIGxhdGVzdCB2YWx1ZSBzbyBjYWxsZXJzIChsaWtlIHVzZUNvbnRyb2xsZXIpIHNlZSB0aGUgY29ycmVjdCB2YWx1ZVxuICAgIC8vIGltbWVkaWF0ZWx5IG9uIHRoZSBzYW1lIHJlbmRlci5cbiAgICAvLyBPcHRpbWl6ZTogQ2hlY2sgY29udHJvbCByZWZlcmVuY2UgZmlyc3QgYmVmb3JlIGV4cGVuc2l2ZSBkZWVwRXF1YWxcbiAgICBjb25zdCBjb250cm9sQ2hhbmdlZCA9IF9wcmV2Q29udHJvbC5jdXJyZW50ICE9PSBjb250cm9sO1xuICAgIGNvbnN0IHByZXZOYW1lID0gX3ByZXZOYW1lLmN1cnJlbnQ7XG4gICAgLy8gQ2FjaGUgdGhlIGNvbXB1dGVkIG91dHB1dCB0byBhdm9pZCBkdXBsaWNhdGUgY2FsbHMgd2l0aGluIHRoZSBzYW1lIHJlbmRlclxuICAgIC8vIFdlIGluY2x1ZGUgc2hvdWxkUmV0dXJuSW1tZWRpYXRlIGluIGRlcHMgdG8gZW5zdXJlIHByb3BlciByZWNvbXB1dGF0aW9uXG4gICAgY29uc3QgY29tcHV0ZWRPdXRwdXQgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuYW1lQ2hhbmdlZCA9ICFjb250cm9sQ2hhbmdlZCAmJiAhZGVlcEVxdWFsKHByZXZOYW1lLCBuYW1lKTtcbiAgICAgICAgY29uc3Qgc2hvdWxkUmV0dXJuSW1tZWRpYXRlID0gY29udHJvbENoYW5nZWQgfHwgbmFtZUNoYW5nZWQ7XG4gICAgICAgIHJldHVybiBzaG91bGRSZXR1cm5JbW1lZGlhdGUgPyBnZXRDdXJyZW50T3V0cHV0KCkgOiBudWxsO1xuICAgIH0sIFtkaXNhYmxlZCwgY29udHJvbENoYW5nZWQsIG5hbWUsIHByZXZOYW1lLCBnZXRDdXJyZW50T3V0cHV0XSk7XG4gICAgcmV0dXJuIGNvbXB1dGVkT3V0cHV0ICE9PSBudWxsID8gY29tcHV0ZWRPdXRwdXQgOiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBDdXN0b20gaG9vayB0byB3b3JrIHdpdGggY29udHJvbGxlZCBjb21wb25lbnQsIHRoaXMgZnVuY3Rpb24gcHJvdmlkZSB5b3Ugd2l0aCBib3RoIGZvcm0gYW5kIGZpZWxkIGxldmVsIHN0YXRlLiBSZS1yZW5kZXIgaXMgaXNvbGF0ZWQgYXQgdGhlIGhvb2sgbGV2ZWwuXG4gKlxuICogQHJlbWFya3NcbiAqIFtBUEldKGh0dHBzOi8vcmVhY3QtaG9vay1mb3JtLmNvbS9kb2NzL3VzZWNvbnRyb2xsZXIpIOKAoiBbRGVtb10oaHR0cHM6Ly9jb2Rlc2FuZGJveC5pby9zL3VzZWNvbnRyb2xsZXItMG84cHgpXG4gKlxuICogQHBhcmFtIHByb3BzIC0gdGhlIHBhdGggbmFtZSB0byB0aGUgZm9ybSBmaWVsZCB2YWx1ZSwgYW5kIHZhbGlkYXRpb24gcnVsZXMuXG4gKlxuICogQHJldHVybnMgZmllbGQgcHJvcGVydGllcywgZmllbGQgYW5kIGZvcm0gc3RhdGUuIHtAbGluayBVc2VDb250cm9sbGVyUmV0dXJufVxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c3hcbiAqIGZ1bmN0aW9uIElucHV0KHByb3BzKSB7XG4gKiAgIGNvbnN0IHsgZmllbGQsIGZpZWxkU3RhdGUsIGZvcm1TdGF0ZSB9ID0gdXNlQ29udHJvbGxlcihwcm9wcyk7XG4gKiAgIHJldHVybiAoXG4gKiAgICAgPGRpdj5cbiAqICAgICAgIDxpbnB1dCB7Li4uZmllbGR9IHBsYWNlaG9sZGVyPXtwcm9wcy5uYW1lfSAvPlxuICogICAgICAgPHA+e2ZpZWxkU3RhdGUuaXNUb3VjaGVkICYmIFwiVG91Y2hlZFwifTwvcD5cbiAqICAgICAgIDxwPntmb3JtU3RhdGUuaXNTdWJtaXR0ZWQgPyBcInN1Ym1pdHRlZFwiIDogXCJcIn08L3A+XG4gKiAgICAgPC9kaXY+XG4gKiAgICk7XG4gKiB9XG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gdXNlQ29udHJvbGxlcihwcm9wcykge1xuICAgIGNvbnN0IG1ldGhvZHMgPSB1c2VGb3JtQ29udGV4dCgpO1xuICAgIGNvbnN0IHsgbmFtZSwgZGlzYWJsZWQsIGNvbnRyb2wgPSBtZXRob2RzLmNvbnRyb2wsIHNob3VsZFVucmVnaXN0ZXIsIGRlZmF1bHRWYWx1ZSwgZXhhY3QgPSB0cnVlLCB9ID0gcHJvcHM7XG4gICAgY29uc3QgaXNBcnJheUZpZWxkID0gaXNOYW1lSW5GaWVsZEFycmF5KGNvbnRyb2wuX25hbWVzLmFycmF5LCBuYW1lKTtcbiAgICBjb25zdCBkZWZhdWx0VmFsdWVNZW1vID0gUmVhY3QudXNlTWVtbygoKSA9PiBnZXQoY29udHJvbC5fZm9ybVZhbHVlcywgbmFtZSwgZ2V0KGNvbnRyb2wuX2RlZmF1bHRWYWx1ZXMsIG5hbWUsIGRlZmF1bHRWYWx1ZSkpLCBbY29udHJvbCwgbmFtZSwgZGVmYXVsdFZhbHVlXSk7XG4gICAgY29uc3QgdmFsdWUgPSB1c2VXYXRjaCh7XG4gICAgICAgIGNvbnRyb2wsXG4gICAgICAgIG5hbWUsXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogZGVmYXVsdFZhbHVlTWVtbyxcbiAgICAgICAgZXhhY3QsXG4gICAgfSk7XG4gICAgY29uc3QgZm9ybVN0YXRlID0gdXNlRm9ybVN0YXRlKHtcbiAgICAgICAgY29udHJvbCxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgZXhhY3QsXG4gICAgfSk7XG4gICAgY29uc3QgX3Byb3BzID0gUmVhY3QudXNlUmVmKHByb3BzKTtcbiAgICBjb25zdCBfcHJldmlvdXNOYW1lUmVmID0gUmVhY3QudXNlUmVmKHVuZGVmaW5lZCk7XG4gICAgY29uc3QgX3JlZ2lzdGVyUHJvcHMgPSBSZWFjdC51c2VSZWYoY29udHJvbC5yZWdpc3RlcihuYW1lLCB7XG4gICAgICAgIC4uLnByb3BzLnJ1bGVzLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgLi4uKGlzQm9vbGVhbihwcm9wcy5kaXNhYmxlZCkgPyB7IGRpc2FibGVkOiBwcm9wcy5kaXNhYmxlZCB9IDoge30pLFxuICAgIH0pKTtcbiAgICBfcHJvcHMuY3VycmVudCA9IHByb3BzO1xuICAgIGNvbnN0IGZpZWxkU3RhdGUgPSBSZWFjdC51c2VNZW1vKCgpID0+IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHt9LCB7XG4gICAgICAgIGludmFsaWQ6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6ICgpID0+ICEhZ2V0KGZvcm1TdGF0ZS5lcnJvcnMsIG5hbWUpLFxuICAgICAgICB9LFxuICAgICAgICBpc0RpcnR5OiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiAoKSA9PiAhIWdldChmb3JtU3RhdGUuZGlydHlGaWVsZHMsIG5hbWUpLFxuICAgICAgICB9LFxuICAgICAgICBpc1RvdWNoZWQ6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6ICgpID0+ICEhZ2V0KGZvcm1TdGF0ZS50b3VjaGVkRmllbGRzLCBuYW1lKSxcbiAgICAgICAgfSxcbiAgICAgICAgaXNWYWxpZGF0aW5nOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiAoKSA9PiAhIWdldChmb3JtU3RhdGUudmFsaWRhdGluZ0ZpZWxkcywgbmFtZSksXG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiAoKSA9PiBnZXQoZm9ybVN0YXRlLmVycm9ycywgbmFtZSksXG4gICAgICAgIH0sXG4gICAgfSksIFtmb3JtU3RhdGUsIG5hbWVdKTtcbiAgICBjb25zdCBvbkNoYW5nZSA9IFJlYWN0LnVzZUNhbGxiYWNrKChldmVudCkgPT4gX3JlZ2lzdGVyUHJvcHMuY3VycmVudC5vbkNoYW5nZSh7XG4gICAgICAgIHRhcmdldDoge1xuICAgICAgICAgICAgdmFsdWU6IGdldEV2ZW50VmFsdWUoZXZlbnQpLFxuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgfSxcbiAgICAgICAgdHlwZTogRVZFTlRTLkNIQU5HRSxcbiAgICB9KSwgW25hbWVdKTtcbiAgICBjb25zdCBvbkJsdXIgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiBfcmVnaXN0ZXJQcm9wcy5jdXJyZW50Lm9uQmx1cih7XG4gICAgICAgIHRhcmdldDoge1xuICAgICAgICAgICAgdmFsdWU6IGdldChjb250cm9sLl9mb3JtVmFsdWVzLCBuYW1lKSxcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIH0sXG4gICAgICAgIHR5cGU6IEVWRU5UUy5CTFVSLFxuICAgIH0pLCBbbmFtZSwgY29udHJvbC5fZm9ybVZhbHVlc10pO1xuICAgIGNvbnN0IHJlZiA9IFJlYWN0LnVzZUNhbGxiYWNrKChlbG0pID0+IHtcbiAgICAgICAgY29uc3QgZmllbGQgPSBnZXQoY29udHJvbC5fZmllbGRzLCBuYW1lKTtcbiAgICAgICAgaWYgKGZpZWxkICYmIGVsbSkge1xuICAgICAgICAgICAgZmllbGQuX2YucmVmID0ge1xuICAgICAgICAgICAgICAgIGZvY3VzOiAoKSA9PiBlbG0uZm9jdXMgJiYgZWxtLmZvY3VzKCksXG4gICAgICAgICAgICAgICAgc2VsZWN0OiAoKSA9PiBlbG0uc2VsZWN0ICYmIGVsbS5zZWxlY3QoKSxcbiAgICAgICAgICAgICAgICBzZXRDdXN0b21WYWxpZGl0eTogKG1lc3NhZ2UpID0+IGVsbS5zZXRDdXN0b21WYWxpZGl0eShtZXNzYWdlKSxcbiAgICAgICAgICAgICAgICByZXBvcnRWYWxpZGl0eTogKCkgPT4gZWxtLnJlcG9ydFZhbGlkaXR5KCksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSwgW2NvbnRyb2wuX2ZpZWxkcywgbmFtZV0pO1xuICAgIGNvbnN0IGZpZWxkID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgICAgICBuYW1lLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgLi4uKGlzQm9vbGVhbihkaXNhYmxlZCkgfHwgZm9ybVN0YXRlLmRpc2FibGVkXG4gICAgICAgICAgICA/IHsgZGlzYWJsZWQ6IGZvcm1TdGF0ZS5kaXNhYmxlZCB8fCBkaXNhYmxlZCB9XG4gICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgb25DaGFuZ2UsXG4gICAgICAgIG9uQmx1cixcbiAgICAgICAgcmVmLFxuICAgIH0pLCBbbmFtZSwgZGlzYWJsZWQsIGZvcm1TdGF0ZS5kaXNhYmxlZCwgb25DaGFuZ2UsIG9uQmx1ciwgcmVmLCB2YWx1ZV0pO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IF9zaG91bGRVbnJlZ2lzdGVyRmllbGQgPSBjb250cm9sLl9vcHRpb25zLnNob3VsZFVucmVnaXN0ZXIgfHwgc2hvdWxkVW5yZWdpc3RlcjtcbiAgICAgICAgY29uc3QgcHJldmlvdXNOYW1lID0gX3ByZXZpb3VzTmFtZVJlZi5jdXJyZW50O1xuICAgICAgICBpZiAocHJldmlvdXNOYW1lICYmIHByZXZpb3VzTmFtZSAhPT0gbmFtZSAmJiAhaXNBcnJheUZpZWxkKSB7XG4gICAgICAgICAgICBjb250cm9sLnVucmVnaXN0ZXIocHJldmlvdXNOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBjb250cm9sLnJlZ2lzdGVyKG5hbWUsIHtcbiAgICAgICAgICAgIC4uLl9wcm9wcy5jdXJyZW50LnJ1bGVzLFxuICAgICAgICAgICAgLi4uKGlzQm9vbGVhbihfcHJvcHMuY3VycmVudC5kaXNhYmxlZClcbiAgICAgICAgICAgICAgICA/IHsgZGlzYWJsZWQ6IF9wcm9wcy5jdXJyZW50LmRpc2FibGVkIH1cbiAgICAgICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHVwZGF0ZU1vdW50ZWQgPSAobmFtZSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gZ2V0KGNvbnRyb2wuX2ZpZWxkcywgbmFtZSk7XG4gICAgICAgICAgICBpZiAoZmllbGQgJiYgZmllbGQuX2YpIHtcbiAgICAgICAgICAgICAgICBmaWVsZC5fZi5tb3VudCA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB1cGRhdGVNb3VudGVkKG5hbWUsIHRydWUpO1xuICAgICAgICBpZiAoX3Nob3VsZFVucmVnaXN0ZXJGaWVsZCkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBjbG9uZU9iamVjdChnZXQoY29udHJvbC5fb3B0aW9ucy5kZWZhdWx0VmFsdWVzLCBuYW1lLCBfcHJvcHMuY3VycmVudC5kZWZhdWx0VmFsdWUpKTtcbiAgICAgICAgICAgIHNldChjb250cm9sLl9kZWZhdWx0VmFsdWVzLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQoZ2V0KGNvbnRyb2wuX2Zvcm1WYWx1ZXMsIG5hbWUpKSkge1xuICAgICAgICAgICAgICAgIHNldChjb250cm9sLl9mb3JtVmFsdWVzLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgIWlzQXJyYXlGaWVsZCAmJiBjb250cm9sLnJlZ2lzdGVyKG5hbWUpO1xuICAgICAgICBfcHJldmlvdXNOYW1lUmVmLmN1cnJlbnQgPSBuYW1lO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgKGlzQXJyYXlGaWVsZFxuICAgICAgICAgICAgICAgID8gX3Nob3VsZFVucmVnaXN0ZXJGaWVsZCAmJiAhY29udHJvbC5fc3RhdGUuYWN0aW9uXG4gICAgICAgICAgICAgICAgOiBfc2hvdWxkVW5yZWdpc3RlckZpZWxkKVxuICAgICAgICAgICAgICAgID8gY29udHJvbC51bnJlZ2lzdGVyKG5hbWUpXG4gICAgICAgICAgICAgICAgOiB1cGRhdGVNb3VudGVkKG5hbWUsIGZhbHNlKTtcbiAgICAgICAgfTtcbiAgICB9LCBbbmFtZSwgY29udHJvbCwgaXNBcnJheUZpZWxkLCBzaG91bGRVbnJlZ2lzdGVyXSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29udHJvbC5fc2V0RGlzYWJsZWRGaWVsZCh7XG4gICAgICAgICAgICBkaXNhYmxlZCxcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgIH0pO1xuICAgIH0sIFtkaXNhYmxlZCwgbmFtZSwgY29udHJvbF0pO1xuICAgIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgICAgIGZpZWxkLFxuICAgICAgICBmb3JtU3RhdGUsXG4gICAgICAgIGZpZWxkU3RhdGUsXG4gICAgfSksIFtmaWVsZCwgZm9ybVN0YXRlLCBmaWVsZFN0YXRlXSk7XG59XG5cbi8qKlxuICogQ29tcG9uZW50IGJhc2VkIG9uIGB1c2VDb250cm9sbGVyYCBob29rIHRvIHdvcmsgd2l0aCBjb250cm9sbGVkIGNvbXBvbmVudC5cbiAqXG4gKiBAcmVtYXJrc1xuICogW0FQSV0oaHR0cHM6Ly9yZWFjdC1ob29rLWZvcm0uY29tL2RvY3MvdXNlY29udHJvbGxlci9jb250cm9sbGVyKSDigKIgW0RlbW9dKGh0dHBzOi8vY29kZXNhbmRib3guaW8vcy9yZWFjdC1ob29rLWZvcm0tdjYtY29udHJvbGxlci10cy1qd3l6dykg4oCiIFtWaWRlb10oaHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1OMlVOa19VQ1Z5QSlcbiAqXG4gKiBAcGFyYW0gcHJvcHMgLSB0aGUgcGF0aCBuYW1lIHRvIHRoZSBmb3JtIGZpZWxkIHZhbHVlLCBhbmQgdmFsaWRhdGlvbiBydWxlcy5cbiAqXG4gKiBAcmV0dXJucyBwcm92aWRlIGZpZWxkIGhhbmRsZXIgZnVuY3Rpb25zLCBmaWVsZCBhbmQgZm9ybSBzdGF0ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHN4XG4gKiBmdW5jdGlvbiBBcHAoKSB7XG4gKiAgIGNvbnN0IHsgY29udHJvbCB9ID0gdXNlRm9ybTxGb3JtVmFsdWVzPih7XG4gKiAgICAgZGVmYXVsdFZhbHVlczoge1xuICogICAgICAgdGVzdDogXCJcIlxuICogICAgIH1cbiAqICAgfSk7XG4gKlxuICogICByZXR1cm4gKFxuICogICAgIDxmb3JtPlxuICogICAgICAgPENvbnRyb2xsZXJcbiAqICAgICAgICAgY29udHJvbD17Y29udHJvbH1cbiAqICAgICAgICAgbmFtZT1cInRlc3RcIlxuICogICAgICAgICByZW5kZXI9eyh7IGZpZWxkOiB7IG9uQ2hhbmdlLCBvbkJsdXIsIHZhbHVlLCByZWYgfSwgZm9ybVN0YXRlLCBmaWVsZFN0YXRlIH0pID0+IChcbiAqICAgICAgICAgICA8PlxuICogICAgICAgICAgICAgPGlucHV0XG4gKiAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtvbkNoYW5nZX0gLy8gc2VuZCB2YWx1ZSB0byBob29rIGZvcm1cbiAqICAgICAgICAgICAgICAgb25CbHVyPXtvbkJsdXJ9IC8vIG5vdGlmeSB3aGVuIGlucHV0IGlzIHRvdWNoZWRcbiAqICAgICAgICAgICAgICAgdmFsdWU9e3ZhbHVlfSAvLyByZXR1cm4gdXBkYXRlZCB2YWx1ZVxuICogICAgICAgICAgICAgICByZWY9e3JlZn0gLy8gc2V0IHJlZiBmb3IgZm9jdXMgbWFuYWdlbWVudFxuICogICAgICAgICAgICAgLz5cbiAqICAgICAgICAgICAgIDxwPntmb3JtU3RhdGUuaXNTdWJtaXR0ZWQgPyBcInN1Ym1pdHRlZFwiIDogXCJcIn08L3A+XG4gKiAgICAgICAgICAgICA8cD57ZmllbGRTdGF0ZS5pc1RvdWNoZWQgPyBcInRvdWNoZWRcIiA6IFwiXCJ9PC9wPlxuICogICAgICAgICAgIDwvPlxuICogICAgICAgICApfVxuICogICAgICAgLz5cbiAqICAgICA8L2Zvcm0+XG4gKiAgICk7XG4gKiB9XG4gKiBgYGBcbiAqL1xuY29uc3QgQ29udHJvbGxlciA9IChwcm9wcykgPT4gcHJvcHMucmVuZGVyKHVzZUNvbnRyb2xsZXIocHJvcHMpKTtcblxuY29uc3QgZmxhdHRlbiA9IChvYmopID0+IHtcbiAgICBjb25zdCBvdXRwdXQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhvYmopKSB7XG4gICAgICAgIGlmIChpc09iamVjdFR5cGUob2JqW2tleV0pICYmIG9ialtrZXldICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBuZXN0ZWQgPSBmbGF0dGVuKG9ialtrZXldKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbmVzdGVkS2V5IG9mIE9iamVjdC5rZXlzKG5lc3RlZCkpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRbYCR7a2V5fS4ke25lc3RlZEtleX1gXSA9IG5lc3RlZFtuZXN0ZWRLZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3V0cHV0W2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xufTtcblxuY29uc3QgUE9TVF9SRVFVRVNUID0gJ3Bvc3QnO1xuLyoqXG4gKiBGb3JtIGNvbXBvbmVudCB0byBtYW5hZ2Ugc3VibWlzc2lvbi5cbiAqXG4gKiBAcGFyYW0gcHJvcHMgLSB0byBzZXR1cCBzdWJtaXNzaW9uIGRldGFpbC4ge0BsaW5rIEZvcm1Qcm9wc31cbiAqXG4gKiBAcmV0dXJucyBmb3JtIGNvbXBvbmVudCBvciBoZWFkbGVzcyByZW5kZXIgcHJvcC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHN4XG4gKiBmdW5jdGlvbiBBcHAoKSB7XG4gKiAgIGNvbnN0IHsgY29udHJvbCwgZm9ybVN0YXRlOiB7IGVycm9ycyB9IH0gPSB1c2VGb3JtKCk7XG4gKlxuICogICByZXR1cm4gKFxuICogICAgIDxGb3JtIGFjdGlvbj1cIi9hcGlcIiBjb250cm9sPXtjb250cm9sfT5cbiAqICAgICAgIDxpbnB1dCB7Li4ucmVnaXN0ZXIoXCJuYW1lXCIpfSAvPlxuICogICAgICAgPHA+e2Vycm9ycz8ucm9vdD8uc2VydmVyICYmICdTZXJ2ZXIgZXJyb3InfTwvcD5cbiAqICAgICAgIDxidXR0b24+U3VibWl0PC9idXR0b24+XG4gKiAgICAgPC9Gb3JtPlxuICogICApO1xuICogfVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIEZvcm0ocHJvcHMpIHtcbiAgICBjb25zdCBtZXRob2RzID0gdXNlRm9ybUNvbnRleHQoKTtcbiAgICBjb25zdCBbbW91bnRlZCwgc2V0TW91bnRlZF0gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgeyBjb250cm9sID0gbWV0aG9kcy5jb250cm9sLCBvblN1Ym1pdCwgY2hpbGRyZW4sIGFjdGlvbiwgbWV0aG9kID0gUE9TVF9SRVFVRVNULCBoZWFkZXJzLCBlbmNUeXBlLCBvbkVycm9yLCByZW5kZXIsIG9uU3VjY2VzcywgdmFsaWRhdGVTdGF0dXMsIC4uLnJlc3QgfSA9IHByb3BzO1xuICAgIGNvbnN0IHN1Ym1pdCA9IGFzeW5jIChldmVudCkgPT4ge1xuICAgICAgICBsZXQgaGFzRXJyb3IgPSBmYWxzZTtcbiAgICAgICAgbGV0IHR5cGUgPSAnJztcbiAgICAgICAgYXdhaXQgY29udHJvbC5oYW5kbGVTdWJtaXQoYXN5bmMgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgICAgICAgICBsZXQgZm9ybURhdGFKc29uID0gJyc7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvcm1EYXRhSnNvbiA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKF9hKSB7IH1cbiAgICAgICAgICAgIGNvbnN0IGZsYXR0ZW5Gb3JtVmFsdWVzID0gZmxhdHRlbihjb250cm9sLl9mb3JtVmFsdWVzKTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGZsYXR0ZW5Gb3JtVmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKGtleSwgZmxhdHRlbkZvcm1WYWx1ZXNba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob25TdWJtaXQpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBvblN1Ym1pdCh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICAgICAgICAgIGZvcm1EYXRhLFxuICAgICAgICAgICAgICAgICAgICBmb3JtRGF0YUpzb24sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2hvdWxkU3RyaW5naWZ5U3VibWlzc2lvbkRhdGEgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzICYmIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5jVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgXS5zb21lKCh2YWx1ZSkgPT4gdmFsdWUgJiYgdmFsdWUuaW5jbHVkZXMoJ2pzb24nKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goU3RyaW5nKGFjdGlvbiksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLihlbmNUeXBlICYmIGVuY1R5cGUgIT09ICdtdWx0aXBhcnQvZm9ybS1kYXRhJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHsgJ0NvbnRlbnQtVHlwZSc6IGVuY1R5cGUgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBzaG91bGRTdHJpbmdpZnlTdWJtaXNzaW9uRGF0YSA/IGZvcm1EYXRhSnNvbiA6IGZvcm1EYXRhLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAodmFsaWRhdGVTdGF0dXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICF2YWxpZGF0ZVN0YXR1cyhyZXNwb25zZS5zdGF0dXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiByZXNwb25zZS5zdGF0dXMgPCAyMDAgfHwgcmVzcG9uc2Uuc3RhdHVzID49IDMwMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uRXJyb3IgJiYgb25FcnJvcih7IHJlc3BvbnNlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9IFN0cmluZyhyZXNwb25zZS5zdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25TdWNjZXNzICYmIG9uU3VjY2Vzcyh7IHJlc3BvbnNlIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBoYXNFcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IgJiYgb25FcnJvcih7IGVycm9yIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoZXZlbnQpO1xuICAgICAgICBpZiAoaGFzRXJyb3IgJiYgcHJvcHMuY29udHJvbCkge1xuICAgICAgICAgICAgcHJvcHMuY29udHJvbC5fc3ViamVjdHMuc3RhdGUubmV4dCh7XG4gICAgICAgICAgICAgICAgaXNTdWJtaXRTdWNjZXNzZnVsOiBmYWxzZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcHJvcHMuY29udHJvbC5zZXRFcnJvcigncm9vdC5zZXJ2ZXInLCB7XG4gICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBzZXRNb3VudGVkKHRydWUpO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gcmVuZGVyID8gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIHJlbmRlcih7XG4gICAgICAgIHN1Ym1pdCxcbiAgICB9KSkpIDogKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJmb3JtXCIsIHsgbm9WYWxpZGF0ZTogbW91bnRlZCwgYWN0aW9uOiBhY3Rpb24sIG1ldGhvZDogbWV0aG9kLCBlbmNUeXBlOiBlbmNUeXBlLCBvblN1Ym1pdDogc3VibWl0LCAuLi5yZXN0IH0sIGNoaWxkcmVuKSk7XG59XG5cbnZhciBhcHBlbmRFcnJvcnMgPSAobmFtZSwgdmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhLCBlcnJvcnMsIHR5cGUsIG1lc3NhZ2UpID0+IHZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYVxuICAgID8ge1xuICAgICAgICAuLi5lcnJvcnNbbmFtZV0sXG4gICAgICAgIHR5cGVzOiB7XG4gICAgICAgICAgICAuLi4oZXJyb3JzW25hbWVdICYmIGVycm9yc1tuYW1lXS50eXBlcyA/IGVycm9yc1tuYW1lXS50eXBlcyA6IHt9KSxcbiAgICAgICAgICAgIFt0eXBlXTogbWVzc2FnZSB8fCB0cnVlLFxuICAgICAgICB9LFxuICAgIH1cbiAgICA6IHt9O1xuXG52YXIgY29udmVydFRvQXJyYXlQYXlsb2FkID0gKHZhbHVlKSA9PiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV0pO1xuXG52YXIgY3JlYXRlU3ViamVjdCA9ICgpID0+IHtcbiAgICBsZXQgX29ic2VydmVycyA9IFtdO1xuICAgIGNvbnN0IG5leHQgPSAodmFsdWUpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBvYnNlcnZlciBvZiBfb2JzZXJ2ZXJzKSB7XG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0ICYmIG9ic2VydmVyLm5leHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBzdWJzY3JpYmUgPSAob2JzZXJ2ZXIpID0+IHtcbiAgICAgICAgX29ic2VydmVycy5wdXNoKG9ic2VydmVyKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgX29ic2VydmVycyA9IF9vYnNlcnZlcnMuZmlsdGVyKChvKSA9PiBvICE9PSBvYnNlcnZlcik7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgdW5zdWJzY3JpYmUgPSAoKSA9PiB7XG4gICAgICAgIF9vYnNlcnZlcnMgPSBbXTtcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIGdldCBvYnNlcnZlcnMoKSB7XG4gICAgICAgICAgICByZXR1cm4gX29ic2VydmVycztcbiAgICAgICAgfSxcbiAgICAgICAgbmV4dCxcbiAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICB1bnN1YnNjcmliZSxcbiAgICB9O1xufTtcblxuZnVuY3Rpb24gZXh0cmFjdEZvcm1WYWx1ZXMoZmllbGRzU3RhdGUsIGZvcm1WYWx1ZXMpIHtcbiAgICBjb25zdCB2YWx1ZXMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBmaWVsZHNTdGF0ZSkge1xuICAgICAgICBpZiAoZmllbGRzU3RhdGUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgY29uc3QgZmllbGRTdGF0ZSA9IGZpZWxkc1N0YXRlW2tleV07XG4gICAgICAgICAgICBjb25zdCBmaWVsZFZhbHVlID0gZm9ybVZhbHVlc1trZXldO1xuICAgICAgICAgICAgaWYgKGZpZWxkU3RhdGUgJiYgaXNPYmplY3QoZmllbGRTdGF0ZSkgJiYgZmllbGRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5lc3RlZEZpZWxkc1N0YXRlID0gZXh0cmFjdEZvcm1WYWx1ZXMoZmllbGRTdGF0ZSwgZmllbGRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KG5lc3RlZEZpZWxkc1N0YXRlKSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZXNba2V5XSA9IG5lc3RlZEZpZWxkc1N0YXRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkc1N0YXRlW2tleV0pIHtcbiAgICAgICAgICAgICAgICB2YWx1ZXNba2V5XSA9IGZpZWxkVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbn1cblxudmFyIGlzRW1wdHlPYmplY3QgPSAodmFsdWUpID0+IGlzT2JqZWN0KHZhbHVlKSAmJiAhT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aDtcblxudmFyIGlzRmlsZUlucHV0ID0gKGVsZW1lbnQpID0+IGVsZW1lbnQudHlwZSA9PT0gJ2ZpbGUnO1xuXG52YXIgaXNGdW5jdGlvbiA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xuXG52YXIgaXNIVE1MRWxlbWVudCA9ICh2YWx1ZSkgPT4ge1xuICAgIGlmICghaXNXZWIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBvd25lciA9IHZhbHVlID8gdmFsdWUub3duZXJEb2N1bWVudCA6IDA7XG4gICAgcmV0dXJuICh2YWx1ZSBpbnN0YW5jZW9mXG4gICAgICAgIChvd25lciAmJiBvd25lci5kZWZhdWx0VmlldyA/IG93bmVyLmRlZmF1bHRWaWV3LkhUTUxFbGVtZW50IDogSFRNTEVsZW1lbnQpKTtcbn07XG5cbnZhciBpc011bHRpcGxlU2VsZWN0ID0gKGVsZW1lbnQpID0+IGVsZW1lbnQudHlwZSA9PT0gYHNlbGVjdC1tdWx0aXBsZWA7XG5cbnZhciBpc1JhZGlvSW5wdXQgPSAoZWxlbWVudCkgPT4gZWxlbWVudC50eXBlID09PSAncmFkaW8nO1xuXG52YXIgaXNSYWRpb09yQ2hlY2tib3ggPSAocmVmKSA9PiBpc1JhZGlvSW5wdXQocmVmKSB8fCBpc0NoZWNrQm94SW5wdXQocmVmKTtcblxudmFyIGxpdmUgPSAocmVmKSA9PiBpc0hUTUxFbGVtZW50KHJlZikgJiYgcmVmLmlzQ29ubmVjdGVkO1xuXG5mdW5jdGlvbiBiYXNlR2V0KG9iamVjdCwgdXBkYXRlUGF0aCkge1xuICAgIGNvbnN0IGxlbmd0aCA9IHVwZGF0ZVBhdGguc2xpY2UoMCwgLTEpLmxlbmd0aDtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBvYmplY3QgPSBpc1VuZGVmaW5lZChvYmplY3QpID8gaW5kZXgrKyA6IG9iamVjdFt1cGRhdGVQYXRoW2luZGV4KytdXTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbn1cbmZ1bmN0aW9uIGlzRW1wdHlBcnJheShvYmopIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpICYmICFpc1VuZGVmaW5lZChvYmpba2V5XSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHVuc2V0KG9iamVjdCwgcGF0aCkge1xuICAgIGNvbnN0IHBhdGhzID0gQXJyYXkuaXNBcnJheShwYXRoKVxuICAgICAgICA/IHBhdGhcbiAgICAgICAgOiBpc0tleShwYXRoKVxuICAgICAgICAgICAgPyBbcGF0aF1cbiAgICAgICAgICAgIDogc3RyaW5nVG9QYXRoKHBhdGgpO1xuICAgIGNvbnN0IGNoaWxkT2JqZWN0ID0gcGF0aHMubGVuZ3RoID09PSAxID8gb2JqZWN0IDogYmFzZUdldChvYmplY3QsIHBhdGhzKTtcbiAgICBjb25zdCBpbmRleCA9IHBhdGhzLmxlbmd0aCAtIDE7XG4gICAgY29uc3Qga2V5ID0gcGF0aHNbaW5kZXhdO1xuICAgIGlmIChjaGlsZE9iamVjdCkge1xuICAgICAgICBkZWxldGUgY2hpbGRPYmplY3Rba2V5XTtcbiAgICB9XG4gICAgaWYgKGluZGV4ICE9PSAwICYmXG4gICAgICAgICgoaXNPYmplY3QoY2hpbGRPYmplY3QpICYmIGlzRW1wdHlPYmplY3QoY2hpbGRPYmplY3QpKSB8fFxuICAgICAgICAgICAgKEFycmF5LmlzQXJyYXkoY2hpbGRPYmplY3QpICYmIGlzRW1wdHlBcnJheShjaGlsZE9iamVjdCkpKSkge1xuICAgICAgICB1bnNldChvYmplY3QsIHBhdGhzLnNsaWNlKDAsIC0xKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG59XG5cbnZhciBvYmplY3RIYXNGdW5jdGlvbiA9IChkYXRhKSA9PiB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gZGF0YSkge1xuICAgICAgICBpZiAoaXNGdW5jdGlvbihkYXRhW2tleV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5mdW5jdGlvbiBpc1RyYXZlcnNhYmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IChpc09iamVjdCh2YWx1ZSkgJiYgIW9iamVjdEhhc0Z1bmN0aW9uKHZhbHVlKSk7XG59XG5mdW5jdGlvbiBtYXJrRmllbGRzRGlydHkoZGF0YSwgZmllbGRzID0ge30pIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBkYXRhKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZGF0YVtrZXldO1xuICAgICAgICBpZiAoaXNUcmF2ZXJzYWJsZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGZpZWxkc1trZXldID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyBbXSA6IHt9O1xuICAgICAgICAgICAgbWFya0ZpZWxkc0RpcnR5KHZhbHVlLCBmaWVsZHNba2V5XSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWlzVW5kZWZpbmVkKHZhbHVlKSkge1xuICAgICAgICAgICAgZmllbGRzW2tleV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmaWVsZHM7XG59XG5mdW5jdGlvbiBnZXREaXJ0eUZpZWxkcyhkYXRhLCBmb3JtVmFsdWVzLCBkaXJ0eUZpZWxkc0Zyb21WYWx1ZXMpIHtcbiAgICBpZiAoIWRpcnR5RmllbGRzRnJvbVZhbHVlcykge1xuICAgICAgICBkaXJ0eUZpZWxkc0Zyb21WYWx1ZXMgPSBtYXJrRmllbGRzRGlydHkoZm9ybVZhbHVlcyk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIGRhdGEpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBkYXRhW2tleV07XG4gICAgICAgIGlmIChpc1RyYXZlcnNhYmxlKHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGZvcm1WYWx1ZXMpIHx8IGlzUHJpbWl0aXZlKGRpcnR5RmllbGRzRnJvbVZhbHVlc1trZXldKSkge1xuICAgICAgICAgICAgICAgIGRpcnR5RmllbGRzRnJvbVZhbHVlc1trZXldID0gbWFya0ZpZWxkc0RpcnR5KHZhbHVlLCBBcnJheS5pc0FycmF5KHZhbHVlKSA/IFtdIDoge30pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2V0RGlydHlGaWVsZHModmFsdWUsIGlzTnVsbE9yVW5kZWZpbmVkKGZvcm1WYWx1ZXMpID8ge30gOiBmb3JtVmFsdWVzW2tleV0sIGRpcnR5RmllbGRzRnJvbVZhbHVlc1trZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGZvcm1WYWx1ZSA9IGZvcm1WYWx1ZXNba2V5XTtcbiAgICAgICAgICAgIGRpcnR5RmllbGRzRnJvbVZhbHVlc1trZXldID0gIWRlZXBFcXVhbCh2YWx1ZSwgZm9ybVZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGlydHlGaWVsZHNGcm9tVmFsdWVzO1xufVxuXG5jb25zdCBkZWZhdWx0UmVzdWx0ID0ge1xuICAgIHZhbHVlOiBmYWxzZSxcbiAgICBpc1ZhbGlkOiBmYWxzZSxcbn07XG5jb25zdCB2YWxpZFJlc3VsdCA9IHsgdmFsdWU6IHRydWUsIGlzVmFsaWQ6IHRydWUgfTtcbnZhciBnZXRDaGVja2JveFZhbHVlID0gKG9wdGlvbnMpID0+IHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zKSkge1xuICAgICAgICBpZiAob3B0aW9ucy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBvcHRpb25zXG4gICAgICAgICAgICAgICAgLmZpbHRlcigob3B0aW9uKSA9PiBvcHRpb24gJiYgb3B0aW9uLmNoZWNrZWQgJiYgIW9wdGlvbi5kaXNhYmxlZClcbiAgICAgICAgICAgICAgICAubWFwKChvcHRpb24pID0+IG9wdGlvbi52YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdmFsdWVzLCBpc1ZhbGlkOiAhIXZhbHVlcy5sZW5ndGggfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3B0aW9uc1swXS5jaGVja2VkICYmICFvcHRpb25zWzBdLmRpc2FibGVkXG4gICAgICAgICAgICA/IC8vIEB0cy1leHBlY3QtZXJyb3IgZXhwZWN0ZWQgdG8gd29yayBpbiB0aGUgYnJvd3NlclxuICAgICAgICAgICAgICAgIG9wdGlvbnNbMF0uYXR0cmlidXRlcyAmJiAhaXNVbmRlZmluZWQob3B0aW9uc1swXS5hdHRyaWJ1dGVzLnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICA/IGlzVW5kZWZpbmVkKG9wdGlvbnNbMF0udmFsdWUpIHx8IG9wdGlvbnNbMF0udmFsdWUgPT09ICcnXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHZhbGlkUmVzdWx0XG4gICAgICAgICAgICAgICAgICAgICAgICA6IHsgdmFsdWU6IG9wdGlvbnNbMF0udmFsdWUsIGlzVmFsaWQ6IHRydWUgfVxuICAgICAgICAgICAgICAgICAgICA6IHZhbGlkUmVzdWx0XG4gICAgICAgICAgICA6IGRlZmF1bHRSZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0UmVzdWx0O1xufTtcblxudmFyIGdldEZpZWxkVmFsdWVBcyA9ICh2YWx1ZSwgeyB2YWx1ZUFzTnVtYmVyLCB2YWx1ZUFzRGF0ZSwgc2V0VmFsdWVBcyB9KSA9PiBpc1VuZGVmaW5lZCh2YWx1ZSlcbiAgICA/IHZhbHVlXG4gICAgOiB2YWx1ZUFzTnVtYmVyXG4gICAgICAgID8gdmFsdWUgPT09ICcnXG4gICAgICAgICAgICA/IE5hTlxuICAgICAgICAgICAgOiB2YWx1ZVxuICAgICAgICAgICAgICAgID8gK3ZhbHVlXG4gICAgICAgICAgICAgICAgOiB2YWx1ZVxuICAgICAgICA6IHZhbHVlQXNEYXRlICYmIGlzU3RyaW5nKHZhbHVlKVxuICAgICAgICAgICAgPyBuZXcgRGF0ZSh2YWx1ZSlcbiAgICAgICAgICAgIDogc2V0VmFsdWVBc1xuICAgICAgICAgICAgICAgID8gc2V0VmFsdWVBcyh2YWx1ZSlcbiAgICAgICAgICAgICAgICA6IHZhbHVlO1xuXG5jb25zdCBkZWZhdWx0UmV0dXJuID0ge1xuICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgIHZhbHVlOiBudWxsLFxufTtcbnZhciBnZXRSYWRpb1ZhbHVlID0gKG9wdGlvbnMpID0+IEFycmF5LmlzQXJyYXkob3B0aW9ucylcbiAgICA/IG9wdGlvbnMucmVkdWNlKChwcmV2aW91cywgb3B0aW9uKSA9PiBvcHRpb24gJiYgb3B0aW9uLmNoZWNrZWQgJiYgIW9wdGlvbi5kaXNhYmxlZFxuICAgICAgICA/IHtcbiAgICAgICAgICAgIGlzVmFsaWQ6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogb3B0aW9uLnZhbHVlLFxuICAgICAgICB9XG4gICAgICAgIDogcHJldmlvdXMsIGRlZmF1bHRSZXR1cm4pXG4gICAgOiBkZWZhdWx0UmV0dXJuO1xuXG5mdW5jdGlvbiBnZXRGaWVsZFZhbHVlKF9mKSB7XG4gICAgY29uc3QgcmVmID0gX2YucmVmO1xuICAgIGlmIChpc0ZpbGVJbnB1dChyZWYpKSB7XG4gICAgICAgIHJldHVybiByZWYuZmlsZXM7XG4gICAgfVxuICAgIGlmIChpc1JhZGlvSW5wdXQocmVmKSkge1xuICAgICAgICByZXR1cm4gZ2V0UmFkaW9WYWx1ZShfZi5yZWZzKS52YWx1ZTtcbiAgICB9XG4gICAgaWYgKGlzTXVsdGlwbGVTZWxlY3QocmVmKSkge1xuICAgICAgICByZXR1cm4gWy4uLnJlZi5zZWxlY3RlZE9wdGlvbnNdLm1hcCgoeyB2YWx1ZSB9KSA9PiB2YWx1ZSk7XG4gICAgfVxuICAgIGlmIChpc0NoZWNrQm94SW5wdXQocmVmKSkge1xuICAgICAgICByZXR1cm4gZ2V0Q2hlY2tib3hWYWx1ZShfZi5yZWZzKS52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGdldEZpZWxkVmFsdWVBcyhpc1VuZGVmaW5lZChyZWYudmFsdWUpID8gX2YucmVmLnZhbHVlIDogcmVmLnZhbHVlLCBfZik7XG59XG5cbnZhciBnZXRSZXNvbHZlck9wdGlvbnMgPSAoZmllbGRzTmFtZXMsIF9maWVsZHMsIGNyaXRlcmlhTW9kZSwgc2hvdWxkVXNlTmF0aXZlVmFsaWRhdGlvbikgPT4ge1xuICAgIGNvbnN0IGZpZWxkcyA9IHt9O1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBmaWVsZHNOYW1lcykge1xuICAgICAgICBjb25zdCBmaWVsZCA9IGdldChfZmllbGRzLCBuYW1lKTtcbiAgICAgICAgZmllbGQgJiYgc2V0KGZpZWxkcywgbmFtZSwgZmllbGQuX2YpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBjcml0ZXJpYU1vZGUsXG4gICAgICAgIG5hbWVzOiBbLi4uZmllbGRzTmFtZXNdLFxuICAgICAgICBmaWVsZHMsXG4gICAgICAgIHNob3VsZFVzZU5hdGl2ZVZhbGlkYXRpb24sXG4gICAgfTtcbn07XG5cbnZhciBpc1JlZ2V4ID0gKHZhbHVlKSA9PiB2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cDtcblxudmFyIGdldFJ1bGVWYWx1ZSA9IChydWxlKSA9PiBpc1VuZGVmaW5lZChydWxlKVxuICAgID8gcnVsZVxuICAgIDogaXNSZWdleChydWxlKVxuICAgICAgICA/IHJ1bGUuc291cmNlXG4gICAgICAgIDogaXNPYmplY3QocnVsZSlcbiAgICAgICAgICAgID8gaXNSZWdleChydWxlLnZhbHVlKVxuICAgICAgICAgICAgICAgID8gcnVsZS52YWx1ZS5zb3VyY2VcbiAgICAgICAgICAgICAgICA6IHJ1bGUudmFsdWVcbiAgICAgICAgICAgIDogcnVsZTtcblxudmFyIGdldFZhbGlkYXRpb25Nb2RlcyA9IChtb2RlKSA9PiAoe1xuICAgIGlzT25TdWJtaXQ6ICFtb2RlIHx8IG1vZGUgPT09IFZBTElEQVRJT05fTU9ERS5vblN1Ym1pdCxcbiAgICBpc09uQmx1cjogbW9kZSA9PT0gVkFMSURBVElPTl9NT0RFLm9uQmx1cixcbiAgICBpc09uQ2hhbmdlOiBtb2RlID09PSBWQUxJREFUSU9OX01PREUub25DaGFuZ2UsXG4gICAgaXNPbkFsbDogbW9kZSA9PT0gVkFMSURBVElPTl9NT0RFLmFsbCxcbiAgICBpc09uVG91Y2g6IG1vZGUgPT09IFZBTElEQVRJT05fTU9ERS5vblRvdWNoZWQsXG59KTtcblxuY29uc3QgQVNZTkNfRlVOQ1RJT04gPSAnQXN5bmNGdW5jdGlvbic7XG52YXIgaGFzUHJvbWlzZVZhbGlkYXRpb24gPSAoZmllbGRSZWZlcmVuY2UpID0+ICEhZmllbGRSZWZlcmVuY2UgJiZcbiAgICAhIWZpZWxkUmVmZXJlbmNlLnZhbGlkYXRlICYmXG4gICAgISEoKGlzRnVuY3Rpb24oZmllbGRSZWZlcmVuY2UudmFsaWRhdGUpICYmXG4gICAgICAgIGZpZWxkUmVmZXJlbmNlLnZhbGlkYXRlLmNvbnN0cnVjdG9yLm5hbWUgPT09IEFTWU5DX0ZVTkNUSU9OKSB8fFxuICAgICAgICAoaXNPYmplY3QoZmllbGRSZWZlcmVuY2UudmFsaWRhdGUpICYmXG4gICAgICAgICAgICBPYmplY3QudmFsdWVzKGZpZWxkUmVmZXJlbmNlLnZhbGlkYXRlKS5maW5kKCh2YWxpZGF0ZUZ1bmN0aW9uKSA9PiB2YWxpZGF0ZUZ1bmN0aW9uLmNvbnN0cnVjdG9yLm5hbWUgPT09IEFTWU5DX0ZVTkNUSU9OKSkpO1xuXG52YXIgaGFzVmFsaWRhdGlvbiA9IChvcHRpb25zKSA9PiBvcHRpb25zLm1vdW50ICYmXG4gICAgKG9wdGlvbnMucmVxdWlyZWQgfHxcbiAgICAgICAgb3B0aW9ucy5taW4gfHxcbiAgICAgICAgb3B0aW9ucy5tYXggfHxcbiAgICAgICAgb3B0aW9ucy5tYXhMZW5ndGggfHxcbiAgICAgICAgb3B0aW9ucy5taW5MZW5ndGggfHxcbiAgICAgICAgb3B0aW9ucy5wYXR0ZXJuIHx8XG4gICAgICAgIG9wdGlvbnMudmFsaWRhdGUpO1xuXG52YXIgaXNXYXRjaGVkID0gKG5hbWUsIF9uYW1lcywgaXNCbHVyRXZlbnQpID0+ICFpc0JsdXJFdmVudCAmJlxuICAgIChfbmFtZXMud2F0Y2hBbGwgfHxcbiAgICAgICAgX25hbWVzLndhdGNoLmhhcyhuYW1lKSB8fFxuICAgICAgICBbLi4uX25hbWVzLndhdGNoXS5zb21lKCh3YXRjaE5hbWUpID0+IG5hbWUuc3RhcnRzV2l0aCh3YXRjaE5hbWUpICYmXG4gICAgICAgICAgICAvXlxcLlxcdysvLnRlc3QobmFtZS5zbGljZSh3YXRjaE5hbWUubGVuZ3RoKSkpKTtcblxuY29uc3QgaXRlcmF0ZUZpZWxkc0J5QWN0aW9uID0gKGZpZWxkcywgYWN0aW9uLCBmaWVsZHNOYW1lcywgYWJvcnRFYXJseSkgPT4ge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGZpZWxkc05hbWVzIHx8IE9iamVjdC5rZXlzKGZpZWxkcykpIHtcbiAgICAgICAgY29uc3QgZmllbGQgPSBnZXQoZmllbGRzLCBrZXkpO1xuICAgICAgICBpZiAoZmllbGQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgX2YsIC4uLmN1cnJlbnRGaWVsZCB9ID0gZmllbGQ7XG4gICAgICAgICAgICBpZiAoX2YpIHtcbiAgICAgICAgICAgICAgICBpZiAoX2YucmVmcyAmJiBfZi5yZWZzWzBdICYmIGFjdGlvbihfZi5yZWZzWzBdLCBrZXkpICYmICFhYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChfZi5yZWYgJiYgYWN0aW9uKF9mLnJlZiwgX2YubmFtZSkgJiYgIWFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlcmF0ZUZpZWxkc0J5QWN0aW9uKGN1cnJlbnRGaWVsZCwgYWN0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc09iamVjdChjdXJyZW50RmllbGQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZXJhdGVGaWVsZHNCeUFjdGlvbihjdXJyZW50RmllbGQsIGFjdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybjtcbn07XG5cbmZ1bmN0aW9uIHNjaGVtYUVycm9yTG9va3VwKGVycm9ycywgX2ZpZWxkcywgbmFtZSkge1xuICAgIGNvbnN0IGVycm9yID0gZ2V0KGVycm9ycywgbmFtZSk7XG4gICAgaWYgKGVycm9yIHx8IGlzS2V5KG5hbWUpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IG5hbWVzID0gbmFtZS5zcGxpdCgnLicpO1xuICAgIHdoaWxlIChuYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgZmllbGROYW1lID0gbmFtZXMuam9pbignLicpO1xuICAgICAgICBjb25zdCBmaWVsZCA9IGdldChfZmllbGRzLCBmaWVsZE5hbWUpO1xuICAgICAgICBjb25zdCBmb3VuZEVycm9yID0gZ2V0KGVycm9ycywgZmllbGROYW1lKTtcbiAgICAgICAgaWYgKGZpZWxkICYmICFBcnJheS5pc0FycmF5KGZpZWxkKSAmJiBuYW1lICE9PSBmaWVsZE5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG5hbWUgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm91bmRFcnJvciAmJiBmb3VuZEVycm9yLnR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbmFtZTogZmllbGROYW1lLFxuICAgICAgICAgICAgICAgIGVycm9yOiBmb3VuZEVycm9yLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm91bmRFcnJvciAmJiBmb3VuZEVycm9yLnJvb3QgJiYgZm91bmRFcnJvci5yb290LnR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbmFtZTogYCR7ZmllbGROYW1lfS5yb290YCxcbiAgICAgICAgICAgICAgICBlcnJvcjogZm91bmRFcnJvci5yb290LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBuYW1lcy5wb3AoKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZSxcbiAgICB9O1xufVxuXG52YXIgc2hvdWxkUmVuZGVyRm9ybVN0YXRlID0gKGZvcm1TdGF0ZURhdGEsIF9wcm94eUZvcm1TdGF0ZSwgdXBkYXRlRm9ybVN0YXRlLCBpc1Jvb3QpID0+IHtcbiAgICB1cGRhdGVGb3JtU3RhdGUoZm9ybVN0YXRlRGF0YSk7XG4gICAgY29uc3QgeyBuYW1lLCAuLi5mb3JtU3RhdGUgfSA9IGZvcm1TdGF0ZURhdGE7XG4gICAgcmV0dXJuIChpc0VtcHR5T2JqZWN0KGZvcm1TdGF0ZSkgfHxcbiAgICAgICAgT2JqZWN0LmtleXMoZm9ybVN0YXRlKS5sZW5ndGggPj0gT2JqZWN0LmtleXMoX3Byb3h5Rm9ybVN0YXRlKS5sZW5ndGggfHxcbiAgICAgICAgT2JqZWN0LmtleXMoZm9ybVN0YXRlKS5maW5kKChrZXkpID0+IF9wcm94eUZvcm1TdGF0ZVtrZXldID09PVxuICAgICAgICAgICAgKCFpc1Jvb3QgfHwgVkFMSURBVElPTl9NT0RFLmFsbCkpKTtcbn07XG5cbnZhciBzaG91bGRTdWJzY3JpYmVCeU5hbWUgPSAobmFtZSwgc2lnbmFsTmFtZSwgZXhhY3QpID0+ICFuYW1lIHx8XG4gICAgIXNpZ25hbE5hbWUgfHxcbiAgICBuYW1lID09PSBzaWduYWxOYW1lIHx8XG4gICAgY29udmVydFRvQXJyYXlQYXlsb2FkKG5hbWUpLnNvbWUoKGN1cnJlbnROYW1lKSA9PiBjdXJyZW50TmFtZSAmJlxuICAgICAgICAoZXhhY3RcbiAgICAgICAgICAgID8gY3VycmVudE5hbWUgPT09IHNpZ25hbE5hbWVcbiAgICAgICAgICAgIDogY3VycmVudE5hbWUuc3RhcnRzV2l0aChzaWduYWxOYW1lKSB8fFxuICAgICAgICAgICAgICAgIHNpZ25hbE5hbWUuc3RhcnRzV2l0aChjdXJyZW50TmFtZSkpKTtcblxudmFyIHNraXBWYWxpZGF0aW9uID0gKGlzQmx1ckV2ZW50LCBpc1RvdWNoZWQsIGlzU3VibWl0dGVkLCByZVZhbGlkYXRlTW9kZSwgbW9kZSkgPT4ge1xuICAgIGlmIChtb2RlLmlzT25BbGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBlbHNlIGlmICghaXNTdWJtaXR0ZWQgJiYgbW9kZS5pc09uVG91Y2gpIHtcbiAgICAgICAgcmV0dXJuICEoaXNUb3VjaGVkIHx8IGlzQmx1ckV2ZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNTdWJtaXR0ZWQgPyByZVZhbGlkYXRlTW9kZS5pc09uQmx1ciA6IG1vZGUuaXNPbkJsdXIpIHtcbiAgICAgICAgcmV0dXJuICFpc0JsdXJFdmVudDtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNTdWJtaXR0ZWQgPyByZVZhbGlkYXRlTW9kZS5pc09uQ2hhbmdlIDogbW9kZS5pc09uQ2hhbmdlKSB7XG4gICAgICAgIHJldHVybiBpc0JsdXJFdmVudDtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgdW5zZXRFbXB0eUFycmF5ID0gKHJlZiwgbmFtZSkgPT4gIWNvbXBhY3QoZ2V0KHJlZiwgbmFtZSkpLmxlbmd0aCAmJiB1bnNldChyZWYsIG5hbWUpO1xuXG52YXIgdXBkYXRlRmllbGRBcnJheVJvb3RFcnJvciA9IChlcnJvcnMsIGVycm9yLCBuYW1lKSA9PiB7XG4gICAgY29uc3QgZmllbGRBcnJheUVycm9ycyA9IGNvbnZlcnRUb0FycmF5UGF5bG9hZChnZXQoZXJyb3JzLCBuYW1lKSk7XG4gICAgc2V0KGZpZWxkQXJyYXlFcnJvcnMsICdyb290JywgZXJyb3JbbmFtZV0pO1xuICAgIHNldChlcnJvcnMsIG5hbWUsIGZpZWxkQXJyYXlFcnJvcnMpO1xuICAgIHJldHVybiBlcnJvcnM7XG59O1xuXG5mdW5jdGlvbiBnZXRWYWxpZGF0ZUVycm9yKHJlc3VsdCwgcmVmLCB0eXBlID0gJ3ZhbGlkYXRlJykge1xuICAgIGlmIChpc1N0cmluZyhyZXN1bHQpIHx8XG4gICAgICAgIChBcnJheS5pc0FycmF5KHJlc3VsdCkgJiYgcmVzdWx0LmV2ZXJ5KGlzU3RyaW5nKSkgfHxcbiAgICAgICAgKGlzQm9vbGVhbihyZXN1bHQpICYmICFyZXN1bHQpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgbWVzc2FnZTogaXNTdHJpbmcocmVzdWx0KSA/IHJlc3VsdCA6ICcnLFxuICAgICAgICAgICAgcmVmLFxuICAgICAgICB9O1xuICAgIH1cbn1cblxudmFyIGdldFZhbHVlQW5kTWVzc2FnZSA9ICh2YWxpZGF0aW9uRGF0YSkgPT4gaXNPYmplY3QodmFsaWRhdGlvbkRhdGEpICYmICFpc1JlZ2V4KHZhbGlkYXRpb25EYXRhKVxuICAgID8gdmFsaWRhdGlvbkRhdGFcbiAgICA6IHtcbiAgICAgICAgdmFsdWU6IHZhbGlkYXRpb25EYXRhLFxuICAgICAgICBtZXNzYWdlOiAnJyxcbiAgICB9O1xuXG52YXIgdmFsaWRhdGVGaWVsZCA9IGFzeW5jIChmaWVsZCwgZGlzYWJsZWRGaWVsZE5hbWVzLCBmb3JtVmFsdWVzLCB2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEsIHNob3VsZFVzZU5hdGl2ZVZhbGlkYXRpb24sIGlzRmllbGRBcnJheSkgPT4ge1xuICAgIGNvbnN0IHsgcmVmLCByZWZzLCByZXF1aXJlZCwgbWF4TGVuZ3RoLCBtaW5MZW5ndGgsIG1pbiwgbWF4LCBwYXR0ZXJuLCB2YWxpZGF0ZSwgbmFtZSwgdmFsdWVBc051bWJlciwgbW91bnQsIH0gPSBmaWVsZC5fZjtcbiAgICBjb25zdCBpbnB1dFZhbHVlID0gZ2V0KGZvcm1WYWx1ZXMsIG5hbWUpO1xuICAgIGlmICghbW91bnQgfHwgZGlzYWJsZWRGaWVsZE5hbWVzLmhhcyhuYW1lKSkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGNvbnN0IGlucHV0UmVmID0gcmVmcyA/IHJlZnNbMF0gOiByZWY7XG4gICAgY29uc3Qgc2V0Q3VzdG9tVmFsaWRpdHkgPSAobWVzc2FnZSkgPT4ge1xuICAgICAgICBpZiAoc2hvdWxkVXNlTmF0aXZlVmFsaWRhdGlvbiAmJiBpbnB1dFJlZi5yZXBvcnRWYWxpZGl0eSkge1xuICAgICAgICAgICAgaW5wdXRSZWYuc2V0Q3VzdG9tVmFsaWRpdHkoaXNCb29sZWFuKG1lc3NhZ2UpID8gJycgOiBtZXNzYWdlIHx8ICcnKTtcbiAgICAgICAgICAgIGlucHV0UmVmLnJlcG9ydFZhbGlkaXR5KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGVycm9yID0ge307XG4gICAgY29uc3QgaXNSYWRpbyA9IGlzUmFkaW9JbnB1dChyZWYpO1xuICAgIGNvbnN0IGlzQ2hlY2tCb3ggPSBpc0NoZWNrQm94SW5wdXQocmVmKTtcbiAgICBjb25zdCBpc1JhZGlvT3JDaGVja2JveCA9IGlzUmFkaW8gfHwgaXNDaGVja0JveDtcbiAgICBjb25zdCBpc0VtcHR5ID0gKCh2YWx1ZUFzTnVtYmVyIHx8IGlzRmlsZUlucHV0KHJlZikpICYmXG4gICAgICAgIGlzVW5kZWZpbmVkKHJlZi52YWx1ZSkgJiZcbiAgICAgICAgaXNVbmRlZmluZWQoaW5wdXRWYWx1ZSkpIHx8XG4gICAgICAgIChpc0hUTUxFbGVtZW50KHJlZikgJiYgcmVmLnZhbHVlID09PSAnJykgfHxcbiAgICAgICAgaW5wdXRWYWx1ZSA9PT0gJycgfHxcbiAgICAgICAgKEFycmF5LmlzQXJyYXkoaW5wdXRWYWx1ZSkgJiYgIWlucHV0VmFsdWUubGVuZ3RoKTtcbiAgICBjb25zdCBhcHBlbmRFcnJvcnNDdXJyeSA9IGFwcGVuZEVycm9ycy5iaW5kKG51bGwsIG5hbWUsIHZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSwgZXJyb3IpO1xuICAgIGNvbnN0IGdldE1pbk1heE1lc3NhZ2UgPSAoZXhjZWVkTWF4LCBtYXhMZW5ndGhNZXNzYWdlLCBtaW5MZW5ndGhNZXNzYWdlLCBtYXhUeXBlID0gSU5QVVRfVkFMSURBVElPTl9SVUxFUy5tYXhMZW5ndGgsIG1pblR5cGUgPSBJTlBVVF9WQUxJREFUSU9OX1JVTEVTLm1pbkxlbmd0aCkgPT4ge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZXhjZWVkTWF4ID8gbWF4TGVuZ3RoTWVzc2FnZSA6IG1pbkxlbmd0aE1lc3NhZ2U7XG4gICAgICAgIGVycm9yW25hbWVdID0ge1xuICAgICAgICAgICAgdHlwZTogZXhjZWVkTWF4ID8gbWF4VHlwZSA6IG1pblR5cGUsXG4gICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgcmVmLFxuICAgICAgICAgICAgLi4uYXBwZW5kRXJyb3JzQ3VycnkoZXhjZWVkTWF4ID8gbWF4VHlwZSA6IG1pblR5cGUsIG1lc3NhZ2UpLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgaWYgKGlzRmllbGRBcnJheVxuICAgICAgICA/ICFBcnJheS5pc0FycmF5KGlucHV0VmFsdWUpIHx8ICFpbnB1dFZhbHVlLmxlbmd0aFxuICAgICAgICA6IHJlcXVpcmVkICYmXG4gICAgICAgICAgICAoKCFpc1JhZGlvT3JDaGVja2JveCAmJiAoaXNFbXB0eSB8fCBpc051bGxPclVuZGVmaW5lZChpbnB1dFZhbHVlKSkpIHx8XG4gICAgICAgICAgICAgICAgKGlzQm9vbGVhbihpbnB1dFZhbHVlKSAmJiAhaW5wdXRWYWx1ZSkgfHxcbiAgICAgICAgICAgICAgICAoaXNDaGVja0JveCAmJiAhZ2V0Q2hlY2tib3hWYWx1ZShyZWZzKS5pc1ZhbGlkKSB8fFxuICAgICAgICAgICAgICAgIChpc1JhZGlvICYmICFnZXRSYWRpb1ZhbHVlKHJlZnMpLmlzVmFsaWQpKSkge1xuICAgICAgICBjb25zdCB7IHZhbHVlLCBtZXNzYWdlIH0gPSBpc1N0cmluZyhyZXF1aXJlZClcbiAgICAgICAgICAgID8geyB2YWx1ZTogISFyZXF1aXJlZCwgbWVzc2FnZTogcmVxdWlyZWQgfVxuICAgICAgICAgICAgOiBnZXRWYWx1ZUFuZE1lc3NhZ2UocmVxdWlyZWQpO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGVycm9yW25hbWVdID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IElOUFVUX1ZBTElEQVRJT05fUlVMRVMucmVxdWlyZWQsXG4gICAgICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgICAgICByZWY6IGlucHV0UmVmLFxuICAgICAgICAgICAgICAgIC4uLmFwcGVuZEVycm9yc0N1cnJ5KElOUFVUX1ZBTElEQVRJT05fUlVMRVMucmVxdWlyZWQsIG1lc3NhZ2UpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICghdmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhKSB7XG4gICAgICAgICAgICAgICAgc2V0Q3VzdG9tVmFsaWRpdHkobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghaXNFbXB0eSAmJiAoIWlzTnVsbE9yVW5kZWZpbmVkKG1pbikgfHwgIWlzTnVsbE9yVW5kZWZpbmVkKG1heCkpKSB7XG4gICAgICAgIGxldCBleGNlZWRNYXg7XG4gICAgICAgIGxldCBleGNlZWRNaW47XG4gICAgICAgIGNvbnN0IG1heE91dHB1dCA9IGdldFZhbHVlQW5kTWVzc2FnZShtYXgpO1xuICAgICAgICBjb25zdCBtaW5PdXRwdXQgPSBnZXRWYWx1ZUFuZE1lc3NhZ2UobWluKTtcbiAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChpbnB1dFZhbHVlKSAmJiAhaXNOYU4oaW5wdXRWYWx1ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlTnVtYmVyID0gcmVmLnZhbHVlQXNOdW1iZXIgfHxcbiAgICAgICAgICAgICAgICAoaW5wdXRWYWx1ZSA/ICtpbnB1dFZhbHVlIDogaW5wdXRWYWx1ZSk7XG4gICAgICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKG1heE91dHB1dC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBleGNlZWRNYXggPSB2YWx1ZU51bWJlciA+IG1heE91dHB1dC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQobWluT3V0cHV0LnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGV4Y2VlZE1pbiA9IHZhbHVlTnVtYmVyIDwgbWluT3V0cHV0LnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdmFsdWVEYXRlID0gcmVmLnZhbHVlQXNEYXRlIHx8IG5ldyBEYXRlKGlucHV0VmFsdWUpO1xuICAgICAgICAgICAgY29uc3QgY29udmVydFRpbWVUb0RhdGUgPSAodGltZSkgPT4gbmV3IERhdGUobmV3IERhdGUoKS50b0RhdGVTdHJpbmcoKSArICcgJyArIHRpbWUpO1xuICAgICAgICAgICAgY29uc3QgaXNUaW1lID0gcmVmLnR5cGUgPT0gJ3RpbWUnO1xuICAgICAgICAgICAgY29uc3QgaXNXZWVrID0gcmVmLnR5cGUgPT0gJ3dlZWsnO1xuICAgICAgICAgICAgaWYgKGlzU3RyaW5nKG1heE91dHB1dC52YWx1ZSkgJiYgaW5wdXRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGV4Y2VlZE1heCA9IGlzVGltZVxuICAgICAgICAgICAgICAgICAgICA/IGNvbnZlcnRUaW1lVG9EYXRlKGlucHV0VmFsdWUpID4gY29udmVydFRpbWVUb0RhdGUobWF4T3V0cHV0LnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICA6IGlzV2Vla1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBpbnB1dFZhbHVlID4gbWF4T3V0cHV0LnZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHZhbHVlRGF0ZSA+IG5ldyBEYXRlKG1heE91dHB1dC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpbmcobWluT3V0cHV0LnZhbHVlKSAmJiBpbnB1dFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZXhjZWVkTWluID0gaXNUaW1lXG4gICAgICAgICAgICAgICAgICAgID8gY29udmVydFRpbWVUb0RhdGUoaW5wdXRWYWx1ZSkgPCBjb252ZXJ0VGltZVRvRGF0ZShtaW5PdXRwdXQudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIDogaXNXZWVrXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGlucHV0VmFsdWUgPCBtaW5PdXRwdXQudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdmFsdWVEYXRlIDwgbmV3IERhdGUobWluT3V0cHV0LnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhjZWVkTWF4IHx8IGV4Y2VlZE1pbikge1xuICAgICAgICAgICAgZ2V0TWluTWF4TWVzc2FnZSghIWV4Y2VlZE1heCwgbWF4T3V0cHV0Lm1lc3NhZ2UsIG1pbk91dHB1dC5tZXNzYWdlLCBJTlBVVF9WQUxJREFUSU9OX1JVTEVTLm1heCwgSU5QVVRfVkFMSURBVElPTl9SVUxFUy5taW4pO1xuICAgICAgICAgICAgaWYgKCF2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEpIHtcbiAgICAgICAgICAgICAgICBzZXRDdXN0b21WYWxpZGl0eShlcnJvcltuYW1lXS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKChtYXhMZW5ndGggfHwgbWluTGVuZ3RoKSAmJlxuICAgICAgICAhaXNFbXB0eSAmJlxuICAgICAgICAoaXNTdHJpbmcoaW5wdXRWYWx1ZSkgfHwgKGlzRmllbGRBcnJheSAmJiBBcnJheS5pc0FycmF5KGlucHV0VmFsdWUpKSkpIHtcbiAgICAgICAgY29uc3QgbWF4TGVuZ3RoT3V0cHV0ID0gZ2V0VmFsdWVBbmRNZXNzYWdlKG1heExlbmd0aCk7XG4gICAgICAgIGNvbnN0IG1pbkxlbmd0aE91dHB1dCA9IGdldFZhbHVlQW5kTWVzc2FnZShtaW5MZW5ndGgpO1xuICAgICAgICBjb25zdCBleGNlZWRNYXggPSAhaXNOdWxsT3JVbmRlZmluZWQobWF4TGVuZ3RoT3V0cHV0LnZhbHVlKSAmJlxuICAgICAgICAgICAgaW5wdXRWYWx1ZS5sZW5ndGggPiArbWF4TGVuZ3RoT3V0cHV0LnZhbHVlO1xuICAgICAgICBjb25zdCBleGNlZWRNaW4gPSAhaXNOdWxsT3JVbmRlZmluZWQobWluTGVuZ3RoT3V0cHV0LnZhbHVlKSAmJlxuICAgICAgICAgICAgaW5wdXRWYWx1ZS5sZW5ndGggPCArbWluTGVuZ3RoT3V0cHV0LnZhbHVlO1xuICAgICAgICBpZiAoZXhjZWVkTWF4IHx8IGV4Y2VlZE1pbikge1xuICAgICAgICAgICAgZ2V0TWluTWF4TWVzc2FnZShleGNlZWRNYXgsIG1heExlbmd0aE91dHB1dC5tZXNzYWdlLCBtaW5MZW5ndGhPdXRwdXQubWVzc2FnZSk7XG4gICAgICAgICAgICBpZiAoIXZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSkge1xuICAgICAgICAgICAgICAgIHNldEN1c3RvbVZhbGlkaXR5KGVycm9yW25hbWVdLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocGF0dGVybiAmJiAhaXNFbXB0eSAmJiBpc1N0cmluZyhpbnB1dFZhbHVlKSkge1xuICAgICAgICBjb25zdCB7IHZhbHVlOiBwYXR0ZXJuVmFsdWUsIG1lc3NhZ2UgfSA9IGdldFZhbHVlQW5kTWVzc2FnZShwYXR0ZXJuKTtcbiAgICAgICAgaWYgKGlzUmVnZXgocGF0dGVyblZhbHVlKSAmJiAhaW5wdXRWYWx1ZS5tYXRjaChwYXR0ZXJuVmFsdWUpKSB7XG4gICAgICAgICAgICBlcnJvcltuYW1lXSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBJTlBVVF9WQUxJREFUSU9OX1JVTEVTLnBhdHRlcm4sXG4gICAgICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgICAgICByZWYsXG4gICAgICAgICAgICAgICAgLi4uYXBwZW5kRXJyb3JzQ3VycnkoSU5QVVRfVkFMSURBVElPTl9SVUxFUy5wYXR0ZXJuLCBtZXNzYWdlKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoIXZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSkge1xuICAgICAgICAgICAgICAgIHNldEN1c3RvbVZhbGlkaXR5KG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodmFsaWRhdGUpIHtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odmFsaWRhdGUpKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB2YWxpZGF0ZShpbnB1dFZhbHVlLCBmb3JtVmFsdWVzKTtcbiAgICAgICAgICAgIGNvbnN0IHZhbGlkYXRlRXJyb3IgPSBnZXRWYWxpZGF0ZUVycm9yKHJlc3VsdCwgaW5wdXRSZWYpO1xuICAgICAgICAgICAgaWYgKHZhbGlkYXRlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlcnJvcltuYW1lXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgLi4udmFsaWRhdGVFcnJvcixcbiAgICAgICAgICAgICAgICAgICAgLi4uYXBwZW5kRXJyb3JzQ3VycnkoSU5QVVRfVkFMSURBVElPTl9SVUxFUy52YWxpZGF0ZSwgdmFsaWRhdGVFcnJvci5tZXNzYWdlKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmICghdmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldEN1c3RvbVZhbGlkaXR5KHZhbGlkYXRlRXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNPYmplY3QodmFsaWRhdGUpKSB7XG4gICAgICAgICAgICBsZXQgdmFsaWRhdGlvblJlc3VsdCA9IHt9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdmFsaWRhdGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzRW1wdHlPYmplY3QodmFsaWRhdGlvblJlc3VsdCkgJiYgIXZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsaWRhdGVFcnJvciA9IGdldFZhbGlkYXRlRXJyb3IoYXdhaXQgdmFsaWRhdGVba2V5XShpbnB1dFZhbHVlLCBmb3JtVmFsdWVzKSwgaW5wdXRSZWYsIGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbGlkYXRlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnZhbGlkYXRlRXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5hcHBlbmRFcnJvcnNDdXJyeShrZXksIHZhbGlkYXRlRXJyb3IubWVzc2FnZSksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHNldEN1c3RvbVZhbGlkaXR5KHZhbGlkYXRlRXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yW25hbWVdID0gdmFsaWRhdGlvblJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNFbXB0eU9iamVjdCh2YWxpZGF0aW9uUmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIGVycm9yW25hbWVdID0ge1xuICAgICAgICAgICAgICAgICAgICByZWY6IGlucHV0UmVmLFxuICAgICAgICAgICAgICAgICAgICAuLi52YWxpZGF0aW9uUmVzdWx0LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKCF2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRDdXN0b21WYWxpZGl0eSh0cnVlKTtcbiAgICByZXR1cm4gZXJyb3I7XG59O1xuXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBtb2RlOiBWQUxJREFUSU9OX01PREUub25TdWJtaXQsXG4gICAgcmVWYWxpZGF0ZU1vZGU6IFZBTElEQVRJT05fTU9ERS5vbkNoYW5nZSxcbiAgICBzaG91bGRGb2N1c0Vycm9yOiB0cnVlLFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUZvcm1Db250cm9sKHByb3BzID0ge30pIHtcbiAgICBsZXQgX29wdGlvbnMgPSB7XG4gICAgICAgIC4uLmRlZmF1bHRPcHRpb25zLFxuICAgICAgICAuLi5wcm9wcyxcbiAgICB9O1xuICAgIGxldCBfZm9ybVN0YXRlID0ge1xuICAgICAgICBzdWJtaXRDb3VudDogMCxcbiAgICAgICAgaXNEaXJ0eTogZmFsc2UsXG4gICAgICAgIGlzUmVhZHk6IGZhbHNlLFxuICAgICAgICBpc0xvYWRpbmc6IGlzRnVuY3Rpb24oX29wdGlvbnMuZGVmYXVsdFZhbHVlcyksXG4gICAgICAgIGlzVmFsaWRhdGluZzogZmFsc2UsXG4gICAgICAgIGlzU3VibWl0dGVkOiBmYWxzZSxcbiAgICAgICAgaXNTdWJtaXR0aW5nOiBmYWxzZSxcbiAgICAgICAgaXNTdWJtaXRTdWNjZXNzZnVsOiBmYWxzZSxcbiAgICAgICAgaXNWYWxpZDogZmFsc2UsXG4gICAgICAgIHRvdWNoZWRGaWVsZHM6IHt9LFxuICAgICAgICBkaXJ0eUZpZWxkczoge30sXG4gICAgICAgIHZhbGlkYXRpbmdGaWVsZHM6IHt9LFxuICAgICAgICBlcnJvcnM6IF9vcHRpb25zLmVycm9ycyB8fCB7fSxcbiAgICAgICAgZGlzYWJsZWQ6IF9vcHRpb25zLmRpc2FibGVkIHx8IGZhbHNlLFxuICAgIH07XG4gICAgbGV0IF9maWVsZHMgPSB7fTtcbiAgICBsZXQgX2RlZmF1bHRWYWx1ZXMgPSBpc09iamVjdChfb3B0aW9ucy5kZWZhdWx0VmFsdWVzKSB8fCBpc09iamVjdChfb3B0aW9ucy52YWx1ZXMpXG4gICAgICAgID8gY2xvbmVPYmplY3QoX29wdGlvbnMuZGVmYXVsdFZhbHVlcyB8fCBfb3B0aW9ucy52YWx1ZXMpIHx8IHt9XG4gICAgICAgIDoge307XG4gICAgbGV0IF9mb3JtVmFsdWVzID0gX29wdGlvbnMuc2hvdWxkVW5yZWdpc3RlclxuICAgICAgICA/IHt9XG4gICAgICAgIDogY2xvbmVPYmplY3QoX2RlZmF1bHRWYWx1ZXMpO1xuICAgIGxldCBfc3RhdGUgPSB7XG4gICAgICAgIGFjdGlvbjogZmFsc2UsXG4gICAgICAgIG1vdW50OiBmYWxzZSxcbiAgICAgICAgd2F0Y2g6IGZhbHNlLFxuICAgIH07XG4gICAgbGV0IF9uYW1lcyA9IHtcbiAgICAgICAgbW91bnQ6IG5ldyBTZXQoKSxcbiAgICAgICAgZGlzYWJsZWQ6IG5ldyBTZXQoKSxcbiAgICAgICAgdW5Nb3VudDogbmV3IFNldCgpLFxuICAgICAgICBhcnJheTogbmV3IFNldCgpLFxuICAgICAgICB3YXRjaDogbmV3IFNldCgpLFxuICAgIH07XG4gICAgbGV0IGRlbGF5RXJyb3JDYWxsYmFjaztcbiAgICBsZXQgdGltZXIgPSAwO1xuICAgIGNvbnN0IF9wcm94eUZvcm1TdGF0ZSA9IHtcbiAgICAgICAgaXNEaXJ0eTogZmFsc2UsXG4gICAgICAgIGRpcnR5RmllbGRzOiBmYWxzZSxcbiAgICAgICAgdmFsaWRhdGluZ0ZpZWxkczogZmFsc2UsXG4gICAgICAgIHRvdWNoZWRGaWVsZHM6IGZhbHNlLFxuICAgICAgICBpc1ZhbGlkYXRpbmc6IGZhbHNlLFxuICAgICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgICAgZXJyb3JzOiBmYWxzZSxcbiAgICB9O1xuICAgIGxldCBfcHJveHlTdWJzY3JpYmVGb3JtU3RhdGUgPSB7XG4gICAgICAgIC4uLl9wcm94eUZvcm1TdGF0ZSxcbiAgICB9O1xuICAgIGNvbnN0IF9zdWJqZWN0cyA9IHtcbiAgICAgICAgYXJyYXk6IGNyZWF0ZVN1YmplY3QoKSxcbiAgICAgICAgc3RhdGU6IGNyZWF0ZVN1YmplY3QoKSxcbiAgICB9O1xuICAgIGNvbnN0IHNob3VsZERpc3BsYXlBbGxBc3NvY2lhdGVkRXJyb3JzID0gX29wdGlvbnMuY3JpdGVyaWFNb2RlID09PSBWQUxJREFUSU9OX01PREUuYWxsO1xuICAgIGNvbnN0IGRlYm91bmNlID0gKGNhbGxiYWNrKSA9PiAod2FpdCkgPT4ge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoY2FsbGJhY2ssIHdhaXQpO1xuICAgIH07XG4gICAgY29uc3QgX3NldFZhbGlkID0gYXN5bmMgKHNob3VsZFVwZGF0ZVZhbGlkKSA9PiB7XG4gICAgICAgIGlmICghX29wdGlvbnMuZGlzYWJsZWQgJiZcbiAgICAgICAgICAgIChfcHJveHlGb3JtU3RhdGUuaXNWYWxpZCB8fFxuICAgICAgICAgICAgICAgIF9wcm94eVN1YnNjcmliZUZvcm1TdGF0ZS5pc1ZhbGlkIHx8XG4gICAgICAgICAgICAgICAgc2hvdWxkVXBkYXRlVmFsaWQpKSB7XG4gICAgICAgICAgICBjb25zdCBpc1ZhbGlkID0gX29wdGlvbnMucmVzb2x2ZXJcbiAgICAgICAgICAgICAgICA/IGlzRW1wdHlPYmplY3QoKGF3YWl0IF9ydW5TY2hlbWEoKSkuZXJyb3JzKVxuICAgICAgICAgICAgICAgIDogYXdhaXQgZXhlY3V0ZUJ1aWx0SW5WYWxpZGF0aW9uKF9maWVsZHMsIHRydWUpO1xuICAgICAgICAgICAgaWYgKGlzVmFsaWQgIT09IF9mb3JtU3RhdGUuaXNWYWxpZCkge1xuICAgICAgICAgICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgICAgICAgICAgaXNWYWxpZCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgX3VwZGF0ZUlzVmFsaWRhdGluZyA9IChuYW1lcywgaXNWYWxpZGF0aW5nKSA9PiB7XG4gICAgICAgIGlmICghX29wdGlvbnMuZGlzYWJsZWQgJiZcbiAgICAgICAgICAgIChfcHJveHlGb3JtU3RhdGUuaXNWYWxpZGF0aW5nIHx8XG4gICAgICAgICAgICAgICAgX3Byb3h5Rm9ybVN0YXRlLnZhbGlkYXRpbmdGaWVsZHMgfHxcbiAgICAgICAgICAgICAgICBfcHJveHlTdWJzY3JpYmVGb3JtU3RhdGUuaXNWYWxpZGF0aW5nIHx8XG4gICAgICAgICAgICAgICAgX3Byb3h5U3Vic2NyaWJlRm9ybVN0YXRlLnZhbGlkYXRpbmdGaWVsZHMpKSB7XG4gICAgICAgICAgICAobmFtZXMgfHwgQXJyYXkuZnJvbShfbmFtZXMubW91bnQpKS5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNWYWxpZGF0aW5nXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHNldChfZm9ybVN0YXRlLnZhbGlkYXRpbmdGaWVsZHMsIG5hbWUsIGlzVmFsaWRhdGluZylcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdW5zZXQoX2Zvcm1TdGF0ZS52YWxpZGF0aW5nRmllbGRzLCBuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgICAgICB2YWxpZGF0aW5nRmllbGRzOiBfZm9ybVN0YXRlLnZhbGlkYXRpbmdGaWVsZHMsXG4gICAgICAgICAgICAgICAgaXNWYWxpZGF0aW5nOiAhaXNFbXB0eU9iamVjdChfZm9ybVN0YXRlLnZhbGlkYXRpbmdGaWVsZHMpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IF9zZXRGaWVsZEFycmF5ID0gKG5hbWUsIHZhbHVlcyA9IFtdLCBtZXRob2QsIGFyZ3MsIHNob3VsZFNldFZhbHVlcyA9IHRydWUsIHNob3VsZFVwZGF0ZUZpZWxkc0FuZFN0YXRlID0gdHJ1ZSkgPT4ge1xuICAgICAgICBpZiAoYXJncyAmJiBtZXRob2QgJiYgIV9vcHRpb25zLmRpc2FibGVkKSB7XG4gICAgICAgICAgICBfc3RhdGUuYWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChzaG91bGRVcGRhdGVGaWVsZHNBbmRTdGF0ZSAmJiBBcnJheS5pc0FycmF5KGdldChfZmllbGRzLCBuYW1lKSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZFZhbHVlcyA9IG1ldGhvZChnZXQoX2ZpZWxkcywgbmFtZSksIGFyZ3MuYXJnQSwgYXJncy5hcmdCKTtcbiAgICAgICAgICAgICAgICBzaG91bGRTZXRWYWx1ZXMgJiYgc2V0KF9maWVsZHMsIG5hbWUsIGZpZWxkVmFsdWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzaG91bGRVcGRhdGVGaWVsZHNBbmRTdGF0ZSAmJlxuICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkoZ2V0KF9mb3JtU3RhdGUuZXJyb3JzLCBuYW1lKSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvcnMgPSBtZXRob2QoZ2V0KF9mb3JtU3RhdGUuZXJyb3JzLCBuYW1lKSwgYXJncy5hcmdBLCBhcmdzLmFyZ0IpO1xuICAgICAgICAgICAgICAgIHNob3VsZFNldFZhbHVlcyAmJiBzZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUsIGVycm9ycyk7XG4gICAgICAgICAgICAgICAgdW5zZXRFbXB0eUFycmF5KF9mb3JtU3RhdGUuZXJyb3JzLCBuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoX3Byb3h5Rm9ybVN0YXRlLnRvdWNoZWRGaWVsZHMgfHxcbiAgICAgICAgICAgICAgICBfcHJveHlTdWJzY3JpYmVGb3JtU3RhdGUudG91Y2hlZEZpZWxkcykgJiZcbiAgICAgICAgICAgICAgICBzaG91bGRVcGRhdGVGaWVsZHNBbmRTdGF0ZSAmJlxuICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkoZ2V0KF9mb3JtU3RhdGUudG91Y2hlZEZpZWxkcywgbmFtZSkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG91Y2hlZEZpZWxkcyA9IG1ldGhvZChnZXQoX2Zvcm1TdGF0ZS50b3VjaGVkRmllbGRzLCBuYW1lKSwgYXJncy5hcmdBLCBhcmdzLmFyZ0IpO1xuICAgICAgICAgICAgICAgIHNob3VsZFNldFZhbHVlcyAmJiBzZXQoX2Zvcm1TdGF0ZS50b3VjaGVkRmllbGRzLCBuYW1lLCB0b3VjaGVkRmllbGRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfcHJveHlGb3JtU3RhdGUuZGlydHlGaWVsZHMgfHwgX3Byb3h5U3Vic2NyaWJlRm9ybVN0YXRlLmRpcnR5RmllbGRzKSB7XG4gICAgICAgICAgICAgICAgX2Zvcm1TdGF0ZS5kaXJ0eUZpZWxkcyA9IGdldERpcnR5RmllbGRzKF9kZWZhdWx0VmFsdWVzLCBfZm9ybVZhbHVlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh7XG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICBpc0RpcnR5OiBfZ2V0RGlydHkobmFtZSwgdmFsdWVzKSxcbiAgICAgICAgICAgICAgICBkaXJ0eUZpZWxkczogX2Zvcm1TdGF0ZS5kaXJ0eUZpZWxkcyxcbiAgICAgICAgICAgICAgICBlcnJvcnM6IF9mb3JtU3RhdGUuZXJyb3JzLFxuICAgICAgICAgICAgICAgIGlzVmFsaWQ6IF9mb3JtU3RhdGUuaXNWYWxpZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0KF9mb3JtVmFsdWVzLCBuYW1lLCB2YWx1ZXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCB1cGRhdGVFcnJvcnMgPSAobmFtZSwgZXJyb3IpID0+IHtcbiAgICAgICAgc2V0KF9mb3JtU3RhdGUuZXJyb3JzLCBuYW1lLCBlcnJvcik7XG4gICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgIGVycm9yczogX2Zvcm1TdGF0ZS5lcnJvcnMsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgX3NldEVycm9ycyA9IChlcnJvcnMpID0+IHtcbiAgICAgICAgX2Zvcm1TdGF0ZS5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgIGVycm9yczogX2Zvcm1TdGF0ZS5lcnJvcnMsXG4gICAgICAgICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCB1cGRhdGVWYWxpZEFuZFZhbHVlID0gKG5hbWUsIHNob3VsZFNraXBTZXRWYWx1ZUFzLCB2YWx1ZSwgcmVmKSA9PiB7XG4gICAgICAgIGNvbnN0IGZpZWxkID0gZ2V0KF9maWVsZHMsIG5hbWUpO1xuICAgICAgICBpZiAoZmllbGQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IGdldChfZm9ybVZhbHVlcywgbmFtZSwgaXNVbmRlZmluZWQodmFsdWUpID8gZ2V0KF9kZWZhdWx0VmFsdWVzLCBuYW1lKSA6IHZhbHVlKTtcbiAgICAgICAgICAgIGlzVW5kZWZpbmVkKGRlZmF1bHRWYWx1ZSkgfHxcbiAgICAgICAgICAgICAgICAocmVmICYmIHJlZi5kZWZhdWx0Q2hlY2tlZCkgfHxcbiAgICAgICAgICAgICAgICBzaG91bGRTa2lwU2V0VmFsdWVBc1xuICAgICAgICAgICAgICAgID8gc2V0KF9mb3JtVmFsdWVzLCBuYW1lLCBzaG91bGRTa2lwU2V0VmFsdWVBcyA/IGRlZmF1bHRWYWx1ZSA6IGdldEZpZWxkVmFsdWUoZmllbGQuX2YpKVxuICAgICAgICAgICAgICAgIDogc2V0RmllbGRWYWx1ZShuYW1lLCBkZWZhdWx0VmFsdWUpO1xuICAgICAgICAgICAgX3N0YXRlLm1vdW50ICYmICFfc3RhdGUuYWN0aW9uICYmIF9zZXRWYWxpZCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCB1cGRhdGVUb3VjaEFuZERpcnR5ID0gKG5hbWUsIGZpZWxkVmFsdWUsIGlzQmx1ckV2ZW50LCBzaG91bGREaXJ0eSwgc2hvdWxkUmVuZGVyKSA9PiB7XG4gICAgICAgIGxldCBzaG91bGRVcGRhdGVGaWVsZCA9IGZhbHNlO1xuICAgICAgICBsZXQgaXNQcmV2aW91c0RpcnR5ID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgIH07XG4gICAgICAgIGlmICghX29wdGlvbnMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIGlmICghaXNCbHVyRXZlbnQgfHwgc2hvdWxkRGlydHkpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3Byb3h5Rm9ybVN0YXRlLmlzRGlydHkgfHwgX3Byb3h5U3Vic2NyaWJlRm9ybVN0YXRlLmlzRGlydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNQcmV2aW91c0RpcnR5ID0gX2Zvcm1TdGF0ZS5pc0RpcnR5O1xuICAgICAgICAgICAgICAgICAgICBfZm9ybVN0YXRlLmlzRGlydHkgPSBvdXRwdXQuaXNEaXJ0eSA9IF9nZXREaXJ0eSgpO1xuICAgICAgICAgICAgICAgICAgICBzaG91bGRVcGRhdGVGaWVsZCA9IGlzUHJldmlvdXNEaXJ0eSAhPT0gb3V0cHV0LmlzRGlydHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGlzQ3VycmVudEZpZWxkUHJpc3RpbmUgPSBkZWVwRXF1YWwoZ2V0KF9kZWZhdWx0VmFsdWVzLCBuYW1lKSwgZmllbGRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgaXNQcmV2aW91c0RpcnR5ID0gISFnZXQoX2Zvcm1TdGF0ZS5kaXJ0eUZpZWxkcywgbmFtZSk7XG4gICAgICAgICAgICAgICAgaXNDdXJyZW50RmllbGRQcmlzdGluZVxuICAgICAgICAgICAgICAgICAgICA/IHVuc2V0KF9mb3JtU3RhdGUuZGlydHlGaWVsZHMsIG5hbWUpXG4gICAgICAgICAgICAgICAgICAgIDogc2V0KF9mb3JtU3RhdGUuZGlydHlGaWVsZHMsIG5hbWUsIHRydWUpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5kaXJ0eUZpZWxkcyA9IF9mb3JtU3RhdGUuZGlydHlGaWVsZHM7XG4gICAgICAgICAgICAgICAgc2hvdWxkVXBkYXRlRmllbGQgPVxuICAgICAgICAgICAgICAgICAgICBzaG91bGRVcGRhdGVGaWVsZCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKChfcHJveHlGb3JtU3RhdGUuZGlydHlGaWVsZHMgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcHJveHlTdWJzY3JpYmVGb3JtU3RhdGUuZGlydHlGaWVsZHMpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNQcmV2aW91c0RpcnR5ICE9PSAhaXNDdXJyZW50RmllbGRQcmlzdGluZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNCbHVyRXZlbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1ByZXZpb3VzRmllbGRUb3VjaGVkID0gZ2V0KF9mb3JtU3RhdGUudG91Y2hlZEZpZWxkcywgbmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1ByZXZpb3VzRmllbGRUb3VjaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldChfZm9ybVN0YXRlLnRvdWNoZWRGaWVsZHMsIG5hbWUsIGlzQmx1ckV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnRvdWNoZWRGaWVsZHMgPSBfZm9ybVN0YXRlLnRvdWNoZWRGaWVsZHM7XG4gICAgICAgICAgICAgICAgICAgIHNob3VsZFVwZGF0ZUZpZWxkID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZFVwZGF0ZUZpZWxkIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKChfcHJveHlGb3JtU3RhdGUudG91Y2hlZEZpZWxkcyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcHJveHlTdWJzY3JpYmVGb3JtU3RhdGUudG91Y2hlZEZpZWxkcykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNQcmV2aW91c0ZpZWxkVG91Y2hlZCAhPT0gaXNCbHVyRXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNob3VsZFVwZGF0ZUZpZWxkICYmIHNob3VsZFJlbmRlciAmJiBfc3ViamVjdHMuc3RhdGUubmV4dChvdXRwdXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaG91bGRVcGRhdGVGaWVsZCA/IG91dHB1dCA6IHt9O1xuICAgIH07XG4gICAgY29uc3Qgc2hvdWxkUmVuZGVyQnlFcnJvciA9IChuYW1lLCBpc1ZhbGlkLCBlcnJvciwgZmllbGRTdGF0ZSkgPT4ge1xuICAgICAgICBjb25zdCBwcmV2aW91c0ZpZWxkRXJyb3IgPSBnZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUpO1xuICAgICAgICBjb25zdCBzaG91bGRVcGRhdGVWYWxpZCA9IChfcHJveHlGb3JtU3RhdGUuaXNWYWxpZCB8fCBfcHJveHlTdWJzY3JpYmVGb3JtU3RhdGUuaXNWYWxpZCkgJiZcbiAgICAgICAgICAgIGlzQm9vbGVhbihpc1ZhbGlkKSAmJlxuICAgICAgICAgICAgX2Zvcm1TdGF0ZS5pc1ZhbGlkICE9PSBpc1ZhbGlkO1xuICAgICAgICBpZiAoX29wdGlvbnMuZGVsYXlFcnJvciAmJiBlcnJvcikge1xuICAgICAgICAgICAgZGVsYXlFcnJvckNhbGxiYWNrID0gZGVib3VuY2UoKCkgPT4gdXBkYXRlRXJyb3JzKG5hbWUsIGVycm9yKSk7XG4gICAgICAgICAgICBkZWxheUVycm9yQ2FsbGJhY2soX29wdGlvbnMuZGVsYXlFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgZGVsYXlFcnJvckNhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICAgICAgPyBzZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUsIGVycm9yKVxuICAgICAgICAgICAgICAgIDogdW5zZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoZXJyb3IgPyAhZGVlcEVxdWFsKHByZXZpb3VzRmllbGRFcnJvciwgZXJyb3IpIDogcHJldmlvdXNGaWVsZEVycm9yKSB8fFxuICAgICAgICAgICAgIWlzRW1wdHlPYmplY3QoZmllbGRTdGF0ZSkgfHxcbiAgICAgICAgICAgIHNob3VsZFVwZGF0ZVZhbGlkKSB7XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkRm9ybVN0YXRlID0ge1xuICAgICAgICAgICAgICAgIC4uLmZpZWxkU3RhdGUsXG4gICAgICAgICAgICAgICAgLi4uKHNob3VsZFVwZGF0ZVZhbGlkICYmIGlzQm9vbGVhbihpc1ZhbGlkKSA/IHsgaXNWYWxpZCB9IDoge30pLFxuICAgICAgICAgICAgICAgIGVycm9yczogX2Zvcm1TdGF0ZS5lcnJvcnMsXG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfZm9ybVN0YXRlID0ge1xuICAgICAgICAgICAgICAgIC4uLl9mb3JtU3RhdGUsXG4gICAgICAgICAgICAgICAgLi4udXBkYXRlZEZvcm1TdGF0ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh1cGRhdGVkRm9ybVN0YXRlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgX3J1blNjaGVtYSA9IGFzeW5jIChuYW1lKSA9PiB7XG4gICAgICAgIF91cGRhdGVJc1ZhbGlkYXRpbmcobmFtZSwgdHJ1ZSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IF9vcHRpb25zLnJlc29sdmVyKF9mb3JtVmFsdWVzLCBfb3B0aW9ucy5jb250ZXh0LCBnZXRSZXNvbHZlck9wdGlvbnMobmFtZSB8fCBfbmFtZXMubW91bnQsIF9maWVsZHMsIF9vcHRpb25zLmNyaXRlcmlhTW9kZSwgX29wdGlvbnMuc2hvdWxkVXNlTmF0aXZlVmFsaWRhdGlvbikpO1xuICAgICAgICBfdXBkYXRlSXNWYWxpZGF0aW5nKG5hbWUpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgY29uc3QgZXhlY3V0ZVNjaGVtYUFuZFVwZGF0ZVN0YXRlID0gYXN5bmMgKG5hbWVzKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZXJyb3JzIH0gPSBhd2FpdCBfcnVuU2NoZW1hKG5hbWVzKTtcbiAgICAgICAgaWYgKG5hbWVzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgbmFtZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IGdldChlcnJvcnMsIG5hbWUpO1xuICAgICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICAgICAgICAgID8gc2V0KF9mb3JtU3RhdGUuZXJyb3JzLCBuYW1lLCBlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgOiB1bnNldChfZm9ybVN0YXRlLmVycm9ycywgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfZm9ybVN0YXRlLmVycm9ycyA9IGVycm9ycztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgIH07XG4gICAgY29uc3QgZXhlY3V0ZUJ1aWx0SW5WYWxpZGF0aW9uID0gYXN5bmMgKGZpZWxkcywgc2hvdWxkT25seUNoZWNrVmFsaWQsIGNvbnRleHQgPSB7XG4gICAgICAgIHZhbGlkOiB0cnVlLFxuICAgIH0pID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIGZpZWxkcykge1xuICAgICAgICAgICAgY29uc3QgZmllbGQgPSBmaWVsZHNbbmFtZV07XG4gICAgICAgICAgICBpZiAoZmllbGQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IF9mLCAuLi5maWVsZFZhbHVlIH0gPSBmaWVsZDtcbiAgICAgICAgICAgICAgICBpZiAoX2YpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNGaWVsZEFycmF5Um9vdCA9IF9uYW1lcy5hcnJheS5oYXMoX2YubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzUHJvbWlzZUZ1bmN0aW9uID0gZmllbGQuX2YgJiYgaGFzUHJvbWlzZVZhbGlkYXRpb24oZmllbGQuX2YpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNQcm9taXNlRnVuY3Rpb24gJiYgX3Byb3h5Rm9ybVN0YXRlLnZhbGlkYXRpbmdGaWVsZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF91cGRhdGVJc1ZhbGlkYXRpbmcoW19mLm5hbWVdLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWVsZEVycm9yID0gYXdhaXQgdmFsaWRhdGVGaWVsZChmaWVsZCwgX25hbWVzLmRpc2FibGVkLCBfZm9ybVZhbHVlcywgc2hvdWxkRGlzcGxheUFsbEFzc29jaWF0ZWRFcnJvcnMsIF9vcHRpb25zLnNob3VsZFVzZU5hdGl2ZVZhbGlkYXRpb24gJiYgIXNob3VsZE9ubHlDaGVja1ZhbGlkLCBpc0ZpZWxkQXJyYXlSb290KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUHJvbWlzZUZ1bmN0aW9uICYmIF9wcm94eUZvcm1TdGF0ZS52YWxpZGF0aW5nRmllbGRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdXBkYXRlSXNWYWxpZGF0aW5nKFtfZi5uYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkRXJyb3JbX2YubmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQudmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRPbmx5Q2hlY2tWYWxpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICFzaG91bGRPbmx5Q2hlY2tWYWxpZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKGdldChmaWVsZEVycm9yLCBfZi5uYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gaXNGaWVsZEFycmF5Um9vdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHVwZGF0ZUZpZWxkQXJyYXlSb290RXJyb3IoX2Zvcm1TdGF0ZS5lcnJvcnMsIGZpZWxkRXJyb3IsIF9mLm5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogc2V0KF9mb3JtU3RhdGUuZXJyb3JzLCBfZi5uYW1lLCBmaWVsZEVycm9yW19mLm5hbWVdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdW5zZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIF9mLm5hbWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgIWlzRW1wdHlPYmplY3QoZmllbGRWYWx1ZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgKGF3YWl0IGV4ZWN1dGVCdWlsdEluVmFsaWRhdGlvbihmaWVsZFZhbHVlLCBzaG91bGRPbmx5Q2hlY2tWYWxpZCwgY29udGV4dCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250ZXh0LnZhbGlkO1xuICAgIH07XG4gICAgY29uc3QgX3JlbW92ZVVubW91bnRlZCA9ICgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIF9uYW1lcy51bk1vdW50KSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZCA9IGdldChfZmllbGRzLCBuYW1lKTtcbiAgICAgICAgICAgIGZpZWxkICYmXG4gICAgICAgICAgICAgICAgKGZpZWxkLl9mLnJlZnNcbiAgICAgICAgICAgICAgICAgICAgPyBmaWVsZC5fZi5yZWZzLmV2ZXJ5KChyZWYpID0+ICFsaXZlKHJlZikpXG4gICAgICAgICAgICAgICAgICAgIDogIWxpdmUoZmllbGQuX2YucmVmKSkgJiZcbiAgICAgICAgICAgICAgICB1bnJlZ2lzdGVyKG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIF9uYW1lcy51bk1vdW50ID0gbmV3IFNldCgpO1xuICAgIH07XG4gICAgY29uc3QgX2dldERpcnR5ID0gKG5hbWUsIGRhdGEpID0+ICFfb3B0aW9ucy5kaXNhYmxlZCAmJlxuICAgICAgICAobmFtZSAmJiBkYXRhICYmIHNldChfZm9ybVZhbHVlcywgbmFtZSwgZGF0YSksXG4gICAgICAgICAgICAhZGVlcEVxdWFsKGdldFZhbHVlcygpLCBfZGVmYXVsdFZhbHVlcykpO1xuICAgIGNvbnN0IF9nZXRXYXRjaCA9IChuYW1lcywgZGVmYXVsdFZhbHVlLCBpc0dsb2JhbCkgPT4gZ2VuZXJhdGVXYXRjaE91dHB1dChuYW1lcywgX25hbWVzLCB7XG4gICAgICAgIC4uLihfc3RhdGUubW91bnRcbiAgICAgICAgICAgID8gX2Zvcm1WYWx1ZXNcbiAgICAgICAgICAgIDogaXNVbmRlZmluZWQoZGVmYXVsdFZhbHVlKVxuICAgICAgICAgICAgICAgID8gX2RlZmF1bHRWYWx1ZXNcbiAgICAgICAgICAgICAgICA6IGlzU3RyaW5nKG5hbWVzKVxuICAgICAgICAgICAgICAgICAgICA/IHsgW25hbWVzXTogZGVmYXVsdFZhbHVlIH1cbiAgICAgICAgICAgICAgICAgICAgOiBkZWZhdWx0VmFsdWUpLFxuICAgIH0sIGlzR2xvYmFsLCBkZWZhdWx0VmFsdWUpO1xuICAgIGNvbnN0IF9nZXRGaWVsZEFycmF5ID0gKG5hbWUpID0+IGNvbXBhY3QoZ2V0KF9zdGF0ZS5tb3VudCA/IF9mb3JtVmFsdWVzIDogX2RlZmF1bHRWYWx1ZXMsIG5hbWUsIF9vcHRpb25zLnNob3VsZFVucmVnaXN0ZXIgPyBnZXQoX2RlZmF1bHRWYWx1ZXMsIG5hbWUsIFtdKSA6IFtdKSk7XG4gICAgY29uc3Qgc2V0RmllbGRWYWx1ZSA9IChuYW1lLCB2YWx1ZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgIGNvbnN0IGZpZWxkID0gZ2V0KF9maWVsZHMsIG5hbWUpO1xuICAgICAgICBsZXQgZmllbGRWYWx1ZSA9IHZhbHVlO1xuICAgICAgICBpZiAoZmllbGQpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkUmVmZXJlbmNlID0gZmllbGQuX2Y7XG4gICAgICAgICAgICBpZiAoZmllbGRSZWZlcmVuY2UpIHtcbiAgICAgICAgICAgICAgICAhZmllbGRSZWZlcmVuY2UuZGlzYWJsZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgc2V0KF9mb3JtVmFsdWVzLCBuYW1lLCBnZXRGaWVsZFZhbHVlQXModmFsdWUsIGZpZWxkUmVmZXJlbmNlKSk7XG4gICAgICAgICAgICAgICAgZmllbGRWYWx1ZSA9XG4gICAgICAgICAgICAgICAgICAgIGlzSFRNTEVsZW1lbnQoZmllbGRSZWZlcmVuY2UucmVmKSAmJiBpc051bGxPclVuZGVmaW5lZCh2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gJydcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGlzTXVsdGlwbGVTZWxlY3QoZmllbGRSZWZlcmVuY2UucmVmKSkge1xuICAgICAgICAgICAgICAgICAgICBbLi4uZmllbGRSZWZlcmVuY2UucmVmLm9wdGlvbnNdLmZvckVhY2goKG9wdGlvblJlZikgPT4gKG9wdGlvblJlZi5zZWxlY3RlZCA9IGZpZWxkVmFsdWUuaW5jbHVkZXMob3B0aW9uUmVmLnZhbHVlKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmaWVsZFJlZmVyZW5jZS5yZWZzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0NoZWNrQm94SW5wdXQoZmllbGRSZWZlcmVuY2UucmVmKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRSZWZlcmVuY2UucmVmcy5mb3JFYWNoKChjaGVja2JveFJlZikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2hlY2tib3hSZWYuZGVmYXVsdENoZWNrZWQgfHwgIWNoZWNrYm94UmVmLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZpZWxkVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja2JveFJlZi5jaGVja2VkID0gISFmaWVsZFZhbHVlLmZpbmQoKGRhdGEpID0+IGRhdGEgPT09IGNoZWNrYm94UmVmLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrYm94UmVmLmNoZWNrZWQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkVmFsdWUgPT09IGNoZWNrYm94UmVmLnZhbHVlIHx8ICEhZmllbGRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRSZWZlcmVuY2UucmVmcy5mb3JFYWNoKChyYWRpb1JlZikgPT4gKHJhZGlvUmVmLmNoZWNrZWQgPSByYWRpb1JlZi52YWx1ZSA9PT0gZmllbGRWYWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzRmlsZUlucHV0KGZpZWxkUmVmZXJlbmNlLnJlZikpIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGRSZWZlcmVuY2UucmVmLnZhbHVlID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZFJlZmVyZW5jZS5yZWYudmFsdWUgPSBmaWVsZFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZpZWxkUmVmZXJlbmNlLnJlZi50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IGNsb25lT2JqZWN0KF9mb3JtVmFsdWVzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIChvcHRpb25zLnNob3VsZERpcnR5IHx8IG9wdGlvbnMuc2hvdWxkVG91Y2gpICYmXG4gICAgICAgICAgICB1cGRhdGVUb3VjaEFuZERpcnR5KG5hbWUsIGZpZWxkVmFsdWUsIG9wdGlvbnMuc2hvdWxkVG91Y2gsIG9wdGlvbnMuc2hvdWxkRGlydHksIHRydWUpO1xuICAgICAgICBvcHRpb25zLnNob3VsZFZhbGlkYXRlICYmIHRyaWdnZXIobmFtZSk7XG4gICAgfTtcbiAgICBjb25zdCBzZXRWYWx1ZXMgPSAobmFtZSwgdmFsdWUsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBmaWVsZEtleSBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKCF2YWx1ZS5oYXNPd25Qcm9wZXJ0eShmaWVsZEtleSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBmaWVsZFZhbHVlID0gdmFsdWVbZmllbGRLZXldO1xuICAgICAgICAgICAgY29uc3QgZmllbGROYW1lID0gbmFtZSArICcuJyArIGZpZWxkS2V5O1xuICAgICAgICAgICAgY29uc3QgZmllbGQgPSBnZXQoX2ZpZWxkcywgZmllbGROYW1lKTtcbiAgICAgICAgICAgIChfbmFtZXMuYXJyYXkuaGFzKG5hbWUpIHx8XG4gICAgICAgICAgICAgICAgaXNPYmplY3QoZmllbGRWYWx1ZSkgfHxcbiAgICAgICAgICAgICAgICAoZmllbGQgJiYgIWZpZWxkLl9mKSkgJiZcbiAgICAgICAgICAgICAgICAhaXNEYXRlT2JqZWN0KGZpZWxkVmFsdWUpXG4gICAgICAgICAgICAgICAgPyBzZXRWYWx1ZXMoZmllbGROYW1lLCBmaWVsZFZhbHVlLCBvcHRpb25zKVxuICAgICAgICAgICAgICAgIDogc2V0RmllbGRWYWx1ZShmaWVsZE5hbWUsIGZpZWxkVmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBzZXRWYWx1ZSA9IChuYW1lLCB2YWx1ZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgIGNvbnN0IGZpZWxkID0gZ2V0KF9maWVsZHMsIG5hbWUpO1xuICAgICAgICBjb25zdCBpc0ZpZWxkQXJyYXkgPSBfbmFtZXMuYXJyYXkuaGFzKG5hbWUpO1xuICAgICAgICBjb25zdCBjbG9uZVZhbHVlID0gY2xvbmVPYmplY3QodmFsdWUpO1xuICAgICAgICBzZXQoX2Zvcm1WYWx1ZXMsIG5hbWUsIGNsb25lVmFsdWUpO1xuICAgICAgICBpZiAoaXNGaWVsZEFycmF5KSB7XG4gICAgICAgICAgICBfc3ViamVjdHMuYXJyYXkubmV4dCh7XG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IGNsb25lT2JqZWN0KF9mb3JtVmFsdWVzKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKChfcHJveHlGb3JtU3RhdGUuaXNEaXJ0eSB8fFxuICAgICAgICAgICAgICAgIF9wcm94eUZvcm1TdGF0ZS5kaXJ0eUZpZWxkcyB8fFxuICAgICAgICAgICAgICAgIF9wcm94eVN1YnNjcmliZUZvcm1TdGF0ZS5pc0RpcnR5IHx8XG4gICAgICAgICAgICAgICAgX3Byb3h5U3Vic2NyaWJlRm9ybVN0YXRlLmRpcnR5RmllbGRzKSAmJlxuICAgICAgICAgICAgICAgIG9wdGlvbnMuc2hvdWxkRGlydHkpIHtcbiAgICAgICAgICAgICAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGRpcnR5RmllbGRzOiBnZXREaXJ0eUZpZWxkcyhfZGVmYXVsdFZhbHVlcywgX2Zvcm1WYWx1ZXMpLFxuICAgICAgICAgICAgICAgICAgICBpc0RpcnR5OiBfZ2V0RGlydHkobmFtZSwgY2xvbmVWYWx1ZSksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmaWVsZCAmJiAhZmllbGQuX2YgJiYgIWlzTnVsbE9yVW5kZWZpbmVkKGNsb25lVmFsdWUpXG4gICAgICAgICAgICAgICAgPyBzZXRWYWx1ZXMobmFtZSwgY2xvbmVWYWx1ZSwgb3B0aW9ucylcbiAgICAgICAgICAgICAgICA6IHNldEZpZWxkVmFsdWUobmFtZSwgY2xvbmVWYWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgaXNXYXRjaGVkKG5hbWUsIF9uYW1lcykgJiYgX3N1YmplY3RzLnN0YXRlLm5leHQoeyAuLi5fZm9ybVN0YXRlLCBuYW1lIH0pO1xuICAgICAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh7XG4gICAgICAgICAgICBuYW1lOiBfc3RhdGUubW91bnQgPyBuYW1lIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgdmFsdWVzOiBjbG9uZU9iamVjdChfZm9ybVZhbHVlcyksXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3Qgb25DaGFuZ2UgPSBhc3luYyAoZXZlbnQpID0+IHtcbiAgICAgICAgX3N0YXRlLm1vdW50ID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICBsZXQgbmFtZSA9IHRhcmdldC5uYW1lO1xuICAgICAgICBsZXQgaXNGaWVsZFZhbHVlVXBkYXRlZCA9IHRydWU7XG4gICAgICAgIGNvbnN0IGZpZWxkID0gZ2V0KF9maWVsZHMsIG5hbWUpO1xuICAgICAgICBjb25zdCBfdXBkYXRlSXNGaWVsZFZhbHVlVXBkYXRlZCA9IChmaWVsZFZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpc0ZpZWxkVmFsdWVVcGRhdGVkID1cbiAgICAgICAgICAgICAgICBOdW1iZXIuaXNOYU4oZmllbGRWYWx1ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgKGlzRGF0ZU9iamVjdChmaWVsZFZhbHVlKSAmJiBpc05hTihmaWVsZFZhbHVlLmdldFRpbWUoKSkpIHx8XG4gICAgICAgICAgICAgICAgICAgIGRlZXBFcXVhbChmaWVsZFZhbHVlLCBnZXQoX2Zvcm1WYWx1ZXMsIG5hbWUsIGZpZWxkVmFsdWUpKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdmFsaWRhdGlvbk1vZGVCZWZvcmVTdWJtaXQgPSBnZXRWYWxpZGF0aW9uTW9kZXMoX29wdGlvbnMubW9kZSk7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRpb25Nb2RlQWZ0ZXJTdWJtaXQgPSBnZXRWYWxpZGF0aW9uTW9kZXMoX29wdGlvbnMucmVWYWxpZGF0ZU1vZGUpO1xuICAgICAgICBpZiAoZmllbGQpIHtcbiAgICAgICAgICAgIGxldCBlcnJvcjtcbiAgICAgICAgICAgIGxldCBpc1ZhbGlkO1xuICAgICAgICAgICAgY29uc3QgZmllbGRWYWx1ZSA9IHRhcmdldC50eXBlXG4gICAgICAgICAgICAgICAgPyBnZXRGaWVsZFZhbHVlKGZpZWxkLl9mKVxuICAgICAgICAgICAgICAgIDogZ2V0RXZlbnRWYWx1ZShldmVudCk7XG4gICAgICAgICAgICBjb25zdCBpc0JsdXJFdmVudCA9IGV2ZW50LnR5cGUgPT09IEVWRU5UUy5CTFVSIHx8IGV2ZW50LnR5cGUgPT09IEVWRU5UUy5GT0NVU19PVVQ7XG4gICAgICAgICAgICBjb25zdCBzaG91bGRTa2lwVmFsaWRhdGlvbiA9ICghaGFzVmFsaWRhdGlvbihmaWVsZC5fZikgJiZcbiAgICAgICAgICAgICAgICAhX29wdGlvbnMucmVzb2x2ZXIgJiZcbiAgICAgICAgICAgICAgICAhZ2V0KF9mb3JtU3RhdGUuZXJyb3JzLCBuYW1lKSAmJlxuICAgICAgICAgICAgICAgICFmaWVsZC5fZi5kZXBzKSB8fFxuICAgICAgICAgICAgICAgIHNraXBWYWxpZGF0aW9uKGlzQmx1ckV2ZW50LCBnZXQoX2Zvcm1TdGF0ZS50b3VjaGVkRmllbGRzLCBuYW1lKSwgX2Zvcm1TdGF0ZS5pc1N1Ym1pdHRlZCwgdmFsaWRhdGlvbk1vZGVBZnRlclN1Ym1pdCwgdmFsaWRhdGlvbk1vZGVCZWZvcmVTdWJtaXQpO1xuICAgICAgICAgICAgY29uc3Qgd2F0Y2hlZCA9IGlzV2F0Y2hlZChuYW1lLCBfbmFtZXMsIGlzQmx1ckV2ZW50KTtcbiAgICAgICAgICAgIHNldChfZm9ybVZhbHVlcywgbmFtZSwgZmllbGRWYWx1ZSk7XG4gICAgICAgICAgICBpZiAoaXNCbHVyRXZlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRhcmdldCB8fCAhdGFyZ2V0LnJlYWRPbmx5KSB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkLl9mLm9uQmx1ciAmJiBmaWVsZC5fZi5vbkJsdXIoZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICBkZWxheUVycm9yQ2FsbGJhY2sgJiYgZGVsYXlFcnJvckNhbGxiYWNrKDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkLl9mLm9uQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgZmllbGQuX2Yub25DaGFuZ2UoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZmllbGRTdGF0ZSA9IHVwZGF0ZVRvdWNoQW5kRGlydHkobmFtZSwgZmllbGRWYWx1ZSwgaXNCbHVyRXZlbnQpO1xuICAgICAgICAgICAgY29uc3Qgc2hvdWxkUmVuZGVyID0gIWlzRW1wdHlPYmplY3QoZmllbGRTdGF0ZSkgfHwgd2F0Y2hlZDtcbiAgICAgICAgICAgICFpc0JsdXJFdmVudCAmJlxuICAgICAgICAgICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogZXZlbnQudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiBjbG9uZU9iamVjdChfZm9ybVZhbHVlcyksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoc2hvdWxkU2tpcFZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoX3Byb3h5Rm9ybVN0YXRlLmlzVmFsaWQgfHwgX3Byb3h5U3Vic2NyaWJlRm9ybVN0YXRlLmlzVmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9vcHRpb25zLm1vZGUgPT09ICdvbkJsdXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNCbHVyRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfc2V0VmFsaWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghaXNCbHVyRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zZXRWYWxpZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAoc2hvdWxkUmVuZGVyICYmXG4gICAgICAgICAgICAgICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHsgbmFtZSwgLi4uKHdhdGNoZWQgPyB7fSA6IGZpZWxkU3RhdGUpIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICFpc0JsdXJFdmVudCAmJiB3YXRjaGVkICYmIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHsgLi4uX2Zvcm1TdGF0ZSB9KTtcbiAgICAgICAgICAgIGlmIChfb3B0aW9ucy5yZXNvbHZlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZXJyb3JzIH0gPSBhd2FpdCBfcnVuU2NoZW1hKFtuYW1lXSk7XG4gICAgICAgICAgICAgICAgX3VwZGF0ZUlzRmllbGRWYWx1ZVVwZGF0ZWQoZmllbGRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzRmllbGRWYWx1ZVVwZGF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldmlvdXNFcnJvckxvb2t1cFJlc3VsdCA9IHNjaGVtYUVycm9yTG9va3VwKF9mb3JtU3RhdGUuZXJyb3JzLCBfZmllbGRzLCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3JMb29rdXBSZXN1bHQgPSBzY2hlbWFFcnJvckxvb2t1cChlcnJvcnMsIF9maWVsZHMsIHByZXZpb3VzRXJyb3JMb29rdXBSZXN1bHQubmFtZSB8fCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBlcnJvckxvb2t1cFJlc3VsdC5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IGVycm9yTG9va3VwUmVzdWx0Lm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGlzVmFsaWQgPSBpc0VtcHR5T2JqZWN0KGVycm9ycyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX3VwZGF0ZUlzVmFsaWRhdGluZyhbbmFtZV0sIHRydWUpO1xuICAgICAgICAgICAgICAgIGVycm9yID0gKGF3YWl0IHZhbGlkYXRlRmllbGQoZmllbGQsIF9uYW1lcy5kaXNhYmxlZCwgX2Zvcm1WYWx1ZXMsIHNob3VsZERpc3BsYXlBbGxBc3NvY2lhdGVkRXJyb3JzLCBfb3B0aW9ucy5zaG91bGRVc2VOYXRpdmVWYWxpZGF0aW9uKSlbbmFtZV07XG4gICAgICAgICAgICAgICAgX3VwZGF0ZUlzVmFsaWRhdGluZyhbbmFtZV0pO1xuICAgICAgICAgICAgICAgIF91cGRhdGVJc0ZpZWxkVmFsdWVVcGRhdGVkKGZpZWxkVmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChpc0ZpZWxkVmFsdWVVcGRhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKF9wcm94eUZvcm1TdGF0ZS5pc1ZhbGlkIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBfcHJveHlTdWJzY3JpYmVGb3JtU3RhdGUuaXNWYWxpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNWYWxpZCA9IGF3YWl0IGV4ZWN1dGVCdWlsdEluVmFsaWRhdGlvbihfZmllbGRzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0ZpZWxkVmFsdWVVcGRhdGVkKSB7XG4gICAgICAgICAgICAgICAgZmllbGQuX2YuZGVwcyAmJlxuICAgICAgICAgICAgICAgICAgICAoIUFycmF5LmlzQXJyYXkoZmllbGQuX2YuZGVwcykgfHwgZmllbGQuX2YuZGVwcy5sZW5ndGggPiAwKSAmJlxuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyKGZpZWxkLl9mLmRlcHMpO1xuICAgICAgICAgICAgICAgIHNob3VsZFJlbmRlckJ5RXJyb3IobmFtZSwgaXNWYWxpZCwgZXJyb3IsIGZpZWxkU3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBfZm9jdXNJbnB1dCA9IChyZWYsIGtleSkgPT4ge1xuICAgICAgICBpZiAoZ2V0KF9mb3JtU3RhdGUuZXJyb3JzLCBrZXkpICYmIHJlZi5mb2N1cykge1xuICAgICAgICAgICAgcmVmLmZvY3VzKCk7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfTtcbiAgICBjb25zdCB0cmlnZ2VyID0gYXN5bmMgKG5hbWUsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICBsZXQgaXNWYWxpZDtcbiAgICAgICAgbGV0IHZhbGlkYXRpb25SZXN1bHQ7XG4gICAgICAgIGNvbnN0IGZpZWxkTmFtZXMgPSBjb252ZXJ0VG9BcnJheVBheWxvYWQobmFtZSk7XG4gICAgICAgIGlmIChfb3B0aW9ucy5yZXNvbHZlcikge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JzID0gYXdhaXQgZXhlY3V0ZVNjaGVtYUFuZFVwZGF0ZVN0YXRlKGlzVW5kZWZpbmVkKG5hbWUpID8gbmFtZSA6IGZpZWxkTmFtZXMpO1xuICAgICAgICAgICAgaXNWYWxpZCA9IGlzRW1wdHlPYmplY3QoZXJyb3JzKTtcbiAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQgPSBuYW1lXG4gICAgICAgICAgICAgICAgPyAhZmllbGROYW1lcy5zb21lKChuYW1lKSA9PiBnZXQoZXJyb3JzLCBuYW1lKSlcbiAgICAgICAgICAgICAgICA6IGlzVmFsaWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmFtZSkge1xuICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdCA9IChhd2FpdCBQcm9taXNlLmFsbChmaWVsZE5hbWVzLm1hcChhc3luYyAoZmllbGROYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGQgPSBnZXQoX2ZpZWxkcywgZmllbGROYW1lKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgZXhlY3V0ZUJ1aWx0SW5WYWxpZGF0aW9uKGZpZWxkICYmIGZpZWxkLl9mID8geyBbZmllbGROYW1lXTogZmllbGQgfSA6IGZpZWxkKTtcbiAgICAgICAgICAgIH0pKSkuZXZlcnkoQm9vbGVhbik7XG4gICAgICAgICAgICAhKCF2YWxpZGF0aW9uUmVzdWx0ICYmICFfZm9ybVN0YXRlLmlzVmFsaWQpICYmIF9zZXRWYWxpZCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdCA9IGlzVmFsaWQgPSBhd2FpdCBleGVjdXRlQnVpbHRJblZhbGlkYXRpb24oX2ZpZWxkcyk7XG4gICAgICAgIH1cbiAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgLi4uKCFpc1N0cmluZyhuYW1lKSB8fFxuICAgICAgICAgICAgICAgICgoX3Byb3h5Rm9ybVN0YXRlLmlzVmFsaWQgfHwgX3Byb3h5U3Vic2NyaWJlRm9ybVN0YXRlLmlzVmFsaWQpICYmXG4gICAgICAgICAgICAgICAgICAgIGlzVmFsaWQgIT09IF9mb3JtU3RhdGUuaXNWYWxpZClcbiAgICAgICAgICAgICAgICA/IHt9XG4gICAgICAgICAgICAgICAgOiB7IG5hbWUgfSksXG4gICAgICAgICAgICAuLi4oX29wdGlvbnMucmVzb2x2ZXIgfHwgIW5hbWUgPyB7IGlzVmFsaWQgfSA6IHt9KSxcbiAgICAgICAgICAgIGVycm9yczogX2Zvcm1TdGF0ZS5lcnJvcnMsXG4gICAgICAgIH0pO1xuICAgICAgICBvcHRpb25zLnNob3VsZEZvY3VzICYmXG4gICAgICAgICAgICAhdmFsaWRhdGlvblJlc3VsdCAmJlxuICAgICAgICAgICAgaXRlcmF0ZUZpZWxkc0J5QWN0aW9uKF9maWVsZHMsIF9mb2N1c0lucHV0LCBuYW1lID8gZmllbGROYW1lcyA6IF9uYW1lcy5tb3VudCk7XG4gICAgICAgIHJldHVybiB2YWxpZGF0aW9uUmVzdWx0O1xuICAgIH07XG4gICAgY29uc3QgZ2V0VmFsdWVzID0gKGZpZWxkTmFtZXMsIGNvbmZpZykgPT4ge1xuICAgICAgICBsZXQgdmFsdWVzID0ge1xuICAgICAgICAgICAgLi4uKF9zdGF0ZS5tb3VudCA/IF9mb3JtVmFsdWVzIDogX2RlZmF1bHRWYWx1ZXMpLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoY29uZmlnKSB7XG4gICAgICAgICAgICB2YWx1ZXMgPSBleHRyYWN0Rm9ybVZhbHVlcyhjb25maWcuZGlydHlGaWVsZHMgPyBfZm9ybVN0YXRlLmRpcnR5RmllbGRzIDogX2Zvcm1TdGF0ZS50b3VjaGVkRmllbGRzLCB2YWx1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc1VuZGVmaW5lZChmaWVsZE5hbWVzKVxuICAgICAgICAgICAgPyB2YWx1ZXNcbiAgICAgICAgICAgIDogaXNTdHJpbmcoZmllbGROYW1lcylcbiAgICAgICAgICAgICAgICA/IGdldCh2YWx1ZXMsIGZpZWxkTmFtZXMpXG4gICAgICAgICAgICAgICAgOiBmaWVsZE5hbWVzLm1hcCgobmFtZSkgPT4gZ2V0KHZhbHVlcywgbmFtZSkpO1xuICAgIH07XG4gICAgY29uc3QgZ2V0RmllbGRTdGF0ZSA9IChuYW1lLCBmb3JtU3RhdGUpID0+ICh7XG4gICAgICAgIGludmFsaWQ6ICEhZ2V0KChmb3JtU3RhdGUgfHwgX2Zvcm1TdGF0ZSkuZXJyb3JzLCBuYW1lKSxcbiAgICAgICAgaXNEaXJ0eTogISFnZXQoKGZvcm1TdGF0ZSB8fCBfZm9ybVN0YXRlKS5kaXJ0eUZpZWxkcywgbmFtZSksXG4gICAgICAgIGVycm9yOiBnZXQoKGZvcm1TdGF0ZSB8fCBfZm9ybVN0YXRlKS5lcnJvcnMsIG5hbWUpLFxuICAgICAgICBpc1ZhbGlkYXRpbmc6ICEhZ2V0KF9mb3JtU3RhdGUudmFsaWRhdGluZ0ZpZWxkcywgbmFtZSksXG4gICAgICAgIGlzVG91Y2hlZDogISFnZXQoKGZvcm1TdGF0ZSB8fCBfZm9ybVN0YXRlKS50b3VjaGVkRmllbGRzLCBuYW1lKSxcbiAgICB9KTtcbiAgICBjb25zdCBjbGVhckVycm9ycyA9IChuYW1lKSA9PiB7XG4gICAgICAgIG5hbWUgJiZcbiAgICAgICAgICAgIGNvbnZlcnRUb0FycmF5UGF5bG9hZChuYW1lKS5mb3JFYWNoKChpbnB1dE5hbWUpID0+IHVuc2V0KF9mb3JtU3RhdGUuZXJyb3JzLCBpbnB1dE5hbWUpKTtcbiAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgZXJyb3JzOiBuYW1lID8gX2Zvcm1TdGF0ZS5lcnJvcnMgOiB7fSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBzZXRFcnJvciA9IChuYW1lLCBlcnJvciwgb3B0aW9ucykgPT4ge1xuICAgICAgICBjb25zdCByZWYgPSAoZ2V0KF9maWVsZHMsIG5hbWUsIHsgX2Y6IHt9IH0pLl9mIHx8IHt9KS5yZWY7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRFcnJvciA9IGdldChfZm9ybVN0YXRlLmVycm9ycywgbmFtZSkgfHwge307XG4gICAgICAgIC8vIERvbid0IG92ZXJyaWRlIGV4aXN0aW5nIGVycm9yIG1lc3NhZ2VzIGVsc2V3aGVyZSBpbiB0aGUgb2JqZWN0IHRyZWUuXG4gICAgICAgIGNvbnN0IHsgcmVmOiBjdXJyZW50UmVmLCBtZXNzYWdlLCB0eXBlLCAuLi5yZXN0T2ZFcnJvclRyZWUgfSA9IGN1cnJlbnRFcnJvcjtcbiAgICAgICAgc2V0KF9mb3JtU3RhdGUuZXJyb3JzLCBuYW1lLCB7XG4gICAgICAgICAgICAuLi5yZXN0T2ZFcnJvclRyZWUsXG4gICAgICAgICAgICAuLi5lcnJvcixcbiAgICAgICAgICAgIHJlZixcbiAgICAgICAgfSk7XG4gICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBlcnJvcnM6IF9mb3JtU3RhdGUuZXJyb3JzLFxuICAgICAgICAgICAgaXNWYWxpZDogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgICAgICBvcHRpb25zICYmIG9wdGlvbnMuc2hvdWxkRm9jdXMgJiYgcmVmICYmIHJlZi5mb2N1cyAmJiByZWYuZm9jdXMoKTtcbiAgICB9O1xuICAgIGNvbnN0IHdhdGNoID0gKG5hbWUsIGRlZmF1bHRWYWx1ZSkgPT4gaXNGdW5jdGlvbihuYW1lKVxuICAgICAgICA/IF9zdWJqZWN0cy5zdGF0ZS5zdWJzY3JpYmUoe1xuICAgICAgICAgICAgbmV4dDogKHBheWxvYWQpID0+ICd2YWx1ZXMnIGluIHBheWxvYWQgJiZcbiAgICAgICAgICAgICAgICBuYW1lKF9nZXRXYXRjaCh1bmRlZmluZWQsIGRlZmF1bHRWYWx1ZSksIHBheWxvYWQpLFxuICAgICAgICB9KVxuICAgICAgICA6IF9nZXRXYXRjaChuYW1lLCBkZWZhdWx0VmFsdWUsIHRydWUpO1xuICAgIGNvbnN0IF9zdWJzY3JpYmUgPSAocHJvcHMpID0+IF9zdWJqZWN0cy5zdGF0ZS5zdWJzY3JpYmUoe1xuICAgICAgICBuZXh0OiAoZm9ybVN0YXRlKSA9PiB7XG4gICAgICAgICAgICBpZiAoc2hvdWxkU3Vic2NyaWJlQnlOYW1lKHByb3BzLm5hbWUsIGZvcm1TdGF0ZS5uYW1lLCBwcm9wcy5leGFjdCkgJiZcbiAgICAgICAgICAgICAgICBzaG91bGRSZW5kZXJGb3JtU3RhdGUoZm9ybVN0YXRlLCBwcm9wcy5mb3JtU3RhdGUgfHwgX3Byb3h5Rm9ybVN0YXRlLCBfc2V0Rm9ybVN0YXRlLCBwcm9wcy5yZVJlbmRlclJvb3QpKSB7XG4gICAgICAgICAgICAgICAgcHJvcHMuY2FsbGJhY2soe1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IHsgLi4uX2Zvcm1WYWx1ZXMgfSxcbiAgICAgICAgICAgICAgICAgICAgLi4uX2Zvcm1TdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgLi4uZm9ybVN0YXRlLFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWVzOiBfZGVmYXVsdFZhbHVlcyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9KS51bnN1YnNjcmliZTtcbiAgICBjb25zdCBzdWJzY3JpYmUgPSAocHJvcHMpID0+IHtcbiAgICAgICAgX3N0YXRlLm1vdW50ID0gdHJ1ZTtcbiAgICAgICAgX3Byb3h5U3Vic2NyaWJlRm9ybVN0YXRlID0ge1xuICAgICAgICAgICAgLi4uX3Byb3h5U3Vic2NyaWJlRm9ybVN0YXRlLFxuICAgICAgICAgICAgLi4ucHJvcHMuZm9ybVN0YXRlLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3N1YnNjcmliZSh7XG4gICAgICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgICAgIGZvcm1TdGF0ZTogX3Byb3h5U3Vic2NyaWJlRm9ybVN0YXRlLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHVucmVnaXN0ZXIgPSAobmFtZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgZmllbGROYW1lIG9mIG5hbWUgPyBjb252ZXJ0VG9BcnJheVBheWxvYWQobmFtZSkgOiBfbmFtZXMubW91bnQpIHtcbiAgICAgICAgICAgIF9uYW1lcy5tb3VudC5kZWxldGUoZmllbGROYW1lKTtcbiAgICAgICAgICAgIF9uYW1lcy5hcnJheS5kZWxldGUoZmllbGROYW1lKTtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5rZWVwVmFsdWUpIHtcbiAgICAgICAgICAgICAgICB1bnNldChfZmllbGRzLCBmaWVsZE5hbWUpO1xuICAgICAgICAgICAgICAgIHVuc2V0KF9mb3JtVmFsdWVzLCBmaWVsZE5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgIW9wdGlvbnMua2VlcEVycm9yICYmIHVuc2V0KF9mb3JtU3RhdGUuZXJyb3JzLCBmaWVsZE5hbWUpO1xuICAgICAgICAgICAgIW9wdGlvbnMua2VlcERpcnR5ICYmIHVuc2V0KF9mb3JtU3RhdGUuZGlydHlGaWVsZHMsIGZpZWxkTmFtZSk7XG4gICAgICAgICAgICAhb3B0aW9ucy5rZWVwVG91Y2hlZCAmJiB1bnNldChfZm9ybVN0YXRlLnRvdWNoZWRGaWVsZHMsIGZpZWxkTmFtZSk7XG4gICAgICAgICAgICAhb3B0aW9ucy5rZWVwSXNWYWxpZGF0aW5nICYmXG4gICAgICAgICAgICAgICAgdW5zZXQoX2Zvcm1TdGF0ZS52YWxpZGF0aW5nRmllbGRzLCBmaWVsZE5hbWUpO1xuICAgICAgICAgICAgIV9vcHRpb25zLnNob3VsZFVucmVnaXN0ZXIgJiZcbiAgICAgICAgICAgICAgICAhb3B0aW9ucy5rZWVwRGVmYXVsdFZhbHVlICYmXG4gICAgICAgICAgICAgICAgdW5zZXQoX2RlZmF1bHRWYWx1ZXMsIGZpZWxkTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgdmFsdWVzOiBjbG9uZU9iamVjdChfZm9ybVZhbHVlcyksXG4gICAgICAgIH0pO1xuICAgICAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh7XG4gICAgICAgICAgICAuLi5fZm9ybVN0YXRlLFxuICAgICAgICAgICAgLi4uKCFvcHRpb25zLmtlZXBEaXJ0eSA/IHt9IDogeyBpc0RpcnR5OiBfZ2V0RGlydHkoKSB9KSxcbiAgICAgICAgfSk7XG4gICAgICAgICFvcHRpb25zLmtlZXBJc1ZhbGlkICYmIF9zZXRWYWxpZCgpO1xuICAgIH07XG4gICAgY29uc3QgX3NldERpc2FibGVkRmllbGQgPSAoeyBkaXNhYmxlZCwgbmFtZSwgfSkgPT4ge1xuICAgICAgICBpZiAoKGlzQm9vbGVhbihkaXNhYmxlZCkgJiYgX3N0YXRlLm1vdW50KSB8fFxuICAgICAgICAgICAgISFkaXNhYmxlZCB8fFxuICAgICAgICAgICAgX25hbWVzLmRpc2FibGVkLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgZGlzYWJsZWQgPyBfbmFtZXMuZGlzYWJsZWQuYWRkKG5hbWUpIDogX25hbWVzLmRpc2FibGVkLmRlbGV0ZShuYW1lKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcmVnaXN0ZXIgPSAobmFtZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgIGxldCBmaWVsZCA9IGdldChfZmllbGRzLCBuYW1lKTtcbiAgICAgICAgY29uc3QgZGlzYWJsZWRJc0RlZmluZWQgPSBpc0Jvb2xlYW4ob3B0aW9ucy5kaXNhYmxlZCkgfHwgaXNCb29sZWFuKF9vcHRpb25zLmRpc2FibGVkKTtcbiAgICAgICAgc2V0KF9maWVsZHMsIG5hbWUsIHtcbiAgICAgICAgICAgIC4uLihmaWVsZCB8fCB7fSksXG4gICAgICAgICAgICBfZjoge1xuICAgICAgICAgICAgICAgIC4uLihmaWVsZCAmJiBmaWVsZC5fZiA/IGZpZWxkLl9mIDogeyByZWY6IHsgbmFtZSB9IH0pLFxuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgbW91bnQ6IHRydWUsXG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBfbmFtZXMubW91bnQuYWRkKG5hbWUpO1xuICAgICAgICBpZiAoZmllbGQpIHtcbiAgICAgICAgICAgIF9zZXREaXNhYmxlZEZpZWxkKHtcbiAgICAgICAgICAgICAgICBkaXNhYmxlZDogaXNCb29sZWFuKG9wdGlvbnMuZGlzYWJsZWQpXG4gICAgICAgICAgICAgICAgICAgID8gb3B0aW9ucy5kaXNhYmxlZFxuICAgICAgICAgICAgICAgICAgICA6IF9vcHRpb25zLmRpc2FibGVkLFxuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVwZGF0ZVZhbGlkQW5kVmFsdWUobmFtZSwgdHJ1ZSwgb3B0aW9ucy52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLihkaXNhYmxlZElzRGVmaW5lZFxuICAgICAgICAgICAgICAgID8geyBkaXNhYmxlZDogb3B0aW9ucy5kaXNhYmxlZCB8fCBfb3B0aW9ucy5kaXNhYmxlZCB9XG4gICAgICAgICAgICAgICAgOiB7fSksXG4gICAgICAgICAgICAuLi4oX29wdGlvbnMucHJvZ3Jlc3NpdmVcbiAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6ICEhb3B0aW9ucy5yZXF1aXJlZCxcbiAgICAgICAgICAgICAgICAgICAgbWluOiBnZXRSdWxlVmFsdWUob3B0aW9ucy5taW4pLFxuICAgICAgICAgICAgICAgICAgICBtYXg6IGdldFJ1bGVWYWx1ZShvcHRpb25zLm1heCksXG4gICAgICAgICAgICAgICAgICAgIG1pbkxlbmd0aDogZ2V0UnVsZVZhbHVlKG9wdGlvbnMubWluTGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgICAgbWF4TGVuZ3RoOiBnZXRSdWxlVmFsdWUob3B0aW9ucy5tYXhMZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuOiBnZXRSdWxlVmFsdWUob3B0aW9ucy5wYXR0ZXJuKSxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgOiB7fSksXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgb25DaGFuZ2UsXG4gICAgICAgICAgICBvbkJsdXI6IG9uQ2hhbmdlLFxuICAgICAgICAgICAgcmVmOiAocmVmKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHJlZikge1xuICAgICAgICAgICAgICAgICAgICByZWdpc3RlcihuYW1lLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgZmllbGQgPSBnZXQoX2ZpZWxkcywgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkUmVmID0gaXNVbmRlZmluZWQocmVmLnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyByZWYucXVlcnlTZWxlY3RvckFsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gcmVmLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0LHNlbGVjdCx0ZXh0YXJlYScpWzBdIHx8IHJlZlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogcmVmXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHJlZjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmFkaW9PckNoZWNrYm94ID0gaXNSYWRpb09yQ2hlY2tib3goZmllbGRSZWYpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWZzID0gZmllbGQuX2YucmVmcyB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhZGlvT3JDaGVja2JveFxuICAgICAgICAgICAgICAgICAgICAgICAgPyByZWZzLmZpbmQoKG9wdGlvbikgPT4gb3B0aW9uID09PSBmaWVsZFJlZilcbiAgICAgICAgICAgICAgICAgICAgICAgIDogZmllbGRSZWYgPT09IGZpZWxkLl9mLnJlZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNldChfZmllbGRzLCBuYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmZpZWxkLl9mLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLihyYWRpb09yQ2hlY2tib3hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4ucmVmcy5maWx0ZXIobGl2ZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRSZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uKEFycmF5LmlzQXJyYXkoZ2V0KF9kZWZhdWx0VmFsdWVzLCBuYW1lKSkgPyBbe31dIDogW10pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZjogeyB0eXBlOiBmaWVsZFJlZi50eXBlLCBuYW1lIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB7IHJlZjogZmllbGRSZWYgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlVmFsaWRBbmRWYWx1ZShuYW1lLCBmYWxzZSwgdW5kZWZpbmVkLCBmaWVsZFJlZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZCA9IGdldChfZmllbGRzLCBuYW1lLCB7fSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZC5fZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQuX2YubW91bnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAoX29wdGlvbnMuc2hvdWxkVW5yZWdpc3RlciB8fCBvcHRpb25zLnNob3VsZFVucmVnaXN0ZXIpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhKGlzTmFtZUluRmllbGRBcnJheShfbmFtZXMuYXJyYXksIG5hbWUpICYmIF9zdGF0ZS5hY3Rpb24pICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBfbmFtZXMudW5Nb3VudC5hZGQobmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IF9mb2N1c0Vycm9yID0gKCkgPT4gX29wdGlvbnMuc2hvdWxkRm9jdXNFcnJvciAmJlxuICAgICAgICBpdGVyYXRlRmllbGRzQnlBY3Rpb24oX2ZpZWxkcywgX2ZvY3VzSW5wdXQsIF9uYW1lcy5tb3VudCk7XG4gICAgY29uc3QgX2Rpc2FibGVGb3JtID0gKGRpc2FibGVkKSA9PiB7XG4gICAgICAgIGlmIChpc0Jvb2xlYW4oZGlzYWJsZWQpKSB7XG4gICAgICAgICAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh7IGRpc2FibGVkIH0pO1xuICAgICAgICAgICAgaXRlcmF0ZUZpZWxkc0J5QWN0aW9uKF9maWVsZHMsIChyZWYsIG5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50RmllbGQgPSBnZXQoX2ZpZWxkcywgbmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRGaWVsZCkge1xuICAgICAgICAgICAgICAgICAgICByZWYuZGlzYWJsZWQgPSBjdXJyZW50RmllbGQuX2YuZGlzYWJsZWQgfHwgZGlzYWJsZWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnRGaWVsZC5fZi5yZWZzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEZpZWxkLl9mLnJlZnMuZm9yRWFjaCgoaW5wdXRSZWYpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFJlZi5kaXNhYmxlZCA9IGN1cnJlbnRGaWVsZC5fZi5kaXNhYmxlZCB8fCBkaXNhYmxlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgMCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVTdWJtaXQgPSAob25WYWxpZCwgb25JbnZhbGlkKSA9PiBhc3luYyAoZSkgPT4ge1xuICAgICAgICBsZXQgb25WYWxpZEVycm9yID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCAmJiBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBlLnBlcnNpc3QgJiZcbiAgICAgICAgICAgICAgICBlLnBlcnNpc3QoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZmllbGRWYWx1ZXMgPSBjbG9uZU9iamVjdChfZm9ybVZhbHVlcyk7XG4gICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgIGlzU3VibWl0dGluZzogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChfb3B0aW9ucy5yZXNvbHZlcikge1xuICAgICAgICAgICAgY29uc3QgeyBlcnJvcnMsIHZhbHVlcyB9ID0gYXdhaXQgX3J1blNjaGVtYSgpO1xuICAgICAgICAgICAgX2Zvcm1TdGF0ZS5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICAgICAgICBmaWVsZFZhbHVlcyA9IGNsb25lT2JqZWN0KHZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhd2FpdCBleGVjdXRlQnVpbHRJblZhbGlkYXRpb24oX2ZpZWxkcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9uYW1lcy5kaXNhYmxlZC5zaXplKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgX25hbWVzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgdW5zZXQoZmllbGRWYWx1ZXMsIG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHVuc2V0KF9mb3JtU3RhdGUuZXJyb3JzLCAncm9vdCcpO1xuICAgICAgICBpZiAoaXNFbXB0eU9iamVjdChfZm9ybVN0YXRlLmVycm9ycykpIHtcbiAgICAgICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgICAgICBlcnJvcnM6IHt9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IG9uVmFsaWQoZmllbGRWYWx1ZXMsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgb25WYWxpZEVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAob25JbnZhbGlkKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgb25JbnZhbGlkKHsgLi4uX2Zvcm1TdGF0ZS5lcnJvcnMgfSwgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfZm9jdXNFcnJvcigpO1xuICAgICAgICAgICAgc2V0VGltZW91dChfZm9jdXNFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgaXNTdWJtaXR0ZWQ6IHRydWUsXG4gICAgICAgICAgICBpc1N1Ym1pdHRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgaXNTdWJtaXRTdWNjZXNzZnVsOiBpc0VtcHR5T2JqZWN0KF9mb3JtU3RhdGUuZXJyb3JzKSAmJiAhb25WYWxpZEVycm9yLFxuICAgICAgICAgICAgc3VibWl0Q291bnQ6IF9mb3JtU3RhdGUuc3VibWl0Q291bnQgKyAxLFxuICAgICAgICAgICAgZXJyb3JzOiBfZm9ybVN0YXRlLmVycm9ycyxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChvblZhbGlkRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG9uVmFsaWRFcnJvcjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcmVzZXRGaWVsZCA9IChuYW1lLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgaWYgKGdldChfZmllbGRzLCBuYW1lKSkge1xuICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKG9wdGlvbnMuZGVmYXVsdFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHNldFZhbHVlKG5hbWUsIGNsb25lT2JqZWN0KGdldChfZGVmYXVsdFZhbHVlcywgbmFtZSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldFZhbHVlKG5hbWUsIG9wdGlvbnMuZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgICAgICAgICBzZXQoX2RlZmF1bHRWYWx1ZXMsIG5hbWUsIGNsb25lT2JqZWN0KG9wdGlvbnMuZGVmYXVsdFZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMua2VlcFRvdWNoZWQpIHtcbiAgICAgICAgICAgICAgICB1bnNldChfZm9ybVN0YXRlLnRvdWNoZWRGaWVsZHMsIG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmtlZXBEaXJ0eSkge1xuICAgICAgICAgICAgICAgIHVuc2V0KF9mb3JtU3RhdGUuZGlydHlGaWVsZHMsIG5hbWUpO1xuICAgICAgICAgICAgICAgIF9mb3JtU3RhdGUuaXNEaXJ0eSA9IG9wdGlvbnMuZGVmYXVsdFZhbHVlXG4gICAgICAgICAgICAgICAgICAgID8gX2dldERpcnR5KG5hbWUsIGNsb25lT2JqZWN0KGdldChfZGVmYXVsdFZhbHVlcywgbmFtZSkpKVxuICAgICAgICAgICAgICAgICAgICA6IF9nZXREaXJ0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmtlZXBFcnJvcikge1xuICAgICAgICAgICAgICAgIHVuc2V0KF9mb3JtU3RhdGUuZXJyb3JzLCBuYW1lKTtcbiAgICAgICAgICAgICAgICBfcHJveHlGb3JtU3RhdGUuaXNWYWxpZCAmJiBfc2V0VmFsaWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHsgLi4uX2Zvcm1TdGF0ZSB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgX3Jlc2V0ID0gKGZvcm1WYWx1ZXMsIGtlZXBTdGF0ZU9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICBjb25zdCB1cGRhdGVkVmFsdWVzID0gZm9ybVZhbHVlcyA/IGNsb25lT2JqZWN0KGZvcm1WYWx1ZXMpIDogX2RlZmF1bHRWYWx1ZXM7XG4gICAgICAgIGNvbnN0IGNsb25lVXBkYXRlZFZhbHVlcyA9IGNsb25lT2JqZWN0KHVwZGF0ZWRWYWx1ZXMpO1xuICAgICAgICBjb25zdCBpc0VtcHR5UmVzZXRWYWx1ZXMgPSBpc0VtcHR5T2JqZWN0KGZvcm1WYWx1ZXMpO1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBpc0VtcHR5UmVzZXRWYWx1ZXMgPyBfZGVmYXVsdFZhbHVlcyA6IGNsb25lVXBkYXRlZFZhbHVlcztcbiAgICAgICAgaWYgKCFrZWVwU3RhdGVPcHRpb25zLmtlZXBEZWZhdWx0VmFsdWVzKSB7XG4gICAgICAgICAgICBfZGVmYXVsdFZhbHVlcyA9IHVwZGF0ZWRWYWx1ZXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFrZWVwU3RhdGVPcHRpb25zLmtlZXBWYWx1ZXMpIHtcbiAgICAgICAgICAgIGlmIChrZWVwU3RhdGVPcHRpb25zLmtlZXBEaXJ0eVZhbHVlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkc1RvQ2hlY2sgPSBuZXcgU2V0KFtcbiAgICAgICAgICAgICAgICAgICAgLi4uX25hbWVzLm1vdW50LFxuICAgICAgICAgICAgICAgICAgICAuLi5PYmplY3Qua2V5cyhnZXREaXJ0eUZpZWxkcyhfZGVmYXVsdFZhbHVlcywgX2Zvcm1WYWx1ZXMpKSxcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGZpZWxkTmFtZSBvZiBBcnJheS5mcm9tKGZpZWxkc1RvQ2hlY2spKSB7XG4gICAgICAgICAgICAgICAgICAgIGdldChfZm9ybVN0YXRlLmRpcnR5RmllbGRzLCBmaWVsZE5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHNldCh2YWx1ZXMsIGZpZWxkTmFtZSwgZ2V0KF9mb3JtVmFsdWVzLCBmaWVsZE5hbWUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBzZXRWYWx1ZShmaWVsZE5hbWUsIGdldCh2YWx1ZXMsIGZpZWxkTmFtZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpc1dlYiAmJiBpc1VuZGVmaW5lZChmb3JtVmFsdWVzKSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgX25hbWVzLm1vdW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWVsZCA9IGdldChfZmllbGRzLCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZCAmJiBmaWVsZC5fZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkUmVmZXJlbmNlID0gQXJyYXkuaXNBcnJheShmaWVsZC5fZi5yZWZzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGZpZWxkLl9mLnJlZnNbMF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBmaWVsZC5fZi5yZWY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzSFRNTEVsZW1lbnQoZmllbGRSZWZlcmVuY2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZvcm0gPSBmaWVsZFJlZmVyZW5jZS5jbG9zZXN0KCdmb3JtJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmb3JtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoa2VlcFN0YXRlT3B0aW9ucy5rZWVwRmllbGRzUmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZmllbGROYW1lIG9mIF9uYW1lcy5tb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWUoZmllbGROYW1lLCBnZXQodmFsdWVzLCBmaWVsZE5hbWUpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX2ZpZWxkcyA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9mb3JtVmFsdWVzID0gX29wdGlvbnMuc2hvdWxkVW5yZWdpc3RlclxuICAgICAgICAgICAgICAgID8ga2VlcFN0YXRlT3B0aW9ucy5rZWVwRGVmYXVsdFZhbHVlc1xuICAgICAgICAgICAgICAgICAgICA/IGNsb25lT2JqZWN0KF9kZWZhdWx0VmFsdWVzKVxuICAgICAgICAgICAgICAgICAgICA6IHt9XG4gICAgICAgICAgICAgICAgOiBjbG9uZU9iamVjdCh2YWx1ZXMpO1xuICAgICAgICAgICAgX3N1YmplY3RzLmFycmF5Lm5leHQoe1xuICAgICAgICAgICAgICAgIHZhbHVlczogeyAuLi52YWx1ZXMgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgICAgIHZhbHVlczogeyAuLi52YWx1ZXMgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIF9uYW1lcyA9IHtcbiAgICAgICAgICAgIG1vdW50OiBrZWVwU3RhdGVPcHRpb25zLmtlZXBEaXJ0eVZhbHVlcyA/IF9uYW1lcy5tb3VudCA6IG5ldyBTZXQoKSxcbiAgICAgICAgICAgIHVuTW91bnQ6IG5ldyBTZXQoKSxcbiAgICAgICAgICAgIGFycmF5OiBuZXcgU2V0KCksXG4gICAgICAgICAgICBkaXNhYmxlZDogbmV3IFNldCgpLFxuICAgICAgICAgICAgd2F0Y2g6IG5ldyBTZXQoKSxcbiAgICAgICAgICAgIHdhdGNoQWxsOiBmYWxzZSxcbiAgICAgICAgICAgIGZvY3VzOiAnJyxcbiAgICAgICAgfTtcbiAgICAgICAgX3N0YXRlLm1vdW50ID1cbiAgICAgICAgICAgICFfcHJveHlGb3JtU3RhdGUuaXNWYWxpZCB8fFxuICAgICAgICAgICAgICAgICEha2VlcFN0YXRlT3B0aW9ucy5rZWVwSXNWYWxpZCB8fFxuICAgICAgICAgICAgICAgICEha2VlcFN0YXRlT3B0aW9ucy5rZWVwRGlydHlWYWx1ZXMgfHxcbiAgICAgICAgICAgICAgICAoIV9vcHRpb25zLnNob3VsZFVucmVnaXN0ZXIgJiYgIWlzRW1wdHlPYmplY3QodmFsdWVzKSk7XG4gICAgICAgIF9zdGF0ZS53YXRjaCA9ICEhX29wdGlvbnMuc2hvdWxkVW5yZWdpc3RlcjtcbiAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgc3VibWl0Q291bnQ6IGtlZXBTdGF0ZU9wdGlvbnMua2VlcFN1Ym1pdENvdW50XG4gICAgICAgICAgICAgICAgPyBfZm9ybVN0YXRlLnN1Ym1pdENvdW50XG4gICAgICAgICAgICAgICAgOiAwLFxuICAgICAgICAgICAgaXNEaXJ0eTogaXNFbXB0eVJlc2V0VmFsdWVzXG4gICAgICAgICAgICAgICAgPyBmYWxzZVxuICAgICAgICAgICAgICAgIDoga2VlcFN0YXRlT3B0aW9ucy5rZWVwRGlydHlcbiAgICAgICAgICAgICAgICAgICAgPyBfZm9ybVN0YXRlLmlzRGlydHlcbiAgICAgICAgICAgICAgICAgICAgOiAhIShrZWVwU3RhdGVPcHRpb25zLmtlZXBEZWZhdWx0VmFsdWVzICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhZGVlcEVxdWFsKGZvcm1WYWx1ZXMsIF9kZWZhdWx0VmFsdWVzKSksXG4gICAgICAgICAgICBpc1N1Ym1pdHRlZDoga2VlcFN0YXRlT3B0aW9ucy5rZWVwSXNTdWJtaXR0ZWRcbiAgICAgICAgICAgICAgICA/IF9mb3JtU3RhdGUuaXNTdWJtaXR0ZWRcbiAgICAgICAgICAgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgZGlydHlGaWVsZHM6IGlzRW1wdHlSZXNldFZhbHVlc1xuICAgICAgICAgICAgICAgID8ge31cbiAgICAgICAgICAgICAgICA6IGtlZXBTdGF0ZU9wdGlvbnMua2VlcERpcnR5VmFsdWVzXG4gICAgICAgICAgICAgICAgICAgID8ga2VlcFN0YXRlT3B0aW9ucy5rZWVwRGVmYXVsdFZhbHVlcyAmJiBfZm9ybVZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBnZXREaXJ0eUZpZWxkcyhfZGVmYXVsdFZhbHVlcywgX2Zvcm1WYWx1ZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IF9mb3JtU3RhdGUuZGlydHlGaWVsZHNcbiAgICAgICAgICAgICAgICAgICAgOiBrZWVwU3RhdGVPcHRpb25zLmtlZXBEZWZhdWx0VmFsdWVzICYmIGZvcm1WYWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgID8gZ2V0RGlydHlGaWVsZHMoX2RlZmF1bHRWYWx1ZXMsIGZvcm1WYWx1ZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGtlZXBTdGF0ZU9wdGlvbnMua2VlcERpcnR5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBfZm9ybVN0YXRlLmRpcnR5RmllbGRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB7fSxcbiAgICAgICAgICAgIHRvdWNoZWRGaWVsZHM6IGtlZXBTdGF0ZU9wdGlvbnMua2VlcFRvdWNoZWRcbiAgICAgICAgICAgICAgICA/IF9mb3JtU3RhdGUudG91Y2hlZEZpZWxkc1xuICAgICAgICAgICAgICAgIDoge30sXG4gICAgICAgICAgICBlcnJvcnM6IGtlZXBTdGF0ZU9wdGlvbnMua2VlcEVycm9ycyA/IF9mb3JtU3RhdGUuZXJyb3JzIDoge30sXG4gICAgICAgICAgICBpc1N1Ym1pdFN1Y2Nlc3NmdWw6IGtlZXBTdGF0ZU9wdGlvbnMua2VlcElzU3VibWl0U3VjY2Vzc2Z1bFxuICAgICAgICAgICAgICAgID8gX2Zvcm1TdGF0ZS5pc1N1Ym1pdFN1Y2Nlc3NmdWxcbiAgICAgICAgICAgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgaXNTdWJtaXR0aW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZXM6IF9kZWZhdWx0VmFsdWVzLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHJlc2V0ID0gKGZvcm1WYWx1ZXMsIGtlZXBTdGF0ZU9wdGlvbnMpID0+IF9yZXNldChpc0Z1bmN0aW9uKGZvcm1WYWx1ZXMpXG4gICAgICAgID8gZm9ybVZhbHVlcyhfZm9ybVZhbHVlcylcbiAgICAgICAgOiBmb3JtVmFsdWVzLCBrZWVwU3RhdGVPcHRpb25zKTtcbiAgICBjb25zdCBzZXRGb2N1cyA9IChuYW1lLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgY29uc3QgZmllbGQgPSBnZXQoX2ZpZWxkcywgbmFtZSk7XG4gICAgICAgIGNvbnN0IGZpZWxkUmVmZXJlbmNlID0gZmllbGQgJiYgZmllbGQuX2Y7XG4gICAgICAgIGlmIChmaWVsZFJlZmVyZW5jZSkge1xuICAgICAgICAgICAgY29uc3QgZmllbGRSZWYgPSBmaWVsZFJlZmVyZW5jZS5yZWZzXG4gICAgICAgICAgICAgICAgPyBmaWVsZFJlZmVyZW5jZS5yZWZzWzBdXG4gICAgICAgICAgICAgICAgOiBmaWVsZFJlZmVyZW5jZS5yZWY7XG4gICAgICAgICAgICBpZiAoZmllbGRSZWYuZm9jdXMpIHtcbiAgICAgICAgICAgICAgICBmaWVsZFJlZi5mb2N1cygpO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuc2hvdWxkU2VsZWN0ICYmXG4gICAgICAgICAgICAgICAgICAgIGlzRnVuY3Rpb24oZmllbGRSZWYuc2VsZWN0KSAmJlxuICAgICAgICAgICAgICAgICAgICBmaWVsZFJlZi5zZWxlY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgX3NldEZvcm1TdGF0ZSA9ICh1cGRhdGVkRm9ybVN0YXRlKSA9PiB7XG4gICAgICAgIF9mb3JtU3RhdGUgPSB7XG4gICAgICAgICAgICAuLi5fZm9ybVN0YXRlLFxuICAgICAgICAgICAgLi4udXBkYXRlZEZvcm1TdGF0ZSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IF9yZXNldERlZmF1bHRWYWx1ZXMgPSAoKSA9PiBpc0Z1bmN0aW9uKF9vcHRpb25zLmRlZmF1bHRWYWx1ZXMpICYmXG4gICAgICAgIF9vcHRpb25zLmRlZmF1bHRWYWx1ZXMoKS50aGVuKCh2YWx1ZXMpID0+IHtcbiAgICAgICAgICAgIHJlc2V0KHZhbHVlcywgX29wdGlvbnMucmVzZXRPcHRpb25zKTtcbiAgICAgICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIGNvbnN0IG1ldGhvZHMgPSB7XG4gICAgICAgIGNvbnRyb2w6IHtcbiAgICAgICAgICAgIHJlZ2lzdGVyLFxuICAgICAgICAgICAgdW5yZWdpc3RlcixcbiAgICAgICAgICAgIGdldEZpZWxkU3RhdGUsXG4gICAgICAgICAgICBoYW5kbGVTdWJtaXQsXG4gICAgICAgICAgICBzZXRFcnJvcixcbiAgICAgICAgICAgIF9zdWJzY3JpYmUsXG4gICAgICAgICAgICBfcnVuU2NoZW1hLFxuICAgICAgICAgICAgX2ZvY3VzRXJyb3IsXG4gICAgICAgICAgICBfZ2V0V2F0Y2gsXG4gICAgICAgICAgICBfZ2V0RGlydHksXG4gICAgICAgICAgICBfc2V0VmFsaWQsXG4gICAgICAgICAgICBfc2V0RmllbGRBcnJheSxcbiAgICAgICAgICAgIF9zZXREaXNhYmxlZEZpZWxkLFxuICAgICAgICAgICAgX3NldEVycm9ycyxcbiAgICAgICAgICAgIF9nZXRGaWVsZEFycmF5LFxuICAgICAgICAgICAgX3Jlc2V0LFxuICAgICAgICAgICAgX3Jlc2V0RGVmYXVsdFZhbHVlcyxcbiAgICAgICAgICAgIF9yZW1vdmVVbm1vdW50ZWQsXG4gICAgICAgICAgICBfZGlzYWJsZUZvcm0sXG4gICAgICAgICAgICBfc3ViamVjdHMsXG4gICAgICAgICAgICBfcHJveHlGb3JtU3RhdGUsXG4gICAgICAgICAgICBnZXQgX2ZpZWxkcygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZpZWxkcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQgX2Zvcm1WYWx1ZXMoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mb3JtVmFsdWVzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBfc3RhdGUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zdGF0ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQgX3N0YXRlKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgX3N0YXRlID0gdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IF9kZWZhdWx0VmFsdWVzKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZGVmYXVsdFZhbHVlcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQgX25hbWVzKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfbmFtZXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0IF9uYW1lcyh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIF9uYW1lcyA9IHZhbHVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBfZm9ybVN0YXRlKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZm9ybVN0YXRlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBfb3B0aW9ucygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX29wdGlvbnM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0IF9vcHRpb25zKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgX29wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIC4uLl9vcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAuLi52YWx1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICB0cmlnZ2VyLFxuICAgICAgICByZWdpc3RlcixcbiAgICAgICAgaGFuZGxlU3VibWl0LFxuICAgICAgICB3YXRjaCxcbiAgICAgICAgc2V0VmFsdWUsXG4gICAgICAgIGdldFZhbHVlcyxcbiAgICAgICAgcmVzZXQsXG4gICAgICAgIHJlc2V0RmllbGQsXG4gICAgICAgIGNsZWFyRXJyb3JzLFxuICAgICAgICB1bnJlZ2lzdGVyLFxuICAgICAgICBzZXRFcnJvcixcbiAgICAgICAgc2V0Rm9jdXMsXG4gICAgICAgIGdldEZpZWxkU3RhdGUsXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5tZXRob2RzLFxuICAgICAgICBmb3JtQ29udHJvbDogbWV0aG9kcyxcbiAgICB9O1xufVxuXG52YXIgZ2VuZXJhdGVJZCA9ICgpID0+IHtcbiAgICBpZiAodHlwZW9mIGNyeXB0byAhPT0gJ3VuZGVmaW5lZCcgJiYgY3J5cHRvLnJhbmRvbVVVSUQpIHtcbiAgICAgICAgcmV0dXJuIGNyeXB0by5yYW5kb21VVUlEKCk7XG4gICAgfVxuICAgIGNvbnN0IGQgPSB0eXBlb2YgcGVyZm9ybWFuY2UgPT09ICd1bmRlZmluZWQnID8gRGF0ZS5ub3coKSA6IHBlcmZvcm1hbmNlLm5vdygpICogMTAwMDtcbiAgICByZXR1cm4gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCAoYykgPT4ge1xuICAgICAgICBjb25zdCByID0gKE1hdGgucmFuZG9tKCkgKiAxNiArIGQpICUgMTYgfCAwO1xuICAgICAgICByZXR1cm4gKGMgPT0gJ3gnID8gciA6IChyICYgMHgzKSB8IDB4OCkudG9TdHJpbmcoMTYpO1xuICAgIH0pO1xufTtcblxudmFyIGdldEZvY3VzRmllbGROYW1lID0gKG5hbWUsIGluZGV4LCBvcHRpb25zID0ge30pID0+IG9wdGlvbnMuc2hvdWxkRm9jdXMgfHwgaXNVbmRlZmluZWQob3B0aW9ucy5zaG91bGRGb2N1cylcbiAgICA/IG9wdGlvbnMuZm9jdXNOYW1lIHx8XG4gICAgICAgIGAke25hbWV9LiR7aXNVbmRlZmluZWQob3B0aW9ucy5mb2N1c0luZGV4KSA/IGluZGV4IDogb3B0aW9ucy5mb2N1c0luZGV4fS5gXG4gICAgOiAnJztcblxudmFyIGFwcGVuZEF0ID0gKGRhdGEsIHZhbHVlKSA9PiBbXG4gICAgLi4uZGF0YSxcbiAgICAuLi5jb252ZXJ0VG9BcnJheVBheWxvYWQodmFsdWUpLFxuXTtcblxudmFyIGZpbGxFbXB0eUFycmF5ID0gKHZhbHVlKSA9PiBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLm1hcCgoKSA9PiB1bmRlZmluZWQpIDogdW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpbnNlcnQoZGF0YSwgaW5kZXgsIHZhbHVlKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgLi4uZGF0YS5zbGljZSgwLCBpbmRleCksXG4gICAgICAgIC4uLmNvbnZlcnRUb0FycmF5UGF5bG9hZCh2YWx1ZSksXG4gICAgICAgIC4uLmRhdGEuc2xpY2UoaW5kZXgpLFxuICAgIF07XG59XG5cbnZhciBtb3ZlQXJyYXlBdCA9IChkYXRhLCBmcm9tLCB0bykgPT4ge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGlmIChpc1VuZGVmaW5lZChkYXRhW3RvXSkpIHtcbiAgICAgICAgZGF0YVt0b10gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGRhdGEuc3BsaWNlKHRvLCAwLCBkYXRhLnNwbGljZShmcm9tLCAxKVswXSk7XG4gICAgcmV0dXJuIGRhdGE7XG59O1xuXG52YXIgcHJlcGVuZEF0ID0gKGRhdGEsIHZhbHVlKSA9PiBbXG4gICAgLi4uY29udmVydFRvQXJyYXlQYXlsb2FkKHZhbHVlKSxcbiAgICAuLi5jb252ZXJ0VG9BcnJheVBheWxvYWQoZGF0YSksXG5dO1xuXG5mdW5jdGlvbiByZW1vdmVBdEluZGV4ZXMoZGF0YSwgaW5kZXhlcykge1xuICAgIGxldCBpID0gMDtcbiAgICBjb25zdCB0ZW1wID0gWy4uLmRhdGFdO1xuICAgIGZvciAoY29uc3QgaW5kZXggb2YgaW5kZXhlcykge1xuICAgICAgICB0ZW1wLnNwbGljZShpbmRleCAtIGksIDEpO1xuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiBjb21wYWN0KHRlbXApLmxlbmd0aCA/IHRlbXAgOiBbXTtcbn1cbnZhciByZW1vdmVBcnJheUF0ID0gKGRhdGEsIGluZGV4KSA9PiBpc1VuZGVmaW5lZChpbmRleClcbiAgICA/IFtdXG4gICAgOiByZW1vdmVBdEluZGV4ZXMoZGF0YSwgY29udmVydFRvQXJyYXlQYXlsb2FkKGluZGV4KS5zb3J0KChhLCBiKSA9PiBhIC0gYikpO1xuXG52YXIgc3dhcEFycmF5QXQgPSAoZGF0YSwgaW5kZXhBLCBpbmRleEIpID0+IHtcbiAgICBbZGF0YVtpbmRleEFdLCBkYXRhW2luZGV4Ql1dID0gW2RhdGFbaW5kZXhCXSwgZGF0YVtpbmRleEFdXTtcbn07XG5cbnZhciB1cGRhdGVBdCA9IChmaWVsZFZhbHVlcywgaW5kZXgsIHZhbHVlKSA9PiB7XG4gICAgZmllbGRWYWx1ZXNbaW5kZXhdID0gdmFsdWU7XG4gICAgcmV0dXJuIGZpZWxkVmFsdWVzO1xufTtcblxuLyoqXG4gKiBBIGN1c3RvbSBob29rIHRoYXQgZXhwb3NlcyBjb252ZW5pZW50IG1ldGhvZHMgdG8gcGVyZm9ybSBvcGVyYXRpb25zIHdpdGggYSBsaXN0IG9mIGR5bmFtaWMgaW5wdXRzIHRoYXQgbmVlZCB0byBiZSBhcHBlbmRlZCwgdXBkYXRlZCwgcmVtb3ZlZCBldGMuIOKAoiBbRGVtb10oaHR0cHM6Ly9jb2Rlc2FuZGJveC5pby9zL3JlYWN0LWhvb2stZm9ybS11c2VmaWVsZGFycmF5LXNzdWduKSDigKIgW1ZpZGVvXShodHRwczovL3lvdXR1LmJlLzRNcmJmR1NGWTJBKVxuICpcbiAqIEByZW1hcmtzXG4gKiBbQVBJXShodHRwczovL3JlYWN0LWhvb2stZm9ybS5jb20vZG9jcy91c2VmaWVsZGFycmF5KSDigKIgW0RlbW9dKGh0dHBzOi8vY29kZXNhbmRib3guaW8vcy9yZWFjdC1ob29rLWZvcm0tdXNlZmllbGRhcnJheS1zc3VnbilcbiAqXG4gKiBAcGFyYW0gcHJvcHMgLSB1c2VGaWVsZEFycmF5IHByb3BzXG4gKlxuICogQHJldHVybnMgbWV0aG9kcyAtIGZ1bmN0aW9ucyB0byBtYW5pcHVsYXRlIHdpdGggdGhlIEZpZWxkIEFycmF5cyAoZHluYW1pYyBpbnB1dHMpIHtAbGluayBVc2VGaWVsZEFycmF5UmV0dXJufVxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c3hcbiAqIGZ1bmN0aW9uIEFwcCgpIHtcbiAqICAgY29uc3QgeyByZWdpc3RlciwgY29udHJvbCwgaGFuZGxlU3VibWl0LCByZXNldCwgdHJpZ2dlciwgc2V0RXJyb3IgfSA9IHVzZUZvcm0oe1xuICogICAgIGRlZmF1bHRWYWx1ZXM6IHtcbiAqICAgICAgIHRlc3Q6IFtdXG4gKiAgICAgfVxuICogICB9KTtcbiAqICAgY29uc3QgeyBmaWVsZHMsIGFwcGVuZCB9ID0gdXNlRmllbGRBcnJheSh7XG4gKiAgICAgY29udHJvbCxcbiAqICAgICBuYW1lOiBcInRlc3RcIlxuICogICB9KTtcbiAqXG4gKiAgIHJldHVybiAoXG4gKiAgICAgPGZvcm0gb25TdWJtaXQ9e2hhbmRsZVN1Ym1pdChkYXRhID0+IGNvbnNvbGUubG9nKGRhdGEpKX0+XG4gKiAgICAgICB7ZmllbGRzLm1hcCgoaXRlbSwgaW5kZXgpID0+IChcbiAqICAgICAgICAgIDxpbnB1dCBrZXk9e2l0ZW0uaWR9IHsuLi5yZWdpc3RlcihgdGVzdC4ke2luZGV4fS5maXJzdE5hbWVgKX0gIC8+XG4gKiAgICAgICApKX1cbiAqICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIG9uQ2xpY2s9eygpID0+IGFwcGVuZCh7IGZpcnN0TmFtZTogXCJiaWxsXCIgfSl9PlxuICogICAgICAgICBhcHBlbmRcbiAqICAgICAgIDwvYnV0dG9uPlxuICogICAgICAgPGlucHV0IHR5cGU9XCJzdWJtaXRcIiAvPlxuICogICAgIDwvZm9ybT5cbiAqICAgKTtcbiAqIH1cbiAqIGBgYFxuICovXG5mdW5jdGlvbiB1c2VGaWVsZEFycmF5KHByb3BzKSB7XG4gICAgY29uc3QgbWV0aG9kcyA9IHVzZUZvcm1Db250ZXh0KCk7XG4gICAgY29uc3QgeyBjb250cm9sID0gbWV0aG9kcy5jb250cm9sLCBuYW1lLCBrZXlOYW1lID0gJ2lkJywgc2hvdWxkVW5yZWdpc3RlciwgcnVsZXMsIH0gPSBwcm9wcztcbiAgICBjb25zdCBbZmllbGRzLCBzZXRGaWVsZHNdID0gUmVhY3QudXNlU3RhdGUoY29udHJvbC5fZ2V0RmllbGRBcnJheShuYW1lKSk7XG4gICAgY29uc3QgaWRzID0gUmVhY3QudXNlUmVmKGNvbnRyb2wuX2dldEZpZWxkQXJyYXkobmFtZSkubWFwKGdlbmVyYXRlSWQpKTtcbiAgICBjb25zdCBfYWN0aW9uZWQgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICAgIGNvbnRyb2wuX25hbWVzLmFycmF5LmFkZChuYW1lKTtcbiAgICBSZWFjdC51c2VNZW1vKCgpID0+IHJ1bGVzICYmXG4gICAgICAgIGZpZWxkcy5sZW5ndGggPj0gMCAmJlxuICAgICAgICBjb250cm9sLnJlZ2lzdGVyKG5hbWUsIHJ1bGVzKSwgW2NvbnRyb2wsIG5hbWUsIGZpZWxkcy5sZW5ndGgsIHJ1bGVzXSk7XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiBjb250cm9sLl9zdWJqZWN0cy5hcnJheS5zdWJzY3JpYmUoe1xuICAgICAgICBuZXh0OiAoeyB2YWx1ZXMsIG5hbWU6IGZpZWxkQXJyYXlOYW1lLCB9KSA9PiB7XG4gICAgICAgICAgICBpZiAoZmllbGRBcnJheU5hbWUgPT09IG5hbWUgfHwgIWZpZWxkQXJyYXlOYW1lKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGRWYWx1ZXMgPSBnZXQodmFsdWVzLCBuYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmaWVsZFZhbHVlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0RmllbGRzKGZpZWxkVmFsdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgaWRzLmN1cnJlbnQgPSBmaWVsZFZhbHVlcy5tYXAoZ2VuZXJhdGVJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH0pLnVuc3Vic2NyaWJlLCBbY29udHJvbCwgbmFtZV0pO1xuICAgIGNvbnN0IHVwZGF0ZVZhbHVlcyA9IFJlYWN0LnVzZUNhbGxiYWNrKCh1cGRhdGVkRmllbGRBcnJheVZhbHVlcykgPT4ge1xuICAgICAgICBfYWN0aW9uZWQuY3VycmVudCA9IHRydWU7XG4gICAgICAgIGNvbnRyb2wuX3NldEZpZWxkQXJyYXkobmFtZSwgdXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMpO1xuICAgIH0sIFtjb250cm9sLCBuYW1lXSk7XG4gICAgY29uc3QgYXBwZW5kID0gKHZhbHVlLCBvcHRpb25zKSA9PiB7XG4gICAgICAgIGNvbnN0IGFwcGVuZFZhbHVlID0gY29udmVydFRvQXJyYXlQYXlsb2FkKGNsb25lT2JqZWN0KHZhbHVlKSk7XG4gICAgICAgIGNvbnN0IHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzID0gYXBwZW5kQXQoY29udHJvbC5fZ2V0RmllbGRBcnJheShuYW1lKSwgYXBwZW5kVmFsdWUpO1xuICAgICAgICBjb250cm9sLl9uYW1lcy5mb2N1cyA9IGdldEZvY3VzRmllbGROYW1lKG5hbWUsIHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzLmxlbmd0aCAtIDEsIG9wdGlvbnMpO1xuICAgICAgICBpZHMuY3VycmVudCA9IGFwcGVuZEF0KGlkcy5jdXJyZW50LCBhcHBlbmRWYWx1ZS5tYXAoZ2VuZXJhdGVJZCkpO1xuICAgICAgICB1cGRhdGVWYWx1ZXModXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMpO1xuICAgICAgICBzZXRGaWVsZHModXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMpO1xuICAgICAgICBjb250cm9sLl9zZXRGaWVsZEFycmF5KG5hbWUsIHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzLCBhcHBlbmRBdCwge1xuICAgICAgICAgICAgYXJnQTogZmlsbEVtcHR5QXJyYXkodmFsdWUpLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHByZXBlbmQgPSAodmFsdWUsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgY29uc3QgcHJlcGVuZFZhbHVlID0gY29udmVydFRvQXJyYXlQYXlsb2FkKGNsb25lT2JqZWN0KHZhbHVlKSk7XG4gICAgICAgIGNvbnN0IHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzID0gcHJlcGVuZEF0KGNvbnRyb2wuX2dldEZpZWxkQXJyYXkobmFtZSksIHByZXBlbmRWYWx1ZSk7XG4gICAgICAgIGNvbnRyb2wuX25hbWVzLmZvY3VzID0gZ2V0Rm9jdXNGaWVsZE5hbWUobmFtZSwgMCwgb3B0aW9ucyk7XG4gICAgICAgIGlkcy5jdXJyZW50ID0gcHJlcGVuZEF0KGlkcy5jdXJyZW50LCBwcmVwZW5kVmFsdWUubWFwKGdlbmVyYXRlSWQpKTtcbiAgICAgICAgdXBkYXRlVmFsdWVzKHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzKTtcbiAgICAgICAgc2V0RmllbGRzKHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzKTtcbiAgICAgICAgY29udHJvbC5fc2V0RmllbGRBcnJheShuYW1lLCB1cGRhdGVkRmllbGRBcnJheVZhbHVlcywgcHJlcGVuZEF0LCB7XG4gICAgICAgICAgICBhcmdBOiBmaWxsRW1wdHlBcnJheSh2YWx1ZSksXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgcmVtb3ZlID0gKGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzID0gcmVtb3ZlQXJyYXlBdChjb250cm9sLl9nZXRGaWVsZEFycmF5KG5hbWUpLCBpbmRleCk7XG4gICAgICAgIGlkcy5jdXJyZW50ID0gcmVtb3ZlQXJyYXlBdChpZHMuY3VycmVudCwgaW5kZXgpO1xuICAgICAgICB1cGRhdGVWYWx1ZXModXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMpO1xuICAgICAgICBzZXRGaWVsZHModXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMpO1xuICAgICAgICAhQXJyYXkuaXNBcnJheShnZXQoY29udHJvbC5fZmllbGRzLCBuYW1lKSkgJiZcbiAgICAgICAgICAgIHNldChjb250cm9sLl9maWVsZHMsIG5hbWUsIHVuZGVmaW5lZCk7XG4gICAgICAgIGNvbnRyb2wuX3NldEZpZWxkQXJyYXkobmFtZSwgdXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMsIHJlbW92ZUFycmF5QXQsIHtcbiAgICAgICAgICAgIGFyZ0E6IGluZGV4LFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGluc2VydCQxID0gKGluZGV4LCB2YWx1ZSwgb3B0aW9ucykgPT4ge1xuICAgICAgICBjb25zdCBpbnNlcnRWYWx1ZSA9IGNvbnZlcnRUb0FycmF5UGF5bG9hZChjbG9uZU9iamVjdCh2YWx1ZSkpO1xuICAgICAgICBjb25zdCB1cGRhdGVkRmllbGRBcnJheVZhbHVlcyA9IGluc2VydChjb250cm9sLl9nZXRGaWVsZEFycmF5KG5hbWUpLCBpbmRleCwgaW5zZXJ0VmFsdWUpO1xuICAgICAgICBjb250cm9sLl9uYW1lcy5mb2N1cyA9IGdldEZvY3VzRmllbGROYW1lKG5hbWUsIGluZGV4LCBvcHRpb25zKTtcbiAgICAgICAgaWRzLmN1cnJlbnQgPSBpbnNlcnQoaWRzLmN1cnJlbnQsIGluZGV4LCBpbnNlcnRWYWx1ZS5tYXAoZ2VuZXJhdGVJZCkpO1xuICAgICAgICB1cGRhdGVWYWx1ZXModXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMpO1xuICAgICAgICBzZXRGaWVsZHModXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMpO1xuICAgICAgICBjb250cm9sLl9zZXRGaWVsZEFycmF5KG5hbWUsIHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzLCBpbnNlcnQsIHtcbiAgICAgICAgICAgIGFyZ0E6IGluZGV4LFxuICAgICAgICAgICAgYXJnQjogZmlsbEVtcHR5QXJyYXkodmFsdWUpLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHN3YXAgPSAoaW5kZXhBLCBpbmRleEIpID0+IHtcbiAgICAgICAgY29uc3QgdXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMgPSBjb250cm9sLl9nZXRGaWVsZEFycmF5KG5hbWUpO1xuICAgICAgICBzd2FwQXJyYXlBdCh1cGRhdGVkRmllbGRBcnJheVZhbHVlcywgaW5kZXhBLCBpbmRleEIpO1xuICAgICAgICBzd2FwQXJyYXlBdChpZHMuY3VycmVudCwgaW5kZXhBLCBpbmRleEIpO1xuICAgICAgICB1cGRhdGVWYWx1ZXModXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMpO1xuICAgICAgICBzZXRGaWVsZHModXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMpO1xuICAgICAgICBjb250cm9sLl9zZXRGaWVsZEFycmF5KG5hbWUsIHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzLCBzd2FwQXJyYXlBdCwge1xuICAgICAgICAgICAgYXJnQTogaW5kZXhBLFxuICAgICAgICAgICAgYXJnQjogaW5kZXhCLFxuICAgICAgICB9LCBmYWxzZSk7XG4gICAgfTtcbiAgICBjb25zdCBtb3ZlID0gKGZyb20sIHRvKSA9PiB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzID0gY29udHJvbC5fZ2V0RmllbGRBcnJheShuYW1lKTtcbiAgICAgICAgbW92ZUFycmF5QXQodXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMsIGZyb20sIHRvKTtcbiAgICAgICAgbW92ZUFycmF5QXQoaWRzLmN1cnJlbnQsIGZyb20sIHRvKTtcbiAgICAgICAgdXBkYXRlVmFsdWVzKHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzKTtcbiAgICAgICAgc2V0RmllbGRzKHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzKTtcbiAgICAgICAgY29udHJvbC5fc2V0RmllbGRBcnJheShuYW1lLCB1cGRhdGVkRmllbGRBcnJheVZhbHVlcywgbW92ZUFycmF5QXQsIHtcbiAgICAgICAgICAgIGFyZ0E6IGZyb20sXG4gICAgICAgICAgICBhcmdCOiB0byxcbiAgICAgICAgfSwgZmFsc2UpO1xuICAgIH07XG4gICAgY29uc3QgdXBkYXRlID0gKGluZGV4LCB2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCB1cGRhdGVWYWx1ZSA9IGNsb25lT2JqZWN0KHZhbHVlKTtcbiAgICAgICAgY29uc3QgdXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMgPSB1cGRhdGVBdChjb250cm9sLl9nZXRGaWVsZEFycmF5KG5hbWUpLCBpbmRleCwgdXBkYXRlVmFsdWUpO1xuICAgICAgICBpZHMuY3VycmVudCA9IFsuLi51cGRhdGVkRmllbGRBcnJheVZhbHVlc10ubWFwKChpdGVtLCBpKSA9PiAhaXRlbSB8fCBpID09PSBpbmRleCA/IGdlbmVyYXRlSWQoKSA6IGlkcy5jdXJyZW50W2ldKTtcbiAgICAgICAgdXBkYXRlVmFsdWVzKHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzKTtcbiAgICAgICAgc2V0RmllbGRzKFsuLi51cGRhdGVkRmllbGRBcnJheVZhbHVlc10pO1xuICAgICAgICBjb250cm9sLl9zZXRGaWVsZEFycmF5KG5hbWUsIHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzLCB1cGRhdGVBdCwge1xuICAgICAgICAgICAgYXJnQTogaW5kZXgsXG4gICAgICAgICAgICBhcmdCOiB1cGRhdGVWYWx1ZSxcbiAgICAgICAgfSwgdHJ1ZSwgZmFsc2UpO1xuICAgIH07XG4gICAgY29uc3QgcmVwbGFjZSA9ICh2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCB1cGRhdGVkRmllbGRBcnJheVZhbHVlcyA9IGNvbnZlcnRUb0FycmF5UGF5bG9hZChjbG9uZU9iamVjdCh2YWx1ZSkpO1xuICAgICAgICBpZHMuY3VycmVudCA9IHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzLm1hcChnZW5lcmF0ZUlkKTtcbiAgICAgICAgdXBkYXRlVmFsdWVzKFsuLi51cGRhdGVkRmllbGRBcnJheVZhbHVlc10pO1xuICAgICAgICBzZXRGaWVsZHMoWy4uLnVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzXSk7XG4gICAgICAgIGNvbnRyb2wuX3NldEZpZWxkQXJyYXkobmFtZSwgWy4uLnVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzXSwgKGRhdGEpID0+IGRhdGEsIHt9LCB0cnVlLCBmYWxzZSk7XG4gICAgfTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb250cm9sLl9zdGF0ZS5hY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgaXNXYXRjaGVkKG5hbWUsIGNvbnRyb2wuX25hbWVzKSAmJlxuICAgICAgICAgICAgY29udHJvbC5fc3ViamVjdHMuc3RhdGUubmV4dCh7XG4gICAgICAgICAgICAgICAgLi4uY29udHJvbC5fZm9ybVN0YXRlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGlmIChfYWN0aW9uZWQuY3VycmVudCAmJlxuICAgICAgICAgICAgKCFnZXRWYWxpZGF0aW9uTW9kZXMoY29udHJvbC5fb3B0aW9ucy5tb2RlKS5pc09uU3VibWl0IHx8XG4gICAgICAgICAgICAgICAgY29udHJvbC5fZm9ybVN0YXRlLmlzU3VibWl0dGVkKSAmJlxuICAgICAgICAgICAgIWdldFZhbGlkYXRpb25Nb2Rlcyhjb250cm9sLl9vcHRpb25zLnJlVmFsaWRhdGVNb2RlKS5pc09uU3VibWl0KSB7XG4gICAgICAgICAgICBpZiAoY29udHJvbC5fb3B0aW9ucy5yZXNvbHZlcikge1xuICAgICAgICAgICAgICAgIGNvbnRyb2wuX3J1blNjaGVtYShbbmFtZV0pLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IGdldChyZXN1bHQuZXJyb3JzLCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdFcnJvciA9IGdldChjb250cm9sLl9mb3JtU3RhdGUuZXJyb3JzLCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgID8gKCFlcnJvciAmJiBleGlzdGluZ0Vycm9yLnR5cGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGVycm9yICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChleGlzdGluZ0Vycm9yLnR5cGUgIT09IGVycm9yLnR5cGUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nRXJyb3IubWVzc2FnZSAhPT0gZXJyb3IubWVzc2FnZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGVycm9yICYmIGVycm9yLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBzZXQoY29udHJvbC5fZm9ybVN0YXRlLmVycm9ycywgbmFtZSwgZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB1bnNldChjb250cm9sLl9mb3JtU3RhdGUuZXJyb3JzLCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2wuX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yczogY29udHJvbC5fZm9ybVN0YXRlLmVycm9ycyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZCA9IGdldChjb250cm9sLl9maWVsZHMsIG5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZCAmJlxuICAgICAgICAgICAgICAgICAgICBmaWVsZC5fZiAmJlxuICAgICAgICAgICAgICAgICAgICAhKGdldFZhbGlkYXRpb25Nb2Rlcyhjb250cm9sLl9vcHRpb25zLnJlVmFsaWRhdGVNb2RlKS5pc09uU3VibWl0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRWYWxpZGF0aW9uTW9kZXMoY29udHJvbC5fb3B0aW9ucy5tb2RlKS5pc09uU3VibWl0KSkge1xuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZUZpZWxkKGZpZWxkLCBjb250cm9sLl9uYW1lcy5kaXNhYmxlZCwgY29udHJvbC5fZm9ybVZhbHVlcywgY29udHJvbC5fb3B0aW9ucy5jcml0ZXJpYU1vZGUgPT09IFZBTElEQVRJT05fTU9ERS5hbGwsIGNvbnRyb2wuX29wdGlvbnMuc2hvdWxkVXNlTmF0aXZlVmFsaWRhdGlvbiwgdHJ1ZSkudGhlbigoZXJyb3IpID0+ICFpc0VtcHR5T2JqZWN0KGVycm9yKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbC5fc3ViamVjdHMuc3RhdGUubmV4dCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzOiB1cGRhdGVGaWVsZEFycmF5Um9vdEVycm9yKGNvbnRyb2wuX2Zvcm1TdGF0ZS5lcnJvcnMsIGVycm9yLCBuYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29udHJvbC5fc3ViamVjdHMuc3RhdGUubmV4dCh7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgdmFsdWVzOiBjbG9uZU9iamVjdChjb250cm9sLl9mb3JtVmFsdWVzKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnRyb2wuX25hbWVzLmZvY3VzICYmXG4gICAgICAgICAgICBpdGVyYXRlRmllbGRzQnlBY3Rpb24oY29udHJvbC5fZmllbGRzLCAocmVmLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY29udHJvbC5fbmFtZXMuZm9jdXMgJiZcbiAgICAgICAgICAgICAgICAgICAga2V5LnN0YXJ0c1dpdGgoY29udHJvbC5fbmFtZXMuZm9jdXMpICYmXG4gICAgICAgICAgICAgICAgICAgIHJlZi5mb2N1cykge1xuICAgICAgICAgICAgICAgICAgICByZWYuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjb250cm9sLl9uYW1lcy5mb2N1cyA9ICcnO1xuICAgICAgICBjb250cm9sLl9zZXRWYWxpZCgpO1xuICAgICAgICBfYWN0aW9uZWQuY3VycmVudCA9IGZhbHNlO1xuICAgIH0sIFtmaWVsZHMsIG5hbWUsIGNvbnRyb2xdKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAhZ2V0KGNvbnRyb2wuX2Zvcm1WYWx1ZXMsIG5hbWUpICYmIGNvbnRyb2wuX3NldEZpZWxkQXJyYXkobmFtZSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVNb3VudGVkID0gKG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGQgPSBnZXQoY29udHJvbC5fZmllbGRzLCBuYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGQgJiYgZmllbGQuX2YpIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGQuX2YubW91bnQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29udHJvbC5fb3B0aW9ucy5zaG91bGRVbnJlZ2lzdGVyIHx8IHNob3VsZFVucmVnaXN0ZXJcbiAgICAgICAgICAgICAgICA/IGNvbnRyb2wudW5yZWdpc3RlcihuYW1lKVxuICAgICAgICAgICAgICAgIDogdXBkYXRlTW91bnRlZChuYW1lLCBmYWxzZSk7XG4gICAgICAgIH07XG4gICAgfSwgW25hbWUsIGNvbnRyb2wsIGtleU5hbWUsIHNob3VsZFVucmVnaXN0ZXJdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzd2FwOiBSZWFjdC51c2VDYWxsYmFjayhzd2FwLCBbdXBkYXRlVmFsdWVzLCBuYW1lLCBjb250cm9sXSksXG4gICAgICAgIG1vdmU6IFJlYWN0LnVzZUNhbGxiYWNrKG1vdmUsIFt1cGRhdGVWYWx1ZXMsIG5hbWUsIGNvbnRyb2xdKSxcbiAgICAgICAgcHJlcGVuZDogUmVhY3QudXNlQ2FsbGJhY2socHJlcGVuZCwgW3VwZGF0ZVZhbHVlcywgbmFtZSwgY29udHJvbF0pLFxuICAgICAgICBhcHBlbmQ6IFJlYWN0LnVzZUNhbGxiYWNrKGFwcGVuZCwgW3VwZGF0ZVZhbHVlcywgbmFtZSwgY29udHJvbF0pLFxuICAgICAgICByZW1vdmU6IFJlYWN0LnVzZUNhbGxiYWNrKHJlbW92ZSwgW3VwZGF0ZVZhbHVlcywgbmFtZSwgY29udHJvbF0pLFxuICAgICAgICBpbnNlcnQ6IFJlYWN0LnVzZUNhbGxiYWNrKGluc2VydCQxLCBbdXBkYXRlVmFsdWVzLCBuYW1lLCBjb250cm9sXSksXG4gICAgICAgIHVwZGF0ZTogUmVhY3QudXNlQ2FsbGJhY2sodXBkYXRlLCBbdXBkYXRlVmFsdWVzLCBuYW1lLCBjb250cm9sXSksXG4gICAgICAgIHJlcGxhY2U6IFJlYWN0LnVzZUNhbGxiYWNrKHJlcGxhY2UsIFt1cGRhdGVWYWx1ZXMsIG5hbWUsIGNvbnRyb2xdKSxcbiAgICAgICAgZmllbGRzOiBSZWFjdC51c2VNZW1vKCgpID0+IGZpZWxkcy5tYXAoKGZpZWxkLCBpbmRleCkgPT4gKHtcbiAgICAgICAgICAgIC4uLmZpZWxkLFxuICAgICAgICAgICAgW2tleU5hbWVdOiBpZHMuY3VycmVudFtpbmRleF0gfHwgZ2VuZXJhdGVJZCgpLFxuICAgICAgICB9KSksIFtmaWVsZHMsIGtleU5hbWVdKSxcbiAgICB9O1xufVxuXG4vKipcbiAqIEN1c3RvbSBob29rIHRvIG1hbmFnZSB0aGUgZW50aXJlIGZvcm0uXG4gKlxuICogQHJlbWFya3NcbiAqIFtBUEldKGh0dHBzOi8vcmVhY3QtaG9vay1mb3JtLmNvbS9kb2NzL3VzZWZvcm0pIOKAoiBbRGVtb10oaHR0cHM6Ly9jb2Rlc2FuZGJveC5pby9zL3JlYWN0LWhvb2stZm9ybS1nZXQtc3RhcnRlZC10cy01a3NtbSkg4oCiIFtWaWRlb10oaHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1Sa1h2NEFYWENfNClcbiAqXG4gKiBAcGFyYW0gcHJvcHMgLSBmb3JtIGNvbmZpZ3VyYXRpb24gYW5kIHZhbGlkYXRpb24gcGFyYW1ldGVycy5cbiAqXG4gKiBAcmV0dXJucyBtZXRob2RzIC0gaW5kaXZpZHVhbCBmdW5jdGlvbnMgdG8gbWFuYWdlIHRoZSBmb3JtIHN0YXRlLiB7QGxpbmsgVXNlRm9ybVJldHVybn1cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHN4XG4gKiBmdW5jdGlvbiBBcHAoKSB7XG4gKiAgIGNvbnN0IHsgcmVnaXN0ZXIsIGhhbmRsZVN1Ym1pdCwgd2F0Y2gsIGZvcm1TdGF0ZTogeyBlcnJvcnMgfSB9ID0gdXNlRm9ybSgpO1xuICogICBjb25zdCBvblN1Ym1pdCA9IGRhdGEgPT4gY29uc29sZS5sb2coZGF0YSk7XG4gKlxuICogICBjb25zb2xlLmxvZyh3YXRjaChcImV4YW1wbGVcIikpO1xuICpcbiAqICAgcmV0dXJuIChcbiAqICAgICA8Zm9ybSBvblN1Ym1pdD17aGFuZGxlU3VibWl0KG9uU3VibWl0KX0+XG4gKiAgICAgICA8aW5wdXQgZGVmYXVsdFZhbHVlPVwidGVzdFwiIHsuLi5yZWdpc3RlcihcImV4YW1wbGVcIil9IC8+XG4gKiAgICAgICA8aW5wdXQgey4uLnJlZ2lzdGVyKFwiZXhhbXBsZVJlcXVpcmVkXCIsIHsgcmVxdWlyZWQ6IHRydWUgfSl9IC8+XG4gKiAgICAgICB7ZXJyb3JzLmV4YW1wbGVSZXF1aXJlZCAmJiA8c3Bhbj5UaGlzIGZpZWxkIGlzIHJlcXVpcmVkPC9zcGFuPn1cbiAqICAgICAgIDxidXR0b24+U3VibWl0PC9idXR0b24+XG4gKiAgICAgPC9mb3JtPlxuICogICApO1xuICogfVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIHVzZUZvcm0ocHJvcHMgPSB7fSkge1xuICAgIGNvbnN0IF9mb3JtQ29udHJvbCA9IFJlYWN0LnVzZVJlZih1bmRlZmluZWQpO1xuICAgIGNvbnN0IF92YWx1ZXMgPSBSZWFjdC51c2VSZWYodW5kZWZpbmVkKTtcbiAgICBjb25zdCBbZm9ybVN0YXRlLCB1cGRhdGVGb3JtU3RhdGVdID0gUmVhY3QudXNlU3RhdGUoe1xuICAgICAgICBpc0RpcnR5OiBmYWxzZSxcbiAgICAgICAgaXNWYWxpZGF0aW5nOiBmYWxzZSxcbiAgICAgICAgaXNMb2FkaW5nOiBpc0Z1bmN0aW9uKHByb3BzLmRlZmF1bHRWYWx1ZXMpLFxuICAgICAgICBpc1N1Ym1pdHRlZDogZmFsc2UsXG4gICAgICAgIGlzU3VibWl0dGluZzogZmFsc2UsXG4gICAgICAgIGlzU3VibWl0U3VjY2Vzc2Z1bDogZmFsc2UsXG4gICAgICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgICAgICBzdWJtaXRDb3VudDogMCxcbiAgICAgICAgZGlydHlGaWVsZHM6IHt9LFxuICAgICAgICB0b3VjaGVkRmllbGRzOiB7fSxcbiAgICAgICAgdmFsaWRhdGluZ0ZpZWxkczoge30sXG4gICAgICAgIGVycm9yczogcHJvcHMuZXJyb3JzIHx8IHt9LFxuICAgICAgICBkaXNhYmxlZDogcHJvcHMuZGlzYWJsZWQgfHwgZmFsc2UsXG4gICAgICAgIGlzUmVhZHk6IGZhbHNlLFxuICAgICAgICBkZWZhdWx0VmFsdWVzOiBpc0Z1bmN0aW9uKHByb3BzLmRlZmF1bHRWYWx1ZXMpXG4gICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgOiBwcm9wcy5kZWZhdWx0VmFsdWVzLFxuICAgIH0pO1xuICAgIGlmICghX2Zvcm1Db250cm9sLmN1cnJlbnQpIHtcbiAgICAgICAgaWYgKHByb3BzLmZvcm1Db250cm9sKSB7XG4gICAgICAgICAgICBfZm9ybUNvbnRyb2wuY3VycmVudCA9IHtcbiAgICAgICAgICAgICAgICAuLi5wcm9wcy5mb3JtQ29udHJvbCxcbiAgICAgICAgICAgICAgICBmb3JtU3RhdGUsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZXMgJiYgIWlzRnVuY3Rpb24ocHJvcHMuZGVmYXVsdFZhbHVlcykpIHtcbiAgICAgICAgICAgICAgICBwcm9wcy5mb3JtQ29udHJvbC5yZXNldChwcm9wcy5kZWZhdWx0VmFsdWVzLCBwcm9wcy5yZXNldE9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgeyBmb3JtQ29udHJvbCwgLi4ucmVzdCB9ID0gY3JlYXRlRm9ybUNvbnRyb2wocHJvcHMpO1xuICAgICAgICAgICAgX2Zvcm1Db250cm9sLmN1cnJlbnQgPSB7XG4gICAgICAgICAgICAgICAgLi4ucmVzdCxcbiAgICAgICAgICAgICAgICBmb3JtU3RhdGUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGNvbnRyb2wgPSBfZm9ybUNvbnRyb2wuY3VycmVudC5jb250cm9sO1xuICAgIGNvbnRyb2wuX29wdGlvbnMgPSBwcm9wcztcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3Qgc3ViID0gY29udHJvbC5fc3Vic2NyaWJlKHtcbiAgICAgICAgICAgIGZvcm1TdGF0ZTogY29udHJvbC5fcHJveHlGb3JtU3RhdGUsXG4gICAgICAgICAgICBjYWxsYmFjazogKCkgPT4gdXBkYXRlRm9ybVN0YXRlKHsgLi4uY29udHJvbC5fZm9ybVN0YXRlIH0pLFxuICAgICAgICAgICAgcmVSZW5kZXJSb290OiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgdXBkYXRlRm9ybVN0YXRlKChkYXRhKSA9PiAoe1xuICAgICAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgICAgIGlzUmVhZHk6IHRydWUsXG4gICAgICAgIH0pKTtcbiAgICAgICAgY29udHJvbC5fZm9ybVN0YXRlLmlzUmVhZHkgPSB0cnVlO1xuICAgICAgICByZXR1cm4gc3ViO1xuICAgIH0sIFtjb250cm9sXSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IGNvbnRyb2wuX2Rpc2FibGVGb3JtKHByb3BzLmRpc2FibGVkKSwgW2NvbnRyb2wsIHByb3BzLmRpc2FibGVkXSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHByb3BzLm1vZGUpIHtcbiAgICAgICAgICAgIGNvbnRyb2wuX29wdGlvbnMubW9kZSA9IHByb3BzLm1vZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BzLnJlVmFsaWRhdGVNb2RlKSB7XG4gICAgICAgICAgICBjb250cm9sLl9vcHRpb25zLnJlVmFsaWRhdGVNb2RlID0gcHJvcHMucmVWYWxpZGF0ZU1vZGU7XG4gICAgICAgIH1cbiAgICB9LCBbY29udHJvbCwgcHJvcHMubW9kZSwgcHJvcHMucmVWYWxpZGF0ZU1vZGVdKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAocHJvcHMuZXJyb3JzKSB7XG4gICAgICAgICAgICBjb250cm9sLl9zZXRFcnJvcnMocHJvcHMuZXJyb3JzKTtcbiAgICAgICAgICAgIGNvbnRyb2wuX2ZvY3VzRXJyb3IoKTtcbiAgICAgICAgfVxuICAgIH0sIFtjb250cm9sLCBwcm9wcy5lcnJvcnNdKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBwcm9wcy5zaG91bGRVbnJlZ2lzdGVyICYmXG4gICAgICAgICAgICBjb250cm9sLl9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IGNvbnRyb2wuX2dldFdhdGNoKCksXG4gICAgICAgICAgICB9KTtcbiAgICB9LCBbY29udHJvbCwgcHJvcHMuc2hvdWxkVW5yZWdpc3Rlcl0pO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChjb250cm9sLl9wcm94eUZvcm1TdGF0ZS5pc0RpcnR5KSB7XG4gICAgICAgICAgICBjb25zdCBpc0RpcnR5ID0gY29udHJvbC5fZ2V0RGlydHkoKTtcbiAgICAgICAgICAgIGlmIChpc0RpcnR5ICE9PSBmb3JtU3RhdGUuaXNEaXJ0eSkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2wuX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgICAgICAgICBpc0RpcnR5LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW2NvbnRyb2wsIGZvcm1TdGF0ZS5pc0RpcnR5XSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAocHJvcHMudmFsdWVzICYmICFkZWVwRXF1YWwocHJvcHMudmFsdWVzLCBfdmFsdWVzLmN1cnJlbnQpKSB7XG4gICAgICAgICAgICBjb250cm9sLl9yZXNldChwcm9wcy52YWx1ZXMsIHtcbiAgICAgICAgICAgICAgICBrZWVwRmllbGRzUmVmOiB0cnVlLFxuICAgICAgICAgICAgICAgIC4uLmNvbnRyb2wuX29wdGlvbnMucmVzZXRPcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoISgoX2EgPSBjb250cm9sLl9vcHRpb25zLnJlc2V0T3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmtlZXBJc1ZhbGlkKSkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2wuX3NldFZhbGlkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdmFsdWVzLmN1cnJlbnQgPSBwcm9wcy52YWx1ZXM7XG4gICAgICAgICAgICB1cGRhdGVGb3JtU3RhdGUoKHN0YXRlKSA9PiAoeyAuLi5zdGF0ZSB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb250cm9sLl9yZXNldERlZmF1bHRWYWx1ZXMoKTtcbiAgICAgICAgfVxuICAgIH0sIFtjb250cm9sLCBwcm9wcy52YWx1ZXNdKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIWNvbnRyb2wuX3N0YXRlLm1vdW50KSB7XG4gICAgICAgICAgICBjb250cm9sLl9zZXRWYWxpZCgpO1xuICAgICAgICAgICAgY29udHJvbC5fc3RhdGUubW91bnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250cm9sLl9zdGF0ZS53YXRjaCkge1xuICAgICAgICAgICAgY29udHJvbC5fc3RhdGUud2F0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnRyb2wuX3N1YmplY3RzLnN0YXRlLm5leHQoeyAuLi5jb250cm9sLl9mb3JtU3RhdGUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29udHJvbC5fcmVtb3ZlVW5tb3VudGVkKCk7XG4gICAgfSk7XG4gICAgX2Zvcm1Db250cm9sLmN1cnJlbnQuZm9ybVN0YXRlID0gZ2V0UHJveHlGb3JtU3RhdGUoZm9ybVN0YXRlLCBjb250cm9sKTtcbiAgICByZXR1cm4gX2Zvcm1Db250cm9sLmN1cnJlbnQ7XG59XG5cbi8qKlxuICogV2F0Y2ggY29tcG9uZW50IHRoYXQgc3Vic2NyaWJlcyB0byBmb3JtIGZpZWxkIGNoYW5nZXMgYW5kIHJlLXJlbmRlcnMgd2hlbiB3YXRjaGVkIGZpZWxkcyB1cGRhdGUuXG4gKlxuICogQHBhcmFtIGNvbnRyb2wgLSBUaGUgZm9ybSBjb250cm9sIG9iamVjdCBmcm9tIHVzZUZvcm1cbiAqIEBwYXJhbSBuYW1lcyAtIEFycmF5IG9mIGZpZWxkIG5hbWVzIHRvIHdhdGNoIGZvciBjaGFuZ2VzXG4gKiBAcGFyYW0gcmVuZGVyIC0gVGhlIGZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgd2F0Y2hlZCB2YWx1ZXMgYW5kIHJldHVybnMgUmVhY3ROb2RlXG4gKiBAcmV0dXJucyBUaGUgcmVzdWx0IG9mIGNhbGxpbmcgcmVuZGVyIGZ1bmN0aW9uIHdpdGggd2F0Y2hlZCB2YWx1ZXNcbiAqXG4gKiBAZXhhbXBsZVxuICogVGhlIGBXYXRjaGAgY29tcG9uZW50IG9ubHkgcmUtcmVuZGVyIHdoZW4gdGhlIHZhbHVlcyBvZiBgZm9vYCwgYGJhcmAsIGFuZCBgYmF6LnF1eGAgY2hhbmdlLlxuICogVGhlIHR5cGVzIG9mIGBmb29gLCBgYmFyYCwgYW5kIGBiYXoucXV4YCBhcmUgcHJlY2lzZWx5IGluZmVycmVkLlxuICpcbiAqIGBgYHRzeFxuICogY29uc3QgeyBjb250cm9sIH0gPSB1c2VGb3JtKCk7XG4gKlxuICogPFdhdGNoXG4gKiAgIGNvbnRyb2w9e2NvbnRyb2x9XG4gKiAgIG5hbWVzPXtbJ2ZvbycsICdiYXInLCAnYmF6LnF1eCddfVxuICogICByZW5kZXI9eyhbZm9vLCBiYXIsIGJhel9xdXhdKSA9PiA8ZGl2Pntmb299e2Jhcn17YmF6X3F1eH08L2Rpdj59XG4gKiAvPlxuICogYGBgXG4gKi9cbmNvbnN0IFdhdGNoID0gKHsgY29udHJvbCwgbmFtZXMsIHJlbmRlciwgfSkgPT4gcmVuZGVyKHVzZVdhdGNoKHsgY29udHJvbCwgbmFtZTogbmFtZXMgfSkpO1xuXG5leHBvcnQgeyBDb250cm9sbGVyLCBGb3JtLCBGb3JtUHJvdmlkZXIsIFdhdGNoLCBhcHBlbmRFcnJvcnMsIGNyZWF0ZUZvcm1Db250cm9sLCBnZXQsIHNldCwgdXNlQ29udHJvbGxlciwgdXNlRmllbGRBcnJheSwgdXNlRm9ybSwgdXNlRm9ybUNvbnRleHQsIHVzZUZvcm1TdGF0ZSwgdXNlV2F0Y2ggfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzbS5tanMubWFwXG4iXSwibmFtZXMiOlsiUmVhY3QiLCJpc0NoZWNrQm94SW5wdXQiLCJlbGVtZW50IiwidHlwZSIsImlzRGF0ZU9iamVjdCIsInZhbHVlIiwiRGF0ZSIsImlzTnVsbE9yVW5kZWZpbmVkIiwiaXNPYmplY3RUeXBlIiwiaXNPYmplY3QiLCJBcnJheSIsImlzQXJyYXkiLCJnZXRFdmVudFZhbHVlIiwiZXZlbnQiLCJ0YXJnZXQiLCJjaGVja2VkIiwiZ2V0Tm9kZVBhcmVudE5hbWUiLCJuYW1lIiwic3Vic3RyaW5nIiwic2VhcmNoIiwiaXNOYW1lSW5GaWVsZEFycmF5IiwibmFtZXMiLCJoYXMiLCJpc1BsYWluT2JqZWN0IiwidGVtcE9iamVjdCIsInByb3RvdHlwZUNvcHkiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiaXNXZWIiLCJ3aW5kb3ciLCJIVE1MRWxlbWVudCIsImRvY3VtZW50IiwiY2xvbmVPYmplY3QiLCJkYXRhIiwiY29weSIsImlzRmlsZUxpc3RJbnN0YW5jZSIsIkZpbGVMaXN0IiwiQmxvYiIsIk9iamVjdCIsImNyZWF0ZSIsImdldFByb3RvdHlwZU9mIiwia2V5IiwiaXNLZXkiLCJ0ZXN0IiwiaXNVbmRlZmluZWQiLCJ2YWwiLCJ1bmRlZmluZWQiLCJjb21wYWN0IiwiZmlsdGVyIiwiQm9vbGVhbiIsInN0cmluZ1RvUGF0aCIsImlucHV0IiwicmVwbGFjZSIsInNwbGl0IiwiZ2V0Iiwib2JqZWN0IiwicGF0aCIsImRlZmF1bHRWYWx1ZSIsInJlc3VsdCIsInJlZHVjZSIsImlzQm9vbGVhbiIsInNldCIsImluZGV4IiwidGVtcFBhdGgiLCJsZW5ndGgiLCJsYXN0SW5kZXgiLCJuZXdWYWx1ZSIsIm9ialZhbHVlIiwiaXNOYU4iLCJFVkVOVFMiLCJCTFVSIiwiRk9DVVNfT1VUIiwiQ0hBTkdFIiwiVkFMSURBVElPTl9NT0RFIiwib25CbHVyIiwib25DaGFuZ2UiLCJvblN1Ym1pdCIsIm9uVG91Y2hlZCIsImFsbCIsIklOUFVUX1ZBTElEQVRJT05fUlVMRVMiLCJtYXgiLCJtaW4iLCJtYXhMZW5ndGgiLCJtaW5MZW5ndGgiLCJwYXR0ZXJuIiwicmVxdWlyZWQiLCJ2YWxpZGF0ZSIsIkhvb2tGb3JtQ29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCJkaXNwbGF5TmFtZSIsInVzZUZvcm1Db250ZXh0IiwidXNlQ29udGV4dCIsIkZvcm1Qcm92aWRlciIsInByb3BzIiwiY2hpbGRyZW4iLCJjcmVhdGVFbGVtZW50IiwiUHJvdmlkZXIiLCJnZXRQcm94eUZvcm1TdGF0ZSIsImZvcm1TdGF0ZSIsImNvbnRyb2wiLCJsb2NhbFByb3h5Rm9ybVN0YXRlIiwiaXNSb290IiwiZGVmYXVsdFZhbHVlcyIsIl9kZWZhdWx0VmFsdWVzIiwiZGVmaW5lUHJvcGVydHkiLCJfa2V5IiwiX3Byb3h5Rm9ybVN0YXRlIiwidXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCIsInVzZUxheW91dEVmZmVjdCIsInVzZUVmZmVjdCIsInVzZUZvcm1TdGF0ZSIsIm1ldGhvZHMiLCJkaXNhYmxlZCIsImV4YWN0IiwidXBkYXRlRm9ybVN0YXRlIiwidXNlU3RhdGUiLCJfZm9ybVN0YXRlIiwiX2xvY2FsUHJveHlGb3JtU3RhdGUiLCJ1c2VSZWYiLCJpc0RpcnR5IiwiaXNMb2FkaW5nIiwiZGlydHlGaWVsZHMiLCJ0b3VjaGVkRmllbGRzIiwidmFsaWRhdGluZ0ZpZWxkcyIsImlzVmFsaWRhdGluZyIsImlzVmFsaWQiLCJlcnJvcnMiLCJfc3Vic2NyaWJlIiwiY3VycmVudCIsImNhbGxiYWNrIiwiX3NldFZhbGlkIiwidXNlTWVtbyIsImlzU3RyaW5nIiwiZ2VuZXJhdGVXYXRjaE91dHB1dCIsIl9uYW1lcyIsImZvcm1WYWx1ZXMiLCJpc0dsb2JhbCIsIndhdGNoIiwiYWRkIiwibWFwIiwiZmllbGROYW1lIiwid2F0Y2hBbGwiLCJpc1ByaW1pdGl2ZSIsImRlZXBFcXVhbCIsIm9iamVjdDEiLCJvYmplY3QyIiwiX2ludGVybmFsX3Zpc2l0ZWQiLCJXZWFrU2V0IiwiaXMiLCJnZXRUaW1lIiwia2V5czEiLCJrZXlzIiwia2V5czIiLCJ2YWwxIiwiaW5jbHVkZXMiLCJ2YWwyIiwidXNlV2F0Y2giLCJjb21wdXRlIiwiX2RlZmF1bHRWYWx1ZSIsIl9jb21wdXRlIiwiX2NvbXB1dGVGb3JtVmFsdWVzIiwiX3ByZXZDb250cm9sIiwiX3ByZXZOYW1lIiwidXBkYXRlVmFsdWUiLCJfZ2V0V2F0Y2giLCJnZXRDdXJyZW50T3V0cHV0IiwidXNlQ2FsbGJhY2siLCJ2YWx1ZXMiLCJfZm9ybVZhbHVlcyIsInJlZnJlc2hWYWx1ZSIsImNvbXB1dGVkRm9ybVZhbHVlcyIsIl9yZW1vdmVVbm1vdW50ZWQiLCJjb250cm9sQ2hhbmdlZCIsInByZXZOYW1lIiwiY29tcHV0ZWRPdXRwdXQiLCJuYW1lQ2hhbmdlZCIsInNob3VsZFJldHVybkltbWVkaWF0ZSIsInVzZUNvbnRyb2xsZXIiLCJzaG91bGRVbnJlZ2lzdGVyIiwiaXNBcnJheUZpZWxkIiwiYXJyYXkiLCJkZWZhdWx0VmFsdWVNZW1vIiwiX3Byb3BzIiwiX3ByZXZpb3VzTmFtZVJlZiIsIl9yZWdpc3RlclByb3BzIiwicmVnaXN0ZXIiLCJydWxlcyIsImZpZWxkU3RhdGUiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiaW52YWxpZCIsImVudW1lcmFibGUiLCJpc1RvdWNoZWQiLCJlcnJvciIsInJlZiIsImVsbSIsImZpZWxkIiwiX2ZpZWxkcyIsIl9mIiwiZm9jdXMiLCJzZWxlY3QiLCJzZXRDdXN0b21WYWxpZGl0eSIsIm1lc3NhZ2UiLCJyZXBvcnRWYWxpZGl0eSIsIl9zaG91bGRVbnJlZ2lzdGVyRmllbGQiLCJfb3B0aW9ucyIsInByZXZpb3VzTmFtZSIsInVucmVnaXN0ZXIiLCJ1cGRhdGVNb3VudGVkIiwibW91bnQiLCJfc3RhdGUiLCJhY3Rpb24iLCJfc2V0RGlzYWJsZWRGaWVsZCIsIkNvbnRyb2xsZXIiLCJyZW5kZXIiLCJmbGF0dGVuIiwib2JqIiwib3V0cHV0IiwibmVzdGVkIiwibmVzdGVkS2V5IiwiUE9TVF9SRVFVRVNUIiwiRm9ybSIsIm1vdW50ZWQiLCJzZXRNb3VudGVkIiwibWV0aG9kIiwiaGVhZGVycyIsImVuY1R5cGUiLCJvbkVycm9yIiwib25TdWNjZXNzIiwidmFsaWRhdGVTdGF0dXMiLCJyZXN0Iiwic3VibWl0IiwiaGFzRXJyb3IiLCJoYW5kbGVTdWJtaXQiLCJmb3JtRGF0YSIsIkZvcm1EYXRhIiwiZm9ybURhdGFKc29uIiwiSlNPTiIsInN0cmluZ2lmeSIsIl9hIiwiZmxhdHRlbkZvcm1WYWx1ZXMiLCJhcHBlbmQiLCJzaG91bGRTdHJpbmdpZnlTdWJtaXNzaW9uRGF0YSIsInNvbWUiLCJyZXNwb25zZSIsImZldGNoIiwiU3RyaW5nIiwiYm9keSIsInN0YXR1cyIsIl9zdWJqZWN0cyIsInN0YXRlIiwibmV4dCIsImlzU3VibWl0U3VjY2Vzc2Z1bCIsInNldEVycm9yIiwiRnJhZ21lbnQiLCJub1ZhbGlkYXRlIiwiYXBwZW5kRXJyb3JzIiwidmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhIiwidHlwZXMiLCJjb252ZXJ0VG9BcnJheVBheWxvYWQiLCJjcmVhdGVTdWJqZWN0IiwiX29ic2VydmVycyIsIm9ic2VydmVyIiwic3Vic2NyaWJlIiwicHVzaCIsInVuc3Vic2NyaWJlIiwibyIsIm9ic2VydmVycyIsImV4dHJhY3RGb3JtVmFsdWVzIiwiZmllbGRzU3RhdGUiLCJmaWVsZFZhbHVlIiwibmVzdGVkRmllbGRzU3RhdGUiLCJpc0VtcHR5T2JqZWN0IiwiaXNGaWxlSW5wdXQiLCJpc0Z1bmN0aW9uIiwiaXNIVE1MRWxlbWVudCIsIm93bmVyIiwib3duZXJEb2N1bWVudCIsImRlZmF1bHRWaWV3IiwiaXNNdWx0aXBsZVNlbGVjdCIsImlzUmFkaW9JbnB1dCIsImlzUmFkaW9PckNoZWNrYm94IiwibGl2ZSIsImlzQ29ubmVjdGVkIiwiYmFzZUdldCIsInVwZGF0ZVBhdGgiLCJzbGljZSIsImlzRW1wdHlBcnJheSIsInVuc2V0IiwicGF0aHMiLCJjaGlsZE9iamVjdCIsIm9iamVjdEhhc0Z1bmN0aW9uIiwiaXNUcmF2ZXJzYWJsZSIsIm1hcmtGaWVsZHNEaXJ0eSIsImZpZWxkcyIsImdldERpcnR5RmllbGRzIiwiZGlydHlGaWVsZHNGcm9tVmFsdWVzIiwiZm9ybVZhbHVlIiwiZGVmYXVsdFJlc3VsdCIsInZhbGlkUmVzdWx0IiwiZ2V0Q2hlY2tib3hWYWx1ZSIsIm9wdGlvbnMiLCJvcHRpb24iLCJhdHRyaWJ1dGVzIiwiZ2V0RmllbGRWYWx1ZUFzIiwidmFsdWVBc051bWJlciIsInZhbHVlQXNEYXRlIiwic2V0VmFsdWVBcyIsIk5hTiIsImRlZmF1bHRSZXR1cm4iLCJnZXRSYWRpb1ZhbHVlIiwicHJldmlvdXMiLCJnZXRGaWVsZFZhbHVlIiwiZmlsZXMiLCJyZWZzIiwic2VsZWN0ZWRPcHRpb25zIiwiZ2V0UmVzb2x2ZXJPcHRpb25zIiwiZmllbGRzTmFtZXMiLCJjcml0ZXJpYU1vZGUiLCJzaG91bGRVc2VOYXRpdmVWYWxpZGF0aW9uIiwiaXNSZWdleCIsIlJlZ0V4cCIsImdldFJ1bGVWYWx1ZSIsInJ1bGUiLCJzb3VyY2UiLCJnZXRWYWxpZGF0aW9uTW9kZXMiLCJtb2RlIiwiaXNPblN1Ym1pdCIsImlzT25CbHVyIiwiaXNPbkNoYW5nZSIsImlzT25BbGwiLCJpc09uVG91Y2giLCJBU1lOQ19GVU5DVElPTiIsImhhc1Byb21pc2VWYWxpZGF0aW9uIiwiZmllbGRSZWZlcmVuY2UiLCJmaW5kIiwidmFsaWRhdGVGdW5jdGlvbiIsImhhc1ZhbGlkYXRpb24iLCJpc1dhdGNoZWQiLCJpc0JsdXJFdmVudCIsIndhdGNoTmFtZSIsInN0YXJ0c1dpdGgiLCJpdGVyYXRlRmllbGRzQnlBY3Rpb24iLCJhYm9ydEVhcmx5IiwiY3VycmVudEZpZWxkIiwic2NoZW1hRXJyb3JMb29rdXAiLCJqb2luIiwiZm91bmRFcnJvciIsInJvb3QiLCJwb3AiLCJzaG91bGRSZW5kZXJGb3JtU3RhdGUiLCJmb3JtU3RhdGVEYXRhIiwic2hvdWxkU3Vic2NyaWJlQnlOYW1lIiwic2lnbmFsTmFtZSIsImN1cnJlbnROYW1lIiwic2tpcFZhbGlkYXRpb24iLCJpc1N1Ym1pdHRlZCIsInJlVmFsaWRhdGVNb2RlIiwidW5zZXRFbXB0eUFycmF5IiwidXBkYXRlRmllbGRBcnJheVJvb3RFcnJvciIsImZpZWxkQXJyYXlFcnJvcnMiLCJnZXRWYWxpZGF0ZUVycm9yIiwiZXZlcnkiLCJnZXRWYWx1ZUFuZE1lc3NhZ2UiLCJ2YWxpZGF0aW9uRGF0YSIsInZhbGlkYXRlRmllbGQiLCJkaXNhYmxlZEZpZWxkTmFtZXMiLCJpc0ZpZWxkQXJyYXkiLCJpbnB1dFZhbHVlIiwiaW5wdXRSZWYiLCJpc1JhZGlvIiwiaXNDaGVja0JveCIsImlzRW1wdHkiLCJhcHBlbmRFcnJvcnNDdXJyeSIsImJpbmQiLCJnZXRNaW5NYXhNZXNzYWdlIiwiZXhjZWVkTWF4IiwibWF4TGVuZ3RoTWVzc2FnZSIsIm1pbkxlbmd0aE1lc3NhZ2UiLCJtYXhUeXBlIiwibWluVHlwZSIsImV4Y2VlZE1pbiIsIm1heE91dHB1dCIsIm1pbk91dHB1dCIsInZhbHVlTnVtYmVyIiwidmFsdWVEYXRlIiwiY29udmVydFRpbWVUb0RhdGUiLCJ0aW1lIiwidG9EYXRlU3RyaW5nIiwiaXNUaW1lIiwiaXNXZWVrIiwibWF4TGVuZ3RoT3V0cHV0IiwibWluTGVuZ3RoT3V0cHV0IiwicGF0dGVyblZhbHVlIiwibWF0Y2giLCJ2YWxpZGF0ZUVycm9yIiwidmFsaWRhdGlvblJlc3VsdCIsImRlZmF1bHRPcHRpb25zIiwic2hvdWxkRm9jdXNFcnJvciIsImNyZWF0ZUZvcm1Db250cm9sIiwic3VibWl0Q291bnQiLCJpc1JlYWR5IiwiaXNTdWJtaXR0aW5nIiwiU2V0IiwidW5Nb3VudCIsImRlbGF5RXJyb3JDYWxsYmFjayIsInRpbWVyIiwiX3Byb3h5U3Vic2NyaWJlRm9ybVN0YXRlIiwic2hvdWxkRGlzcGxheUFsbEFzc29jaWF0ZWRFcnJvcnMiLCJkZWJvdW5jZSIsIndhaXQiLCJjbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0Iiwic2hvdWxkVXBkYXRlVmFsaWQiLCJyZXNvbHZlciIsIl9ydW5TY2hlbWEiLCJleGVjdXRlQnVpbHRJblZhbGlkYXRpb24iLCJfdXBkYXRlSXNWYWxpZGF0aW5nIiwiZnJvbSIsImZvckVhY2giLCJfc2V0RmllbGRBcnJheSIsImFyZ3MiLCJzaG91bGRTZXRWYWx1ZXMiLCJzaG91bGRVcGRhdGVGaWVsZHNBbmRTdGF0ZSIsImZpZWxkVmFsdWVzIiwiYXJnQSIsImFyZ0IiLCJfZ2V0RGlydHkiLCJ1cGRhdGVFcnJvcnMiLCJfc2V0RXJyb3JzIiwidXBkYXRlVmFsaWRBbmRWYWx1ZSIsInNob3VsZFNraXBTZXRWYWx1ZUFzIiwiZGVmYXVsdENoZWNrZWQiLCJzZXRGaWVsZFZhbHVlIiwidXBkYXRlVG91Y2hBbmREaXJ0eSIsInNob3VsZERpcnR5Iiwic2hvdWxkUmVuZGVyIiwic2hvdWxkVXBkYXRlRmllbGQiLCJpc1ByZXZpb3VzRGlydHkiLCJpc0N1cnJlbnRGaWVsZFByaXN0aW5lIiwiaXNQcmV2aW91c0ZpZWxkVG91Y2hlZCIsInNob3VsZFJlbmRlckJ5RXJyb3IiLCJwcmV2aW91c0ZpZWxkRXJyb3IiLCJkZWxheUVycm9yIiwidXBkYXRlZEZvcm1TdGF0ZSIsImNvbnRleHQiLCJleGVjdXRlU2NoZW1hQW5kVXBkYXRlU3RhdGUiLCJzaG91bGRPbmx5Q2hlY2tWYWxpZCIsInZhbGlkIiwiaXNGaWVsZEFycmF5Um9vdCIsImlzUHJvbWlzZUZ1bmN0aW9uIiwiZmllbGRFcnJvciIsImdldFZhbHVlcyIsIl9nZXRGaWVsZEFycmF5Iiwib3B0aW9uUmVmIiwic2VsZWN0ZWQiLCJjaGVja2JveFJlZiIsInJhZGlvUmVmIiwic2hvdWxkVG91Y2giLCJzaG91bGRWYWxpZGF0ZSIsInRyaWdnZXIiLCJzZXRWYWx1ZXMiLCJmaWVsZEtleSIsInNldFZhbHVlIiwiY2xvbmVWYWx1ZSIsImlzRmllbGRWYWx1ZVVwZGF0ZWQiLCJfdXBkYXRlSXNGaWVsZFZhbHVlVXBkYXRlZCIsIk51bWJlciIsInZhbGlkYXRpb25Nb2RlQmVmb3JlU3VibWl0IiwidmFsaWRhdGlvbk1vZGVBZnRlclN1Ym1pdCIsInNob3VsZFNraXBWYWxpZGF0aW9uIiwiZGVwcyIsIndhdGNoZWQiLCJyZWFkT25seSIsInByZXZpb3VzRXJyb3JMb29rdXBSZXN1bHQiLCJlcnJvckxvb2t1cFJlc3VsdCIsIl9mb2N1c0lucHV0IiwiZmllbGROYW1lcyIsIlByb21pc2UiLCJzaG91bGRGb2N1cyIsImNvbmZpZyIsImdldEZpZWxkU3RhdGUiLCJjbGVhckVycm9ycyIsImlucHV0TmFtZSIsImN1cnJlbnRFcnJvciIsImN1cnJlbnRSZWYiLCJyZXN0T2ZFcnJvclRyZWUiLCJwYXlsb2FkIiwiX3NldEZvcm1TdGF0ZSIsInJlUmVuZGVyUm9vdCIsImRlbGV0ZSIsImtlZXBWYWx1ZSIsImtlZXBFcnJvciIsImtlZXBEaXJ0eSIsImtlZXBUb3VjaGVkIiwia2VlcElzVmFsaWRhdGluZyIsImtlZXBEZWZhdWx0VmFsdWUiLCJrZWVwSXNWYWxpZCIsImRpc2FibGVkSXNEZWZpbmVkIiwicHJvZ3Jlc3NpdmUiLCJmaWVsZFJlZiIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJyYWRpb09yQ2hlY2tib3giLCJfZm9jdXNFcnJvciIsIl9kaXNhYmxlRm9ybSIsIm9uVmFsaWQiLCJvbkludmFsaWQiLCJlIiwib25WYWxpZEVycm9yIiwicHJldmVudERlZmF1bHQiLCJwZXJzaXN0Iiwic2l6ZSIsInJlc2V0RmllbGQiLCJfcmVzZXQiLCJrZWVwU3RhdGVPcHRpb25zIiwidXBkYXRlZFZhbHVlcyIsImNsb25lVXBkYXRlZFZhbHVlcyIsImlzRW1wdHlSZXNldFZhbHVlcyIsImtlZXBEZWZhdWx0VmFsdWVzIiwia2VlcFZhbHVlcyIsImtlZXBEaXJ0eVZhbHVlcyIsImZpZWxkc1RvQ2hlY2siLCJmb3JtIiwiY2xvc2VzdCIsInJlc2V0Iiwia2VlcEZpZWxkc1JlZiIsImtlZXBTdWJtaXRDb3VudCIsImtlZXBJc1N1Ym1pdHRlZCIsImtlZXBFcnJvcnMiLCJrZWVwSXNTdWJtaXRTdWNjZXNzZnVsIiwic2V0Rm9jdXMiLCJzaG91bGRTZWxlY3QiLCJfcmVzZXREZWZhdWx0VmFsdWVzIiwidGhlbiIsInJlc2V0T3B0aW9ucyIsImZvcm1Db250cm9sIiwiZ2VuZXJhdGVJZCIsImNyeXB0byIsInJhbmRvbVVVSUQiLCJkIiwicGVyZm9ybWFuY2UiLCJub3ciLCJjIiwiciIsIk1hdGgiLCJyYW5kb20iLCJ0b1N0cmluZyIsImdldEZvY3VzRmllbGROYW1lIiwiZm9jdXNOYW1lIiwiZm9jdXNJbmRleCIsImFwcGVuZEF0IiwiZmlsbEVtcHR5QXJyYXkiLCJpbnNlcnQiLCJtb3ZlQXJyYXlBdCIsInRvIiwic3BsaWNlIiwicHJlcGVuZEF0IiwicmVtb3ZlQXRJbmRleGVzIiwiaW5kZXhlcyIsImkiLCJ0ZW1wIiwicmVtb3ZlQXJyYXlBdCIsInNvcnQiLCJhIiwiYiIsInN3YXBBcnJheUF0IiwiaW5kZXhBIiwiaW5kZXhCIiwidXBkYXRlQXQiLCJ1c2VGaWVsZEFycmF5Iiwia2V5TmFtZSIsInNldEZpZWxkcyIsImlkcyIsIl9hY3Rpb25lZCIsImZpZWxkQXJyYXlOYW1lIiwidXBkYXRlVmFsdWVzIiwidXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMiLCJhcHBlbmRWYWx1ZSIsInByZXBlbmQiLCJwcmVwZW5kVmFsdWUiLCJyZW1vdmUiLCJpbnNlcnQkMSIsImluc2VydFZhbHVlIiwic3dhcCIsIm1vdmUiLCJ1cGRhdGUiLCJpdGVtIiwiZXhpc3RpbmdFcnJvciIsInVzZUZvcm0iLCJfZm9ybUNvbnRyb2wiLCJfdmFsdWVzIiwic3ViIiwiV2F0Y2giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-hook-form/dist/index.esm.mjs\n");

/***/ })

};
;